# Simplified Chinese translation of coreutils.
# Copyright (C) 1998, 2002, 2004, 2005, 2009, 2010, 2011 Free Software Foundation, Inc.
# This file is distributed under the same license as the coreutils package.
# Yip Chi Lap <clyip@cs.hku.hk>, 1998.
# Abel Cheung <maddog@linux.org.hk>, 2002.
# Anthony Fok <anthony@thizlinux.com>, 2002.
# Funda Wang <fundawang@linux.net.cn>, 2004, 2005.
# Ji ZhengYu <zhengyuji@gmail.com>, 2009.
# Aron Xu <happyaron.xu@gmail.com>, 2009, 2010, 2011, 2015.
# Boyuan Yang <073plan@gmail.com>, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: coreutils 8.29-pre1\n"
"Report-Msgid-Bugs-To: bug-coreutils@gnu.org\n"
"POT-Creation-Date: 2018-07-01 17:59-0700\n"
"PO-Revision-Date: 2019-04-29 13:27+0000\n"
"Last-Translator: Boyuan Yang <073plan@gmail.com>\n"
"Language-Team: Chinese (simplified) <i18n-zh@googlegroups.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Launchpad-Export-Date: 2019-05-11 10:42+0000\n"
"X-Generator: Launchpad (build 18962)\n"
"Language: zh_CN\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"

#: lib/argmatch.c:134
#, c-format
msgid "invalid argument %s for %s"
msgstr "%2$s 的参数%1$s 无效"

#: lib/argmatch.c:135
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "%2$s 的参数%1$s 不明确"

#: lib/argmatch.c:154
msgid "Valid arguments are:"
msgstr "有效的参数为："

#: lib/closein.c:100
msgid "error closing file"
msgstr "关闭文件时出错"

#: lib/closeout.c:122 src/base64.c:139 src/base64.c:151 src/base64.c:157
#: src/base64.c:198 src/base64.c:255 src/cat.c:187 src/cat.c:203 src/cat.c:287
#: src/cksum.c:251 src/expand.c:150 src/expand.c:175 src/factor.c:2387
#: src/mktemp.c:339 src/od.c:968 src/paste.c:163 src/seq.c:287 src/shuf.c:590
#: src/split.c:935 src/split.c:1189 src/split.c:1194 src/tail.c:1267
#: src/tail.c:1421 src/tail.c:2483 src/tr.c:1587 src/tr.c:1813 src/tr.c:1905
#: src/unexpand.c:234 src/unexpand.c:250
#, c-format
msgid "write error"
msgstr "写入错误"

#: lib/copy-acl.c:54 src/copy.c:1393 src/copy.c:2908
#, c-format
msgid "preserving permissions for %s"
msgstr "%s 的保留权限"

#: lib/error.c:195
msgid "Unknown system error"
msgstr "未知的系统错误"

#: lib/file-type.c:40
msgid "regular empty file"
msgstr "普通空文件"

#: lib/file-type.c:40
msgid "regular file"
msgstr "普通文件"

#: lib/file-type.c:43
msgid "directory"
msgstr "目录"

#: lib/file-type.c:46
msgid "symbolic link"
msgstr "符号链接"

#: lib/file-type.c:52
msgid "message queue"
msgstr "消息队列"

#: lib/file-type.c:55
msgid "semaphore"
msgstr "信号量"

#: lib/file-type.c:58
msgid "shared memory object"
msgstr "共享内存对象"

#: lib/file-type.c:61
msgid "typed memory object"
msgstr "共享内存对象"

#: lib/file-type.c:66
msgid "block special file"
msgstr "块特殊文件"

#: lib/file-type.c:69
msgid "character special file"
msgstr "字符特殊文件"

#: lib/file-type.c:72
msgid "contiguous data"
msgstr "连续数据"

#: lib/file-type.c:75
msgid "fifo"
msgstr "先进先出"

#: lib/file-type.c:78
msgid "door"
msgstr "门(Solaris)"

#: lib/file-type.c:81
msgid "multiplexed block special file"
msgstr "复用块特殊文件"

#: lib/file-type.c:84
msgid "multiplexed character special file"
msgstr "复用字符特殊文件"

#: lib/file-type.c:87
msgid "multiplexed file"
msgstr "复用文件"

#: lib/file-type.c:90
msgid "named file"
msgstr "命名文件(XENIX)"

#: lib/file-type.c:93
msgid "network special file"
msgstr "网络特殊文件"

#: lib/file-type.c:96
msgid "migrated file with data"
msgstr "含数据迁移文件(Cray DMF)"

#: lib/file-type.c:99
msgid "migrated file without data"
msgstr "不含数据迁移文件(Cray DMF)"

#: lib/file-type.c:102
msgid "port"
msgstr "端口"

#: lib/file-type.c:105
msgid "socket"
msgstr "套接字"

#: lib/file-type.c:108
msgid "whiteout"
msgstr "whiteout 文件"

#: lib/file-type.c:110
msgid "weird file"
msgstr "古怪文件"

#: lib/gai_strerror.c:57
msgid "Address family for hostname not supported"
msgstr "主机名的地址家族不被支持"

#: lib/gai_strerror.c:58
msgid "Temporary failure in name resolution"
msgstr "名称解析出现临时错误"

#: lib/gai_strerror.c:59
msgid "Bad value for ai_flags"
msgstr "错误的ai_flags 值"

#: lib/gai_strerror.c:60
msgid "Non-recoverable failure in name resolution"
msgstr "名称解析时出现不可恢复的错误"

#: lib/gai_strerror.c:61
msgid "ai_family not supported"
msgstr "不支持的ai_family"

#: lib/gai_strerror.c:62
msgid "Memory allocation failure"
msgstr "内存分配失败"

#: lib/gai_strerror.c:63
msgid "No address associated with hostname"
msgstr "没有与主机名关联的地址"

#: lib/gai_strerror.c:64
msgid "Name or service not known"
msgstr "名称或服务未知"

#: lib/gai_strerror.c:65
msgid "Servname not supported for ai_socktype"
msgstr "ai_socktype 不支持 Servname"

#: lib/gai_strerror.c:66
msgid "ai_socktype not supported"
msgstr "不支持ai_socktype"

#: lib/gai_strerror.c:67
msgid "System error"
msgstr "系统错误"

#: lib/gai_strerror.c:68
msgid "Argument buffer too small"
msgstr "参数缓冲区太小"

#: lib/gai_strerror.c:70
msgid "Processing request in progress"
msgstr "正在处理请求"

#: lib/gai_strerror.c:71
msgid "Request canceled"
msgstr "请求已取消"

#: lib/gai_strerror.c:72
msgid "Request not canceled"
msgstr "请求未取消"

#: lib/gai_strerror.c:73
msgid "All requests done"
msgstr "全部请求已完成"

#: lib/gai_strerror.c:74
msgid "Interrupted by a signal"
msgstr "被信号中断"

#: lib/gai_strerror.c:75
msgid "Parameter string not correctly encoded"
msgstr "参数字符串编码不正确"

#: lib/gai_strerror.c:87
msgid "Unknown error"
msgstr "未知错误"

#: lib/getopt.c:278
#, c-format
msgid "%s: option '%s%s' is ambiguous\n"
msgstr "%s：选项“%s%s”有歧义\n"

#: lib/getopt.c:284
#, c-format
msgid "%s: option '%s%s' is ambiguous; possibilities:"
msgstr "%s：选项“%s%s”有歧义；可能是："

#: lib/getopt.c:319
#, c-format
msgid "%s: unrecognized option '%s%s'\n"
msgstr "%s：无法识别的选项“%s%s”\n"

#: lib/getopt.c:345
#, c-format
msgid "%s: option '%s%s' doesn't allow an argument\n"
msgstr "%s：选项“%s%s”不允许带参数\n"

#: lib/getopt.c:360
#, c-format
msgid "%s: option '%s%s' requires an argument\n"
msgstr "%s：选项“%s%s”必须带参数\n"

#: lib/getopt.c:621
#, c-format
msgid "%s: invalid option -- '%c'\n"
msgstr "%s：无效选项 -- %c\n"

#: lib/getopt.c:636 lib/getopt.c:682
#, c-format
msgid "%s: option requires an argument -- '%c'\n"
msgstr "%s：选项必须带参数 -- \"%c\"\n"

#: lib/mkdir-p.c:179 src/install.c:512
#, c-format
msgid "cannot change permissions of %s"
msgstr "无法更改 %s 的权限"

#: lib/mkdir-p.c:189 src/copy.c:2523 src/install.c:740 src/install.c:753
#, c-format
msgid "cannot create directory %s"
msgstr "无法创建目录 %s"

#: lib/obstack.c:338 lib/obstack.c:340 lib/xalloc-die.c:34 src/csplit.c:233
#: src/tac.c:442
#, c-format
msgid "memory exhausted"
msgstr "内存耗尽"

#: lib/openat-die.c:38
#, c-format
msgid "unable to record current working directory"
msgstr "无法记录目前的工作目录"

#: lib/openat-die.c:57 src/find-mount-point.c:107
#, c-format
msgid "failed to return to initial working directory"
msgstr "返回到初始工作目录失败"

#. TRANSLATORS:
#. Get translations for open and closing quotation marks.
#. The message catalog should translate "`" to a left
#. quotation mark suitable for the locale, and similarly for
#. "'".  For example, a French Unicode local should translate
#. these to U+00AB (LEFT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), respectively.
#. 
#. If the catalog has no translation, we will try to
#. use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and
#. Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the
#. current locale is not Unicode, locale_quoting_style
#. will quote 'like this', and clocale_quoting_style will
#. quote "like this".  You should always include translations
#. for "`" and "'" even if U+2018 and U+2019 are appropriate
#. for your locale.
#. 
#. If you don't know what to put here, please see
#. <https://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>
#. and use glyphs suitable for your language.
#: lib/quotearg.c:362
msgid "`"
msgstr "“"

#: lib/quotearg.c:363
msgid "'"
msgstr "”"

#: lib/randread.c:128
#, c-format
msgid "%s: end of file"
msgstr "%s：文件结束"

#: lib/randread.c:128 src/du.c:1073 src/md5sum.c:803 src/od.c:952 src/tac.c:251
#: src/tac.c:357 src/tac.c:515 src/tac.c:596 src/wc.c:803
#, c-format
msgid "%s: read error"
msgstr "%s：读取出错"

#: lib/regcomp.c:135
msgid "Success"
msgstr "成功"

#: lib/regcomp.c:138
msgid "No match"
msgstr "无匹配"

#: lib/regcomp.c:141
msgid "Invalid regular expression"
msgstr "无效的正则表达式"

#: lib/regcomp.c:144
msgid "Invalid collation character"
msgstr "无效的校勘字符"

#: lib/regcomp.c:147
msgid "Invalid character class name"
msgstr "无效的字符类型名"

#: lib/regcomp.c:150
msgid "Trailing backslash"
msgstr "末尾的反斜杠"

#: lib/regcomp.c:153
msgid "Invalid back reference"
msgstr "无效的后向引用"

#: lib/regcomp.c:156
msgid "Unmatched [, [^, [:, [., or [="
msgstr "未匹配的 [、[^、[:、[. 或 [="

#: lib/regcomp.c:159
msgid "Unmatched ( or \\("
msgstr "未匹配的 ( 或 \\("

#: lib/regcomp.c:162
msgid "Unmatched \\{"
msgstr "未匹配的 \\{"

#: lib/regcomp.c:165
msgid "Invalid content of \\{\\}"
msgstr "\\{\\} 中内容无效"

#: lib/regcomp.c:168
msgid "Invalid range end"
msgstr "无效的范围结束符"

#: lib/regcomp.c:171
msgid "Memory exhausted"
msgstr "内存耗尽"

#: lib/regcomp.c:174
msgid "Invalid preceding regular expression"
msgstr "无效的前置正则表达式"

#: lib/regcomp.c:177
msgid "Premature end of regular expression"
msgstr "正则表达式异常结束"

#: lib/regcomp.c:180
msgid "Regular expression too big"
msgstr "正则表达式过长"

#: lib/regcomp.c:183
msgid "Unmatched ) or \\)"
msgstr "未匹配的 ) 或 \\)"

#: lib/regcomp.c:689
msgid "No previous regular expression"
msgstr "缺少之前的正则表达式"

#: lib/root-dev-ino.h:37
#, c-format
msgid "it is dangerous to operate recursively on %s"
msgstr "在%s 进行递归操作十分危险"

#: lib/root-dev-ino.h:41
#, c-format
msgid "it is dangerous to operate recursively on %s (same as %s)"
msgstr "在%s 进行递归操作十分危险(与%s 相同)"

#: lib/root-dev-ino.h:43
#, c-format
msgid "use --no-preserve-root to override this failsafe"
msgstr "使用 --no-preserve-root 选项跳过安全模式"

#. TRANSLATORS: A regular expression testing for an affirmative answer
#. (english: "yes").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^yesexpr='
#: lib/rpmatch.c:150
msgid "^[yY]"
msgstr "^[yY]"

#. TRANSLATORS: A regular expression testing for a negative answer
#. (english: "no").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^noexpr='
#: lib/rpmatch.c:163
msgid "^[nN]"
msgstr "^[nN]"

#: lib/set-acl.c:46 src/copy.c:2546 src/cp.c:514
#, c-format
msgid "setting permissions for %s"
msgstr "设置%s 的权限"

#: lib/siglist.h:31
msgid "Hangup"
msgstr "挂起"

#: lib/siglist.h:34
msgid "Interrupt"
msgstr "中断"

#: lib/siglist.h:37
msgid "Quit"
msgstr "退出"

#: lib/siglist.h:40
msgid "Illegal instruction"
msgstr "非法操作"

#: lib/siglist.h:43
msgid "Trace/breakpoint trap"
msgstr "跟踪/断点陷阱"

#: lib/siglist.h:46
msgid "Aborted"
msgstr "已中止"

#: lib/siglist.h:49
msgid "Floating point exception"
msgstr "浮点数异常"

#: lib/siglist.h:52
msgid "Killed"
msgstr "已杀死"

#: lib/siglist.h:55
msgid "Bus error"
msgstr "总线错误"

#: lib/siglist.h:58
msgid "Segmentation fault"
msgstr "段错误"

#: lib/siglist.h:61
msgid "Broken pipe"
msgstr "管道中断"

#: lib/siglist.h:64
msgid "Alarm clock"
msgstr "时钟警告"

#: lib/siglist.h:67
msgid "Terminated"
msgstr "已终止"

#: lib/siglist.h:70
msgid "Urgent I/O condition"
msgstr "急需I/O 条件"

#: lib/siglist.h:73
msgid "Stopped (signal)"
msgstr "已停止(信号)"

#: lib/siglist.h:76
msgid "Stopped"
msgstr "已停止"

#: lib/siglist.h:79
msgid "Continued"
msgstr "已继续"

#: lib/siglist.h:82
msgid "Child exited"
msgstr "子进程已退出"

#: lib/siglist.h:85
msgid "Stopped (tty input)"
msgstr "已停止(tty 输入)"

#: lib/siglist.h:88
msgid "Stopped (tty output)"
msgstr "已停止(tty 输出)"

#: lib/siglist.h:91
msgid "I/O possible"
msgstr "可能需要I/O"

#: lib/siglist.h:94
msgid "CPU time limit exceeded"
msgstr "CPU 时间超时"

#: lib/siglist.h:97
msgid "File size limit exceeded"
msgstr "文件大小超过限制"

#: lib/siglist.h:100
msgid "Virtual timer expired"
msgstr "虚拟记时器过期"

#: lib/siglist.h:103
msgid "Profiling timer expired"
msgstr "定时器描述已过期"

#: lib/siglist.h:106
msgid "Window changed"
msgstr "窗口已更改"

#: lib/siglist.h:109
msgid "User defined signal 1"
msgstr "用户自定义信号 1"

#: lib/siglist.h:112
msgid "User defined signal 2"
msgstr "用户自定义信号 2"

#: lib/siglist.h:117
msgid "EMT trap"
msgstr "捕获EMT 信号"

#: lib/siglist.h:120
msgid "Bad system call"
msgstr "错误的系统调用"

#: lib/siglist.h:123
msgid "Stack fault"
msgstr "栈错误"

#: lib/siglist.h:126
msgid "Information request"
msgstr "信息请求"

#: lib/siglist.h:128
msgid "Power failure"
msgstr "电源错误"

#: lib/siglist.h:131
msgid "Resource lost"
msgstr "资源丢失"

#: lib/strsignal.c:114
#, c-format
msgid "Real-time signal %d"
msgstr "实时信号%d"

#: lib/strsignal.c:118
#, c-format
msgid "Unknown signal %d"
msgstr "未知信号%d"

#: lib/unicodeio.c:102
msgid "iconv function not usable"
msgstr "iconv 函数无法使用"

#: lib/unicodeio.c:104
msgid "iconv function not available"
msgstr "iconv 函数不存在"

#: lib/unicodeio.c:111
msgid "character out of range"
msgstr "字符值超出可接受的范围以外"

#: lib/unicodeio.c:181
#, c-format
msgid "cannot convert U+%04X to local character set"
msgstr "无法将U+%04X 转换至用户的字符集"

#: lib/unicodeio.c:183
#, c-format
msgid "cannot convert U+%04X to local character set: %s"
msgstr "无法将U+%04X 转换至用户的字符集：%s"

#: lib/userspec.c:106
msgid "invalid user"
msgstr "无效的用户"

#: lib/userspec.c:107
msgid "invalid group"
msgstr "无效的组"

#: lib/userspec.c:108
msgid "invalid spec"
msgstr "无效的 spec"

#: lib/verror.c:73
#, c-format
msgid "unable to display error message"
msgstr "无法显示错误信息"

#: lib/version-etc.c:74
#, c-format
msgid "Packaged by %s (%s)\n"
msgstr "由 %s 打包 (%s)\n"

#: lib/version-etc.c:77
#, c-format
msgid "Packaged by %s\n"
msgstr "由 %s 打包\n"

#. TRANSLATORS: Translate "(C)" to the copyright symbol
#. (C-in-a-circle), if this symbol is available in the user's
#. locale.  Otherwise, do not translate "(C)"; leave it as-is.
#: lib/version-etc.c:84
msgid "(C)"
msgstr "(C)"

#: lib/version-etc.c:86
msgid ""
"\n"
"License GPLv3+: GNU GPL version 3 or later "
"<https://gnu.org/licenses/gpl.html>.\n"
"This is free software: you are free to change and redistribute it.\n"
"There is NO WARRANTY, to the extent permitted by law.\n"
"\n"
msgstr ""
"\n"
"许可证 GPLv3+：GNU 通用公共许可证第 3 版或更新版本<https://gnu.org/licenses/gpl.html>。\n"
"本软件是自由软件：您可以自由修改和重新发布它。\n"
"在法律范围内没有其他保证。\n"
"\n"

#. TRANSLATORS: %s denotes an author name.
#: lib/version-etc.c:102
#, c-format
msgid "Written by %s.\n"
msgstr "由%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:106
#, c-format
msgid "Written by %s and %s.\n"
msgstr "由%s 和%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:110
#, c-format
msgid "Written by %s, %s, and %s.\n"
msgstr "由%s、%s 和%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:117
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"由%s、%s、%s 和\n"
"%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:124
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s 和 %s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:131
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, and %s.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s、%s 和 %s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:139
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, and %s.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s、%s、%s 和 %s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:147
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s、%s、%s、%s\n"
"和%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:156
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s、%s、%s、%s、\n"
"%s、和%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:167
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, %s, and others.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s、%s、%s、%s、\n"
"%s、%s、和其他人编写。\n"

#. TRANSLATORS: The placeholder indicates the bug-reporting address
#. for this package.  Please add _another line_ saying
#. "Report translation bugs to <...>\n" with the address for translation
#. bugs (typically your translation team's web or email address).
#: lib/version-etc.c:245
#, c-format
msgid ""
"\n"
"Report bugs to: %s\n"
msgstr ""
"\n"
"请向<%s> 报告软件错误。请向 <i18n-zh@googlegroups.com> 报告翻译错误。\n"

#: lib/version-etc.c:247
#, c-format
msgid "Report %s bugs to: %s\n"
msgstr "请向 %2$s 报告 %1$s 的错误\n"

#: lib/version-etc.c:251
#, c-format
msgid "%s home page: <%s>\n"
msgstr "%s 的主页：<%s>\n"

#: lib/version-etc.c:253
#, c-format
msgid "%s home page: <https://www.gnu.org/software/%s/>\n"
msgstr "%s 项目主页：<https://www.gnu.org/software/%s/>\n"

#: lib/version-etc.c:256
msgid "General help using GNU software: <https://www.gnu.org/gethelp/>\n"
msgstr "GNU 软件一般性帮助：<https://www.gnu.org/gethelp/>\n"

#: lib/xbinary-io.c:37
#, c-format
msgid "failed to set file descriptor text/binary mode"
msgstr "设置文件描述符为文本/二进制模式时失败"

#: lib/xmemcoll.c:39 src/expr.c:1026
#, c-format
msgid "string comparison failed"
msgstr "字符串比较出现错误"

#: lib/xmemcoll.c:40
#, c-format
msgid "Set LC_ALL='C' to work around the problem."
msgstr "请设置LC_ALL='C' 以避免出现问题。"

#: lib/xmemcoll.c:42
#, c-format
msgid "The strings compared were %s and %s."
msgstr "要比较的字符串为%s 和%s。"

#: lib/xprintf.c:50 lib/xprintf.c:76
#, c-format
msgid "cannot perform formatted output"
msgstr "不能执行格式化输出"

#: lib/xstrtol-error.c:63
#, c-format
msgid "invalid %s%s argument '%s'"
msgstr "非法的%s%s 参数\"%s\""

#: lib/xstrtol-error.c:68
#, c-format
msgid "invalid suffix in %s%s argument '%s'"
msgstr "非法的后缀在%s%s 参数\"%s\""

#: lib/xstrtol-error.c:72
#, c-format
msgid "%s%s argument '%s' too large"
msgstr "%s%s 参数\"%s\"太大"

#. This is a proper name. See the gettext manual, section Names.
#: src/base64.c:36
msgid "Simon Josefsson"
msgstr "Simon Josefsson"

#: src/base64.c:65
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]\n"
"Base%d encode or decode FILE, or standard input, to standard output.\n"
msgstr ""
"用法：%s [选项]... [文件]\n"
"使用 Base%d 编码/解码文件或标准输入输出。\n"

#: src/base64.c:73
msgid ""
"  -d, --decode          decode data\n"
"  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\n"
"  -w, --wrap=COLS       wrap encoded lines after COLS character (default "
"76).\n"
"                          Use 0 to disable line wrapping\n"
"\n"
msgstr ""
"  -d, --decode\t\t解码数据\n"
"  -i, --ignore-garbag\t解码时忽略非字母字符\n"
"  -w, --wrap=字符数\t在指定的字符数后自动换行(默认为76)，0 为禁用自动换行\n"
"\n"

#: src/base64.c:82
#, c-format
msgid ""
"\n"
"The data are encoded as described for the %s alphabet in RFC 4648.\n"
"When decoding, the input may contain newlines in addition to the bytes of\n"
"the formal %s alphabet.  Use --ignore-garbage to attempt to recover\n"
"from any other non-alphabet bytes in the encoded stream.\n"
msgstr ""
"\n"
"数据以 RFC 4648 规定的 %s 字母格式进行编码。\n"
"解码时，输入数据（编码流）可能包含一些非有效 %s 字符的换行符。\n"
"可以尝试用 --ignore-garbage 选项来绕过编码流中的无效字符。\n"

#: src/base64.c:201 src/base64.c:239 src/csplit.c:277 src/csplit.c:1468
#: src/join.c:465 src/shuf.c:233 src/shuf.c:279 src/shuf.c:554
#: src/tac-pipe.c:76 src/tee.c:263 src/tr.c:1611
#, c-format
msgid "read error"
msgstr "读取错误"

#: src/base64.c:258
msgid "invalid input"
msgstr "输入无效"

#: src/base64.c:295
msgid "invalid wrap size"
msgstr "无效的换行字符数"

#: src/base64.c:313 src/basename.c:176 src/comm.c:489 src/cp.c:621
#: src/date.c:470 src/dircolors.c:449 src/du.c:1018 src/hostid.c:79
#: src/hostname.c:118 src/id.c:190 src/install.c:985 src/join.c:970
#: src/link.c:91 src/ln.c:551 src/logname.c:77 src/mknod.c:182 src/mv.c:451
#: src/nproc.c:115 src/od.c:1865 src/ptx.c:2082 src/seq.c:619 src/shuf.c:491
#: src/sort.c:4595 src/split.c:1553 src/tr.c:1768 src/tsort.c:566 src/tty.c:113
#: src/uname.c:252 src/uniq.c:533 src/uniq.c:550 src/unlink.c:87
#: src/uptime.c:258 src/users.c:152 src/wc.c:737 src/who.c:831 src/whoami.c:85
#, c-format
msgid "extra operand %s"
msgstr "额外的操作数 %s"

#: src/base64.c:344 src/cat.c:764
msgid "closing standard input"
msgstr "关闭标准输入"

#. This is a proper name. See the gettext manual, section Names.
#: src/basename.c:29 src/chgrp.c:38 src/chmod.c:39 src/chown.c:37 src/comm.c:39
#: src/cp.c:48 src/csplit.c:45 src/cut.c:46 src/date.c:40 src/dd.c:46
#: src/df.c:45 src/dirname.c:32 src/du.c:54 src/env.c:36 src/expand.c:49
#: src/fold.c:36 src/groups.c:36 src/head.c:47 src/id.c:42 src/install.c:51
#: src/ln.c:43 src/ls.c:131 src/mkdir.c:39 src/mkfifo.c:36 src/mknod.c:37
#: src/mv.c:43 src/nice.c:40 src/nl.c:42 src/paste.c:53 src/pathchk.c:32
#: src/pinky.c:38 src/printenv.c:44 src/printf.c:68 src/rm.c:41 src/rmdir.c:37
#: src/stty.c:68 src/sum.c:39 src/tac.c:58 src/tail.c:73 src/tee.c:38
#: src/touch.c:45 src/tty.c:44 src/uname.c:61 src/unexpand.c:50 src/uniq.c:43
#: src/uptime.c:47 src/users.c:37 src/wc.c:51 src/who.c:51 src/yes.c:33
msgid "David MacKenzie"
msgstr "David MacKenzie"

#: src/basename.c:48
#, c-format
msgid ""
"Usage: %s NAME [SUFFIX]\n"
"  or:  %s OPTION... NAME...\n"
msgstr ""
"用法：%s 名称 [后缀]\n"
"　或：%s 选项\n"

#: src/basename.c:53
msgid ""
"Print NAME with any leading directory components removed.\n"
"If specified, also remove a trailing SUFFIX.\n"
msgstr ""

#: src/basename.c:60
msgid ""
"  -a, --multiple       support multiple arguments and treat each as a NAME\n"
"  -s, --suffix=SUFFIX  remove a trailing SUFFIX; implies -a\n"
"  -z, --zero           end each output line with NUL, not newline\n"
msgstr ""

#: src/basename.c:67
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/sort          -> \"sort\"\n"
"  %s include/stdio.h .h     -> \"stdio\"\n"
"  %s -s .h include/stdio.h  -> \"stdio\"\n"
"  %s -a any/str1 any/str2   -> \"str1\" followed by \"str2\"\n"
msgstr ""

#: src/basename.c:170 src/chcon.c:536 src/chgrp.c:279 src/chmod.c:529
#: src/chown.c:280 src/chroot.c:278 src/comm.c:481 src/csplit.c:1402
#: src/dirname.c:116 src/expr.c:454 src/join.c:1160 src/link.c:83
#: src/mkdir.c:252 src/mkfifo.c:130 src/mknod.c:171 src/nohup.c:114
#: src/pathchk.c:147 src/printf.c:693 src/readlink.c:145 src/realpath.c:237
#: src/rm.c:338 src/rmdir.c:222 src/seq.c:613 src/sleep.c:124 src/stat.c:1663
#: src/stdbuf.c:370 src/tr.c:1753 src/unlink.c:81
#, c-format
msgid "missing operand"
msgstr "缺少操作数"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:48 src/cp.c:47 src/df.c:44 src/du.c:53 src/factor.c:129
#: src/split.c:49
msgid "Torbjorn Granlund"
msgstr "Torbjorn Granlund"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:49 src/comm.c:38 src/ls.c:130 src/rm.c:42 src/split.c:50
#: src/tee.c:37 src/uniq.c:42
msgid "Richard M. Stallman"
msgstr "Richard M. Stallman"

#: src/cat.c:88 src/df.c:1458 src/expand.c:69 src/fold.c:66 src/head.c:110
#: src/ls.c:5131 src/nl.c:176 src/paste.c:436 src/pr.c:2736 src/rm.c:133
#: src/sum.c:59 src/tac.c:132 src/tail.c:261 src/tee.c:87 src/unexpand.c:78
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "用法：%s [选项]... [文件]...\n"

#: src/cat.c:92
msgid "Concatenate FILE(s) to standard output.\n"
msgstr "连接所有指定文件并将结果写到标准输出。\n"

#: src/cat.c:98
msgid ""
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonempty output lines, overrides -n\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      suppress repeated empty output lines\n"
msgstr ""

#: src/cat.c:107
msgid ""
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
msgstr ""
"  -t                       与-vT 等价\n"
"  -T, --show-tabs          将跳格字符显示为^I\n"
"  -u                       (被忽略)\n"
"  -v, --show-nonprinting   使用^ 和M- 引用，除了LFD和 TAB 之外\n"

#: src/cat.c:115
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s f - g  Output f's contents, then standard input, then g's contents.\n"
"  %s        Copy standard input to standard output.\n"
msgstr ""
"\n"
"示例：\n"
"  %s f - g  先输出f 的内容，然后输出标准输入的内容，最后输出g 的内容。\n"
"  %s        将标准输入的内容复制到标准输出。\n"

#: src/cat.c:327
#, c-format
msgid "cannot do ioctl on %s"
msgstr "无法在 %s 上执行 ioctrl"

#: src/cat.c:638 src/dd.c:2433 src/sort.c:417 src/tail.c:2420 src/tee.c:207
#: src/yes.c:131
#, c-format
msgid "standard output"
msgstr "标准输出"

#: src/cat.c:699
#, c-format
msgid "%s: input file is output file"
msgstr "%s：输入文件是输出文件"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:36 src/runcon.c:57
msgid "Russell Coker"
msgstr "Russell Coker"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:37 src/chgrp.c:39 src/chmod.c:40 src/chown.c:38 src/cp.c:49
#: src/cut.c:47 src/dirname.c:33 src/du.c:56 src/head.c:48 src/hostid.c:33
#: src/hostname.c:34 src/mktemp.c:36 src/mv.c:44 src/nohup.c:35 src/od.c:39
#: src/pathchk.c:33 src/pwd.c:32 src/rm.c:43 src/sleep.c:35 src/sync.c:33
#: src/tail.c:75 src/tr.c:38 src/true.c:33
msgid "Jim Meyering"
msgstr "Jim Meyering"

#: src/chcon.c:100 src/runcon.c:202 src/runcon.c:233
#, c-format
msgid "failed to create security context: %s"
msgstr "创建安全环境失败：%s"

#: src/chcon.c:112
#, c-format
msgid "failed to set %s security context component to %s"
msgstr "设置%s 安全环境组件到%s 失败"

#: src/chcon.c:156 src/chcon.c:547 src/copy.c:924 src/runcon.c:216
#: src/stat.c:793
#, c-format
msgid "failed to get security context of %s"
msgstr "无法取得%s 的安全环境"

#: src/chcon.c:166
#, c-format
msgid "can't apply partial context to unlabeled file %s"
msgstr "部分关联无法应用于文件%s"

#: src/chcon.c:190
#, c-format
msgid "failed to change context of %s to %s"
msgstr "改变%s 的环境到%s 失败"

#: src/chcon.c:255 src/chmod.c:218 src/chown-core.c:324 src/copy.c:725
#: src/du.c:532 src/ls.c:3241
#, c-format
msgid "cannot access %s"
msgstr "无法访问%s"

#: src/chcon.c:266 src/chmod.c:231 src/chown-core.c:337 src/du.c:512
#, c-format
msgid "cannot read directory %s"
msgstr "无法读取目录%s"

#: src/chcon.c:293
#, c-format
msgid "changing security context of %s\n"
msgstr "正在更改%s 的安全环境\n"

#: src/chcon.c:327 src/chmod.c:349 src/chown-core.c:538 src/remove.c:601
#: src/selinux.c:323
#, c-format
msgid "fts_read failed"
msgstr "fts_read 失败"

#: src/chcon.c:338 src/chmod.c:360 src/chown-core.c:550 src/du.c:713
#: src/remove.c:615 src/selinux.c:334
#, c-format
msgid "fts_close failed"
msgstr "fts_close 失败"

#: src/chcon.c:352
#, c-format
msgid ""
"Usage: %s [OPTION]... CONTEXT FILE...\n"
"  or:  %s [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"用法:  %s [选项]... 环境 文件...\n"
"　或:  %s [选项]... [-u 用户] [-r 角色] [-l 范围] [-t 类型] 文件...\n"
"　或:  %s [选项]... --reference=参考文件 文件...\n"

#: src/chcon.c:358
msgid ""
"Change the SELinux security context of each FILE to CONTEXT.\n"
"With --reference, change the security context of each FILE to that of "
"RFILE.\n"
msgstr ""

#: src/chcon.c:365 src/chgrp.c:125 src/chown.c:95
msgid ""
"      --dereference      affect the referent of each symbolic link (this is\n"
"                         the default), rather than the symbolic link itself\n"
"  -h, --no-dereference   affect symbolic links instead of any referenced "
"file\n"
msgstr ""

#: src/chcon.c:370
msgid ""
"  -u, --user=USER        set user USER in the target security context\n"
"  -r, --role=ROLE        set role ROLE in the target security context\n"
"  -t, --type=TYPE        set type TYPE in the target security context\n"
"  -l, --range=RANGE      set range RANGE in the target security context\n"
msgstr ""

#: src/chcon.c:376 src/chgrp.c:134 src/chmod.c:390 src/chown.c:111
msgid ""
"      --no-preserve-root  do not treat '/' specially (the default)\n"
"      --preserve-root    fail to operate recursively on '/'\n"
msgstr ""

#: src/chcon.c:380
msgid ""
"      --reference=RFILE  use RFILE's security context rather than "
"specifying\n"
"                         a CONTEXT value\n"
msgstr ""

#: src/chcon.c:384 src/chgrp.c:142 src/chown.c:119
msgid ""
"  -R, --recursive        operate on files and directories recursively\n"
msgstr ""

#: src/chcon.c:387
msgid ""
"  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""

#: src/chcon.c:390 src/chgrp.c:145 src/chown.c:122
msgid ""
"\n"
"The following options modify how a hierarchy is traversed when the -R\n"
"option is also specified.  If more than one is specified, only the final\n"
"one takes effect.\n"
"\n"
"  -H                     if a command line argument is a symbolic link\n"
"                         to a directory, traverse it\n"
"  -L                     traverse every symbolic link to a directory\n"
"                         encountered\n"
"  -P                     do not traverse any symbolic links (default)\n"
"\n"
msgstr ""

#: src/chcon.c:517 src/chgrp.c:266 src/chown.c:267
msgid "-R --dereference requires either -H or -L"
msgstr "-R --dereference 需要-H 或-L 其中之一"

#: src/chcon.c:523
msgid "-R -h requires -P"
msgstr "-R -h 需要-P"

#: src/chcon.c:538 src/chgrp.c:281 src/chmod.c:531 src/chown.c:282
#: src/comm.c:483 src/csplit.c:1404 src/join.c:1162 src/link.c:85
#: src/mknod.c:173 src/tr.c:1756
#, c-format
msgid "missing operand after %s"
msgstr "%s 后缺少操作数"

#: src/chcon.c:561 src/runcon.c:250
#, c-format
msgid "invalid context: %s"
msgstr "无效模式：%s"

#: src/chcon.c:567
#, c-format
msgid "conflicting security context specifiers given"
msgstr "给出的安全环境说明冲突"

#: src/chcon.c:576 src/chgrp.c:289 src/chgrp.c:307 src/chmod.c:539
#: src/chmod.c:558 src/chown.c:290 src/chown.c:319 src/cp.c:422 src/cp.c:489
#: src/mv.c:99 src/pwd.c:276 src/rm.c:348 src/touch.c:348
#, c-format
msgid "failed to get attributes of %s"
msgstr "无法取得%s 的属性"

#: src/chgrp.c:93
#, c-format
msgid "invalid group: %s"
msgstr "无效的组：%s"

#: src/chgrp.c:110
#, c-format
msgid ""
"Usage: %s [OPTION]... GROUP FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"用法：%s [选项]... 用户组 文件...\n"
"　或：%s [选项]... --reference=参考文件 文件...\n"

#: src/chgrp.c:115
msgid ""
"Change the group of each FILE to GROUP.\n"
"With --reference, change the group of each FILE to that of RFILE.\n"
"\n"
msgstr ""

#: src/chgrp.c:120 src/chmod.c:385 src/chown.c:90
msgid ""
"  -c, --changes          like verbose but report only when a change is made\n"
"  -f, --silent, --quiet  suppress most error messages\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""

#: src/chgrp.c:130 src/chown.c:100
msgid ""
"                         (useful only on systems that can change the\n"
"                         ownership of a symlink)\n"
msgstr ""

#: src/chgrp.c:138
msgid ""
"      --reference=RFILE  use RFILE's group rather than specifying a\n"
"                         GROUP value\n"
msgstr ""

#: src/chgrp.c:160
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s staff /u      Change the group of /u to \"staff\".\n"
"  %s -hR staff /u  Change the group of /u and subfiles to \"staff\".\n"
msgstr ""
"\n"
"示例：\n"
"  %s staff /u            将 /u 的属组更改为\"staff\"。\n"
"  %s -hR staff /u    将 /u 及其子目录下所有文件的属组更改为\"staff\"。\n"

#: src/chmod.c:127
#, c-format
msgid "getting new attributes of %s"
msgstr "检查 %s 的新属性"

#: src/chmod.c:151 src/chown-core.c:146
#, c-format
msgid "neither symbolic link %s nor referent has been changed\n"
msgstr "符号链接%s 和该链接所指示的对象都未被更改\n"

#: src/chmod.c:165
#, c-format
msgid "mode of %s changed from %04lo (%s) to %04lo (%s)\n"
msgstr ""

#: src/chmod.c:168
#, c-format
msgid "failed to change mode of %s from %04lo (%s) to %04lo (%s)\n"
msgstr ""

#: src/chmod.c:171
#, c-format
msgid "mode of %s retained as %04lo (%s)\n"
msgstr "%s 的权限模式保留为%04lo (%s)\n"

#: src/chmod.c:238
#, c-format
msgid "cannot operate on dangling symlink %s"
msgstr "无法创建符号链接%s"

#: src/chmod.c:278
#, c-format
msgid "changing permissions of %s"
msgstr "更改%s 的权限"

#: src/chmod.c:314
#, c-format
msgid "%s: new permissions are %s, not %s"
msgstr "%s：新的权限为%s，而非%s"

#: src/chmod.c:374
#, c-format
msgid ""
"Usage: %s [OPTION]... MODE[,MODE]... FILE...\n"
"  or:  %s [OPTION]... OCTAL-MODE FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"用法：%s [选项]... 模式[,模式]... 文件...\n"
"　或：%s [选项]... 八进制模式 文件...\n"
"　或：%s [选项]... --reference=参考文件 文件...\n"

#: src/chmod.c:380
msgid ""
"Change the mode of each FILE to MODE.\n"
"With --reference, change the mode of each FILE to that of RFILE.\n"
"\n"
msgstr ""
"将每个文件的权限模式变更至指定模式。\n"
"使用 --reference 选项时，把指定文件的模式设置为与参考文件相同。\n"
"\n"

#: src/chmod.c:394
msgid "      --reference=RFILE  use RFILE's mode instead of MODE values\n"
msgstr "      --reference=参考文件  使用参考文件的模式而非给定模式的值\n"

#: src/chmod.c:397
msgid "  -R, --recursive        change files and directories recursively\n"
msgstr "  -R, --recursive        递归修改文件和目录\n"

#: src/chmod.c:402
msgid ""
"\n"
"Each MODE is of the form '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.\n"
msgstr ""
"\n"
"每个模式字符串都应该匹配如下格式：\"[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+\"。\n"

#: src/chmod.c:516
#, c-format
msgid "cannot combine mode and --reference options"
msgstr "无法组合使用 mode 和 --reference 选项"

#: src/chmod.c:547
#, c-format
msgid "invalid mode: %s"
msgstr "无效模式：%s"

#: src/chown-core.c:157
#, c-format
msgid "changed ownership of %s from %s to %s\n"
msgstr "%s 的所有者已从 %s 更改为 %s\n"

#: src/chown-core.c:158
#, c-format
msgid "changed group of %s from %s to %s\n"
msgstr "%s 的所属组已从 %s 更改为 %s\n"

#: src/chown-core.c:159
#, c-format
msgid "no change to ownership of %s\n"
msgstr "%s 的归属关系未更改\n"

#: src/chown-core.c:164
#, c-format
msgid "failed to change ownership of %s from %s to %s\n"
msgstr "无法将 %s 的所有者从 %s 更改为 %s\n"

#: src/chown-core.c:165
#, c-format
msgid "failed to change group of %s from %s to %s\n"
msgstr "无法将 %s 的所属组从 %s 更改为 %s\n"

#: src/chown-core.c:166 src/chown-core.c:172
#, c-format
msgid "failed to change ownership of %s\n"
msgstr "更改 %s 的所有者失败\n"

#: src/chown-core.c:170
#, c-format
msgid "failed to change ownership of %s to %s\n"
msgstr "无法更改 %s 的所有者为 %s\n"

#: src/chown-core.c:171
#, c-format
msgid "failed to change group of %s to %s\n"
msgstr "无法更改%s 的所属组为%s\n"

#: src/chown-core.c:179
#, c-format
msgid "ownership of %s retained as %s\n"
msgstr "%s 的所有者已保留为%s\n"

#: src/chown-core.c:180
#, c-format
msgid "group of %s retained as %s\n"
msgstr "%s 的所属组已保留为%s\n"

#: src/chown-core.c:181
#, c-format
msgid "ownership of %s retained\n"
msgstr "%s 的所有权已保留\n"

#: src/chown-core.c:378
#, c-format
msgid "cannot dereference %s"
msgstr "无法取消%s 的引用"

#: src/chown-core.c:466
#, c-format
msgid "changing ownership of %s"
msgstr "正在更改%s 的所有者"

#: src/chown-core.c:467
#, c-format
msgid "changing group of %s"
msgstr "正在更改%s 的所属组"

#: src/chown.c:80
#, c-format
msgid ""
"Usage: %s [OPTION]... [OWNER][:[GROUP]] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"用法：%s [选项]... [所有者][:[组]] 文件...\n"
"　或：%s [选项]... --reference=参考文件 文件...\n"

#: src/chown.c:85
msgid ""
"Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
"With --reference, change the owner and group of each FILE to those of "
"RFILE.\n"
"\n"
msgstr ""

#: src/chown.c:104
msgid ""
"      --from=CURRENT_OWNER:CURRENT_GROUP\n"
"                         change the owner and/or group of each file only if\n"
"                         its current owner and/or group match those "
"specified\n"
"                         here.  Either may be omitted, in which case a "
"match\n"
"                         is not required for the omitted attribute\n"
msgstr ""
"      --from=当前所有者:当前所属组\n"
"                         \t只当每个文件的所有者和组符合选项所指定时才更改所\n"
"\t\t\t\t有者和组。其中一个可以省略，这时已省略的属性就不\n"
"\t\t\t\t需要符合原有的属性。\n"

#: src/chown.c:115
msgid ""
"      --reference=RFILE  use RFILE's owner and group rather than\n"
"                         specifying OWNER:GROUP values\n"
msgstr ""

#: src/chown.c:137
msgid ""
"\n"
"Owner is unchanged if missing.  Group is unchanged if missing, but changed\n"
"to login group if implied by a ':' following a symbolic OWNER.\n"
"OWNER and GROUP may be numeric as well as symbolic.\n"
msgstr ""

#: src/chown.c:143
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s root /u        Change the owner of /u to \"root\".\n"
"  %s root:staff /u  Likewise, but also change its group to \"staff\".\n"
"  %s -hR root /u    Change the owner of /u and subfiles to \"root\".\n"
msgstr ""
"\n"
"示例：\n"
"  %s root /u\t\t将 /u 的属主更改为\"root\"。\n"
"  %s root:staff /u\t和上面类似，但同时也将其属组更改为\"staff\"。\n"
"  %s -hR root /u\t将 /u 及其子目录下所有文件的属主更改为\"root\"。\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/chroot.c:39
msgid "Roland McGrath"
msgstr "Roland McGrath"

#: src/chroot.c:138 src/install.c:608
#, c-format
msgid "invalid group %s"
msgstr "无效的组%s"

#: src/chroot.c:153
#, c-format
msgid "invalid group list %s"
msgstr "无效的组列表%s"

#: src/chroot.c:186
#, c-format
msgid ""
"Usage: %s [OPTION] NEWROOT [COMMAND [ARG]...]\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s [选项] 新根 [命令 [参数]...]\n"
"　或：%s 选项\n"

#: src/chroot.c:191
msgid ""
"Run COMMAND with root directory set to NEWROOT.\n"
"\n"
msgstr ""
"以指定的新根为运行指定命令时的的根目录。\n"
"\n"

#: src/chroot.c:196
msgid ""
"  --groups=G_LIST        specify supplementary groups as g1,g2,..,gN\n"
msgstr ""

#: src/chroot.c:199
msgid "  --userspec=USER:GROUP  specify user and group (ID or name) to use\n"
msgstr ""

#: src/chroot.c:202
#, c-format
msgid "  --skip-chdir           do not change working directory to %s\n"
msgstr ""

#: src/chroot.c:208
msgid ""
"\n"
"If no command is given, run '\"$SHELL\" -i' (default: '/bin/sh -i').\n"
msgstr ""

#: src/chroot.c:287
#, c-format
msgid "option --skip-chdir only permitted if NEWROOT is old %s"
msgstr ""

#: src/chroot.c:330
#, c-format
msgid "cannot change root directory to %s"
msgstr "无法进入目录%s"

#: src/chroot.c:334
msgid "cannot chdir to root directory"
msgstr "无法切换到根目录"

#: src/chroot.c:376
#, c-format
msgid "no group specified for unknown uid: %d"
msgstr "没有为未知 UID 指定组：%d"

#: src/chroot.c:401
msgid "failed to get supplemental groups"
msgstr ""

#: src/chroot.c:413
msgid "failed to set supplemental groups"
msgstr ""

#: src/chroot.c:419
msgid "failed to set group-ID"
msgstr "设置组ID 失败"

#: src/chroot.c:422
msgid "failed to set user-ID"
msgstr "设置用户ID 失败"

#: src/chroot.c:428 src/nohup.c:229 src/stdbuf.c:391 src/timeout.c:519
#, c-format
msgid "failed to run command %s"
msgstr "无法运行命令%s"

#. This is a proper name. See the gettext manual, section Names.
#: src/cksum.c:40
msgid "Q. Frank Xia"
msgstr "Q. Frank Xia"

#: src/cksum.c:216
#, c-format
msgid "%s: file too long"
msgstr "%s：文件太大"

#: src/cksum.c:263
#, c-format
msgid ""
"Usage: %s [FILE]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"用法：%s [文件]...\n"
"　或：%s [选项]\n"

#: src/cksum.c:268
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
msgstr ""
"输出每个文件的 CRC 校验值和字节统计。\n"
"\n"

#: src/comm.c:112 src/join.c:192
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "用法：%s [选项]... 文件1 文件2\n"

#: src/comm.c:116
msgid "Compare sorted files FILE1 and FILE2 line by line.\n"
msgstr "逐行比较已排序的文件文件1 和文件2。\n"

#: src/comm.c:119 src/join.c:201
msgid ""
"\n"
"When FILE1 or FILE2 (not both) is -, read standard input.\n"
msgstr ""

#: src/comm.c:123
msgid ""
"\n"
"With no options, produce three-column output.  Column one contains\n"
"lines unique to FILE1, column two contains lines unique to FILE2,\n"
"and column three contains lines common to both files.\n"
msgstr ""
"\n"
"如果不附带选项，程序会生成三列输出。第一列包含文件1 特有的行，第二列包含 文件2 特有的行，而第三列包含两个文件共有的行。\n"

#: src/comm.c:129
msgid ""
"\n"
"  -1              suppress column 1 (lines unique to FILE1)\n"
"  -2              suppress column 2 (lines unique to FILE2)\n"
"  -3              suppress column 3 (lines that appear in both files)\n"
msgstr ""
"\n"
"  -1\t\t不输出文件1 特有的行\n"
"  -2\t\t不输出文件2 特有的行\n"
"  -3\t\t不输出两个文件共有的行\n"

#: src/comm.c:135
msgid ""
"\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
msgstr ""
"\n"
"  --check-order\t\t\t检查输入是否被正确排序，即使所有输入行均成对\n"
"  --nocheck-order\t\t不检查输入是否被正确排序\n"

#: src/comm.c:141
msgid "  --output-delimiter=STR  separate columns with STR\n"
msgstr "  --output-delimiter=STR\t依照STR 分列\n"

#: src/comm.c:144
msgid "  --total           output a summary\n"
msgstr ""

#: src/comm.c:147 src/cut.c:178 src/head.c:134 src/numfmt.c:945 src/paste.c:452
#: src/tail.c:308
msgid "  -z, --zero-terminated    line delimiter is NUL, not newline\n"
msgstr "  -z, --zero-terminated    以 NUL 字符而非换行符作为行尾分隔符\n"

#: src/comm.c:152
msgid ""
"\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
msgstr ""

#: src/comm.c:156
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s -12 file1 file2  Print only lines present in both file1 and file2.\n"
"  %s -3 file1 file2  Print lines in file1 not in file2, and vice versa.\n"
msgstr ""
"\n"
"示例：\n"
"  %s -12 文件1 文件2  只打印在文件1 和文件2 中都有的行\n"
"  %s -3  文件1 文件2  打印在文件1 中有，而文件2 中没有的行。反之亦然。\n"

#: src/comm.c:238
#, c-format
msgid "file %d is not in sorted order"
msgstr "文件%d 没有被正确排序"

#: src/comm.c:402 src/du.c:1136 src/ls.c:2872 src/wc.c:864
msgid "total"
msgstr "总用量"

#: src/comm.c:458
msgid "multiple output delimiters specified"
msgstr ""

#: src/copy.c:194 src/copy.c:465
#, c-format
msgid "cannot lseek %s"
msgstr "无法lseek %s"

#: src/copy.c:204 src/copy.c:571
#, c-format
msgid "error deallocating %s"
msgstr ""

#: src/copy.c:242 src/dd.c:1864 src/dd.c:2200 src/du.c:1133 src/head.c:156
#: src/head.c:307 src/head.c:389 src/head.c:585 src/head.c:667 src/head.c:736
#: src/head.c:786 src/head.c:809 src/tail.c:441 src/tail.c:534 src/tail.c:583
#: src/tail.c:676 src/tail.c:804 src/tail.c:852 src/tail.c:889 src/tail.c:2013
#: src/tail.c:2046 src/uniq.c:473
#, c-format
msgid "error reading %s"
msgstr "读取%s 时出错"

#: src/copy.c:275 src/dd.c:2263 src/dd.c:2325 src/head.c:184 src/tail.c:415
#, c-format
msgid "error writing %s"
msgstr "写入%s 出错"

#: src/copy.c:306
#, c-format
msgid "overflow reading %s"
msgstr ""

#: src/copy.c:419
#, c-format
msgid "%s: failed to get extents info"
msgstr "%s：无法获得 extent 信息"

#: src/copy.c:491
#, c-format
msgid "%s: write failed"
msgstr "%s：写入失败"

#: src/copy.c:564 src/copy.c:1308
#, c-format
msgid "failed to extend %s"
msgstr "扩展%s 失败"

#: src/copy.c:806
#, c-format
msgid "clearing permissions for %s"
msgstr "清除%s 的权限"

#: src/copy.c:841 src/copy.c:2754 src/cp.c:318
#, c-format
msgid "failed to preserve ownership for %s"
msgstr "无法保留%s 的所有者"

#: src/copy.c:867
#, c-format
msgid "failed to lookup file %s"
msgstr "查阅文件%s 失败"

#: src/copy.c:872
#, c-format
msgid "failed to preserve authorship for %s"
msgstr "保留%s 的作者失败"

#: src/copy.c:909 src/cp.c:1205 src/install.c:961 src/mkdir.c:269
#: src/mkfifo.c:144 src/mknod.c:200
#, c-format
msgid "failed to set default file creation context to %s"
msgstr "无法取得%s 的创建环境"

#: src/copy.c:939
#, c-format
msgid "failed to set default file creation context for %s"
msgstr ""

#: src/copy.c:965
#, c-format
msgid "failed to set the security context of %s"
msgstr ""

#: src/copy.c:1038 src/csplit.c:655 src/du.c:1025 src/fmt.c:439 src/head.c:888
#: src/split.c:1569 src/tail.c:1987 src/wc.c:749
#, c-format
msgid "cannot open %s for reading"
msgstr "无法打开%s 读取数据"

#: src/copy.c:1044 src/copy.c:1197 src/dd.c:1789 src/dd.c:2337 src/dd.c:2477
#: src/head.c:847 src/tail.c:1827 src/tail.c:1890 src/truncate.c:114
#, c-format
msgid "cannot fstat %s"
msgstr "无法获取%s 的文件状态(fstat)"

#: src/copy.c:1054
#, c-format
msgid "skipping file %s, as it was replaced while being copied"
msgstr "跳过文件%s，因为在准备复制时它已被其它文件取代"

#: src/copy.c:1094 src/copy.c:2184 src/remove.c:263 src/remove.c:280
#: src/remove.c:406 src/remove.c:432
#, c-format
msgid "cannot remove %s"
msgstr "无法删除%s"

#: src/copy.c:1099 src/copy.c:1796 src/copy.c:2189 src/remove.c:376
#, c-format
msgid "removed %s\n"
msgstr "已删除%s\n"

#: src/copy.c:1151
#, c-format
msgid "not writing through dangling symlink %s"
msgstr "无法通过符号链接%s 进行操作"

#: src/copy.c:1189
#, c-format
msgid "cannot create regular file %s"
msgstr "无法创建普通文件%s"

#: src/copy.c:1210
#, c-format
msgid "failed to clone %s from %s"
msgstr ""

#: src/copy.c:1323 src/copy.c:2829
#, c-format
msgid "preserving times for %s"
msgstr "正在保留 %s 的时间"

#: src/copy.c:1403 src/copy.c:1409 src/head.c:896 src/sync.c:162
#: src/touch.c:173 src/truncate.c:392
#, c-format
msgid "failed to close %s"
msgstr ""

#: src/copy.c:1685
#, c-format
msgid "%s: replace %s, overriding mode %04lo (%s)? "
msgstr ""

#: src/copy.c:1686
#, c-format
msgid "%s: unwritable %s (mode %04lo, %s); try anyway? "
msgstr "%s：%s 不可写(权限%04lo，%s)；依然尝试？ "

#: src/copy.c:1693
#, c-format
msgid "%s: overwrite %s? "
msgstr "%s：是否覆盖%s？ "

#: src/copy.c:1763
#, c-format
msgid " (backup: %s)"
msgstr " (备份：%s)"

#: src/copy.c:1773
msgid "failed to restore the default file creation context"
msgstr "恢复默认文件创建环境失败"

#: src/copy.c:1791
#, c-format
msgid "cannot create hard link %s to %s"
msgstr "无法创建指向%2$s 的硬链接%1$s"

#: src/copy.c:1891 src/copy.c:1963 src/copy.c:2534 src/copy.c:2895
#: src/find-mount-point.c:84 src/install.c:702 src/realpath.c:146
#: src/stat.c:1389 src/truncate.c:338
#, c-format
msgid "cannot stat %s"
msgstr "无法获取%s 的文件状态(stat)"

#: src/copy.c:1900
#, c-format
msgid "-r not specified; omitting directory %s"
msgstr "未指定 -r；略过目录%s"

#: src/copy.c:1901
#, c-format
msgid "omitting directory %s"
msgstr "略过目录 %s"

#: src/copy.c:1924
#, c-format
msgid "warning: source file %s specified more than once"
msgstr "警告：指定来源文件%s 多于一次"

#: src/copy.c:1979 src/ln.c:263
#, c-format
msgid "%s and %s are the same file"
msgstr "%s 与%s 为同一文件"

#: src/copy.c:2069
#, c-format
msgid "cannot overwrite non-directory %s with directory %s"
msgstr "无法以目录%2$s 来覆盖非目录%1$s"

#: src/copy.c:2087 src/ln.c:231
#, c-format
msgid "will not overwrite just-created %s with %s"
msgstr "不会以%2$s 覆盖刚创建的%1$s"

#: src/copy.c:2105
#, c-format
msgid "cannot overwrite directory %s with non-directory"
msgstr "无法以非目录来覆盖目录%s"

#: src/copy.c:2119
#, c-format
msgid "cannot move directory onto non-directory: %s -> %s"
msgstr "无法将目录移动至非目录：%s -> %s"

#: src/copy.c:2146
#, c-format
msgid "backing up %s might destroy source;  %s not moved"
msgstr "备份 %s 可能破坏源文件；未移动 %s"

#: src/copy.c:2147
#, c-format
msgid "backing up %s might destroy source;  %s not copied"
msgstr "备份 %s 可能破坏源文件；未复制 %s"

#: src/copy.c:2168 src/ln.c:293
#, c-format
msgid "cannot backup %s"
msgstr "无法备份 %s"

#: src/copy.c:2223
#, c-format
msgid "will not copy %s through just-created symlink %s"
msgstr "不会以%s 覆盖刚创建的%s"

#: src/copy.c:2303
#, c-format
msgid "cannot copy a directory, %s, into itself, %s"
msgstr "无法将目录%s 复制到自己%s"

#: src/copy.c:2311
#, c-format
msgid "warning: source directory %s specified more than once"
msgstr "警告：指定来源目录 %s 多于一次"

#: src/copy.c:2337
#, c-format
msgid "will not create hard link %s to directory %s"
msgstr "不会创建指向目录%2$s 的硬链接%1$s"

#: src/copy.c:2361
#, c-format
msgid "renamed "
msgstr ""

#: src/copy.c:2399
#, c-format
msgid "cannot move %s to a subdirectory of itself, %s"
msgstr "无法将目录%s 移动至自身的子目录%s 下"

#: src/copy.c:2442
#, c-format
msgid "cannot move %s to %s"
msgstr "无法将%s 移动至%s"

#: src/copy.c:2458
#, c-format
msgid "inter-device move failed: %s to %s; unable to remove target"
msgstr "无法进行跨设备的移动：%s 至%s；无法删除目标"

#: src/copy.c:2466
#, c-format
msgid "copied "
msgstr ""

#: src/copy.c:2503
#, c-format
msgid "cannot copy cyclic symbolic link %s"
msgstr "无法复制循环的符号链接%s"

#: src/copy.c:2565
#, c-format
msgid "created directory %s\n"
msgstr "已创建目录 %s\n"

#: src/copy.c:2628
#, c-format
msgid "%s: can make relative symbolic links only in current directory"
msgstr "%s：只能于当前目录中创建相对的符号链接"

#: src/copy.c:2637
#, c-format
msgid "cannot create symbolic link %s to %s"
msgstr "无法创建指向%2$s 的符号链接%1$s"

#: src/copy.c:2691 src/mkfifo.c:170
#, c-format
msgid "cannot create fifo %s"
msgstr "无法创建先进先出文件%s"

#: src/copy.c:2700
#, c-format
msgid "cannot create special file %s"
msgstr "无法创建特殊文件%s"

#: src/copy.c:2711 src/ls.c:3455 src/stat.c:1071
#, c-format
msgid "cannot read symbolic link %s"
msgstr "无法读取符号链接%s"

#: src/copy.c:2738
#, c-format
msgid "cannot create symbolic link %s"
msgstr "无法创建符号链接%s"

#: src/copy.c:2770
#, c-format
msgid "%s has unknown file type"
msgstr "%s 的文件类型不详"

#: src/copy.c:2935 src/ln.c:362
#, c-format
msgid "cannot un-backup %s"
msgstr "无法将%s 的备份还原"

#: src/copy.c:2939
#, c-format
msgid "%s -> %s (unbackup)\n"
msgstr "%s -> %s (还原备份)\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/coreutils.c:48
msgid "Alex Deymo"
msgstr ""

#: src/coreutils.c:65
#, c-format
msgid "Usage: %s --coreutils-prog=PROGRAM_NAME [PARAMETERS]... \n"
msgstr ""

#: src/coreutils.c:68
msgid ""
"Execute the PROGRAM_NAME built-in program with the given PARAMETERS.\n"
"\n"
msgstr ""

#: src/coreutils.c:86
#, c-format
msgid ""
"\n"
"Use: '%s --coreutils-prog=PROGRAM_NAME --help' for individual program help.\n"
msgstr ""

#: src/coreutils.c:178 src/coreutils.c:203
#, c-format
msgid "unknown program %s"
msgstr "未知程序 %s"

#: src/cp.c:148 src/mv.c:292
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
msgstr ""
"用法：%s [选项]... [-T] 源文件 目标文件\n"
"　或：%s [选项]... 源文件... 目录\n"
"　或：%s [选项]... -t 目录 源文件...\n"

#: src/cp.c:154
msgid "Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n"
msgstr ""

#: src/cp.c:160
msgid ""
"  -a, --archive                same as -dR --preserve=all\n"
"      --attributes-only        don't copy the file data, just the "
"attributes\n"
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"      --copy-contents          copy contents of special files when "
"recursive\n"
"  -d                           same as --no-dereference --preserve=links\n"
msgstr ""
"  -a, --archive\t\t\t等于-dR --preserve=all\n"
"      --attributes-only\t仅复制属性而不复制数据      --backup[=CONTROL\t\t"
"为每个已存在的目标文件创建备份\n"
"  -b\t\t\t\t类似--backup 但不接受参数\n"
"      --copy-contents\t\t在递归处理是复制特殊文件内容\n"
"  -d\t\t\t\t等于--no-dereference --preserve=links\n"

#: src/cp.c:169
msgid ""
"  -f, --force                  if an existing destination file cannot be\n"
"                                 opened, remove it and try again (this "
"option\n"
"                                 is ignored when the -n option is also "
"used)\n"
"  -i, --interactive            prompt before overwrite (overrides a previous "
"-n\n"
"                                  option)\n"
"  -H                           follow command-line symbolic links in SOURCE\n"
msgstr ""

#: src/cp.c:178
msgid ""
"  -l, --link                   hard link files instead of copying\n"
"  -L, --dereference            always follow symbolic links in SOURCE\n"
msgstr ""

#: src/cp.c:182
msgid ""
"  -n, --no-clobber             do not overwrite an existing file (overrides\n"
"                                 a previous -i option)\n"
"  -P, --no-dereference         never follow symbolic links in SOURCE\n"
msgstr ""
"  -n, --no-clobber\t\t不要覆盖已存在的文件(使前面的 -i 选项失效)\n"
"  -P, --no-dereference\t\t不跟随源文件中的符号链接\n"

#: src/cp.c:187
msgid ""
"  -p                           same as --preserve=mode,ownership,timestamps\n"
"      --preserve[=ATTR_LIST]   preserve the specified attributes (default:\n"
"                                 mode,ownership,timestamps), if possible\n"
"                                 additional attributes: context, links, "
"xattr,\n"
"                                 all\n"
msgstr ""
"  -p\t\t\t\t等于--preserve=模式,所有权,时间戳\n"
"      --preserve[=属性列表\t保持指定的属性(默认：模式,所有权,时间戳)，如果\n"
"\t\t\t\t\t可能保持附加属性：环境、链接、xattr 等\n"

#: src/cp.c:195
msgid ""
"      --no-preserve=ATTR_LIST  don't preserve the specified attributes\n"
"      --parents                use full source file name under DIRECTORY\n"
msgstr ""
"      --sno-preserve=属性列表\t不保留指定的文件属性\n"
"      --parents\t\t\t复制前在目标目录创建来源文件路径中的所有目录\n"

#: src/cp.c:199
msgid ""
"  -R, -r, --recursive          copy directories recursively\n"
"      --reflink[=WHEN]         control clone/CoW copies. See below\n"
"      --remove-destination     remove each existing destination file before\n"
"                                 attempting to open it (contrast with --"
"force)\n"
msgstr ""
"  -R, -r, --recursive\t\t递归复制目录及其子目录内的所有内容\n"
"      --reflink[=WHEN]\t\t控制克隆/CoW 副本。请查看下面的内如。\n"
"      --remove-destination\t尝试打开目标文件前先删除已存在的目的地\n"
"\t\t\t\t\t文件 (相对于 --force 选项)\n"

#: src/cp.c:205
msgid ""
"      --sparse=WHEN            control creation of sparse files. See below\n"
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
msgstr ""
"      --sparse=WHEN\t\t控制创建稀疏文件的方式\n"
"      --strip-trailing-slashes\t删除参数中所有源文件/目录末端的斜杠\n"

#: src/cp.c:210
msgid ""
"  -s, --symbolic-link          make symbolic links instead of copying\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
msgstr ""
"  -s, --symbolic-link\t\t只创建符号链接而不复制文件\n"
"  -S, --suffix=后缀\t\t自行指定备份文件的后缀\n"
"  -t,  --target-directory=目录\t将所有参数指定的源文件/目录\n"
"                                           复制至目标目录\n"
"  -T, --no-target-directory\t将目标目录视作普通文件\n"

#: src/cp.c:216
msgid ""
"  -u, --update                 copy only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -x, --one-file-system        stay on this file system\n"
msgstr ""
"  -u, --update\t\t\t只在源文件比目标文件新，或目标文件\n"
"\t\t\t\t\t不存在时才进行复制\n"
"  -v, --verbose\t\t显示详细的进行步骤\n"
"  -x, --one-file-system\t不跨越文件系统进行操作\n"

#: src/cp.c:223
msgid ""
"  -Z                           set SELinux security context of destination\n"
"                                 file to default type\n"
"      --context[=CTX]          like -Z, or if CTX is specified then set the\n"
"                                 SELinux or SMACK security context to CTX\n"
msgstr ""

#: src/cp.c:231
msgid ""
"\n"
"By default, sparse SOURCE files are detected by a crude heuristic and the\n"
"corresponding DEST file is made sparse as well.  That is the behavior\n"
"selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\n"
"file whenever the SOURCE file contains a long enough sequence of zero "
"bytes.\n"
"Use --sparse=never to inhibit creation of sparse files.\n"
msgstr ""
"\n"
"默认情况下，源文件的稀疏性仅仅通过简单的方法判断，对应的目标文件目标文件也\n"
"被为稀疏。这是因为默认情况下使用了--sparse=auto 参数。如果明确使用\n"
"--sparse=always 参数则不论源文件是否包含足够长的0 序列也将目标文件创文\n"
"建为稀疏件。\n"
"使用--sparse=never 参数禁止创建稀疏文件。\n"

#: src/cp.c:239
msgid ""
"\n"
"When --reflink[=always] is specified, perform a lightweight copy, where the\n"
"data blocks are copied only when modified.  If this is not possible the "
"copy\n"
"fails, or if --reflink=auto is specified, fall back to a standard copy.\n"
"Use --reflink=never to ensure a standard copy is performed.\n"
msgstr ""

#: src/cp.c:247
msgid ""
"\n"
"As a special case, cp makes a backup of SOURCE when the force and backup\n"
"options are given and SOURCE and DEST are the same name for an existing,\n"
"regular file.\n"
msgstr ""
"\n"
"有一个特别情况：如果同时指定--force 和--backup 选项，而源文件和目标文件\n"
"是同一个已存在的一般文件的话，cp 会将源文件备份。\n"

#: src/cp.c:306
#, c-format
msgid "failed to preserve times for %s"
msgstr "无法保留%s 的时间"

#: src/cp.c:337
#, c-format
msgid "failed to preserve permissions for %s"
msgstr "保留%s 的权限失败"

#: src/cp.c:473
#, c-format
msgid "cannot make directory %s"
msgstr "无法创建目录%s"

#: src/cp.c:522 src/cp.c:553
#, c-format
msgid "%s exists but is not a directory"
msgstr "%s 存在但并非目录"

#: src/cp.c:585 src/cp.c:1087 src/install.c:407 src/install.c:942 src/ln.c:134
#: src/ln.c:198 src/ln.c:219 src/ln.c:503 src/mv.c:160 src/mv.c:393
#, c-format
msgid "failed to access %s"
msgstr "访问%s 失败"

#: src/cp.c:606 src/install.c:970 src/ln.c:534 src/mv.c:436 src/shred.c:1283
#: src/touch.c:430 src/truncate.c:329
#, c-format
msgid "missing file operand"
msgstr "缺少了文件操作数"

#: src/cp.c:608 src/install.c:972 src/ln.c:548 src/mv.c:438
#, c-format
msgid "missing destination file operand after %s"
msgstr "在%s 后缺少了要操作的目标文件"

#: src/cp.c:617 src/install.c:981 src/mv.c:447
msgid "cannot combine --target-directory (-t) and --no-target-directory (-T)"
msgstr "无法同时使用--target-directory (-t) 和--no-target-directory (-T) 选项"

#: src/cp.c:635 src/cp.c:1090 src/install.c:409 src/install.c:945
#: src/install.c:994 src/ln.c:136 src/ln.c:506 src/ln.c:562 src/mv.c:396
#: src/mv.c:468
#, c-format
msgid "target %s is not a directory"
msgstr "目标%s 不是目录"

#: src/cp.c:745
#, c-format
msgid "with --parents, the destination must be a directory"
msgstr "当跟随--parents 选项时，目的地必须是目录"

#: src/cp.c:1082 src/install.c:882 src/ln.c:498 src/mv.c:388
msgid "multiple target directories specified"
msgstr "指定了多个目标目录"

#: src/cp.c:1124 src/install.c:918
#, c-format
msgid "warning: ignoring --context; it requires an SELinux-enabled kernel"
msgstr ""

#: src/cp.c:1145
#, c-format
msgid "cannot make both hard and symbolic links"
msgstr "无法同时创建硬链接及符号链接"

#: src/cp.c:1155 src/mv.c:478
#, c-format
msgid "options --backup and --no-clobber are mutually exclusive"
msgstr "选项--backup 和 --no-clobber 互斥"

#: src/cp.c:1161
#, c-format
msgid "--reflink can be used only with --sparse=auto"
msgstr "--reflink 只能与--sparse=auto 一起用"

#: src/cp.c:1166 src/install.c:950 src/ln.c:567 src/mv.c:483
msgid "backup type"
msgstr "备份方式"

#: src/cp.c:1190 src/install.c:957
msgid "cannot set target context and preserve it"
msgstr ""

#: src/cp.c:1194
msgid "cannot preserve security context without an SELinux-enabled kernel"
msgstr "无法在未启用SELinux 支持的内核上使用安全环境"

#: src/cp.c:1210
msgid ""
"cannot preserve extended attributes, cp is built without xattr support"
msgstr "无法保留扩展属性，当前使用的 cp 副本编译时没有启用 xattr 支持"

#. This is a proper name. See the gettext manual, section Names.
#: src/csplit.c:44 src/dd.c:47
msgid "Stuart Kemp"
msgstr "Stuart Kemp"

#: src/csplit.c:545
msgid "input disappeared"
msgstr "输入消失"

#: src/csplit.c:676 src/csplit.c:688
#, c-format
msgid "%s: line number out of range"
msgstr "%s：行数超出范围"

#: src/csplit.c:718
#, c-format
msgid "%s: %s: line number out of range"
msgstr "%s：%s：行数超出范围"

#: src/csplit.c:721 src/csplit.c:777
#, c-format
msgid " on repetition %s\n"
msgstr " 在循环位%s\n"

#: src/csplit.c:771
#, c-format
msgid "%s: %s: match not found"
msgstr "%s：%s：无匹配"

#: src/csplit.c:838 src/csplit.c:878 src/nl.c:361 src/tac.c:286
#, c-format
msgid "error in regular expression search"
msgstr "正则表达式搜索时出错"

#: src/csplit.c:1007 src/csplit.c:1054
#, c-format
msgid "write error for %s"
msgstr "写入%s 时出错"

#: src/csplit.c:1089
#, c-format
msgid "%s: integer expected after delimiter"
msgstr "%s：分界符后应该跟随整数"

#: src/csplit.c:1106
#, c-format
msgid "%s: '}' is required in repeat count"
msgstr ""

#: src/csplit.c:1117
#, c-format
msgid "%s}: integer required between '{' and '}'"
msgstr ""

#: src/csplit.c:1144
#, c-format
msgid "%s: closing delimiter '%c' missing"
msgstr ""

#: src/csplit.c:1161
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s：无效的正则表达式：%s"

#: src/csplit.c:1193
#, c-format
msgid "%s: invalid pattern"
msgstr "%s：无效的模式"

#: src/csplit.c:1196
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s：行号必须大于0"

#: src/csplit.c:1201
#, c-format
msgid "line number %s is smaller than preceding line number, %s"
msgstr "行号%s 比先前的行号%s 更小"

#: src/csplit.c:1207
#, c-format
msgid "warning: line number %s is the same as preceding line number"
msgstr "警告：行号%s 比先前的行号更小"

#: src/csplit.c:1285
msgid "missing conversion specifier in suffix"
msgstr "下标中丢失了转换规格"

#: src/csplit.c:1290
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "下标中出现无效的转换规格：%c"

#: src/csplit.c:1293
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "下标中出现无效的转换规格：\\%.3o"

#: src/csplit.c:1298
#, c-format
msgid "invalid flags in conversion specification: %%%c%c"
msgstr "无效的转换声明%%%c%c"

#: src/csplit.c:1315
#, c-format
msgid "too many %% conversion specifications in suffix"
msgstr "下标中出现过多的%% 转换规格字符"

#: src/csplit.c:1329
#, c-format
msgid "missing %% conversion specification in suffix"
msgstr "下标中丢失了%% 转换规格字符"

#: src/csplit.c:1375 src/dd.c:1499 src/nproc.c:105 src/tail.c:2140
msgid "invalid number"
msgstr "无效的数字"

#: src/csplit.c:1482
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "用法：%s [选项]... 文件 格式...\n"

#: src/csplit.c:1486
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files 'xx00', 'xx01', ...,\n"
"and output byte counts of each piece to standard output.\n"
msgstr ""

#: src/csplit.c:1490
msgid ""
"\n"
"Read standard input if FILE is -\n"
msgstr ""
"\n"
"如果文件为“-”，则读取标准输入。\n"

#: src/csplit.c:1497
#, c-format
msgid ""
"  -b, --suffix-format=FORMAT  use sprintf FORMAT instead of %02d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of 'xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
msgstr ""

#: src/csplit.c:1502
msgid "      --suppress-matched     suppress the lines matching PATTERN\n"
msgstr ""

#: src/csplit.c:1505
msgid ""
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
msgstr ""
"  -n, --digits=数位\t\t使用指定的进制数位代替二进制\n"
"  -s, --quiet, --silent\t不显示输出文件的尺寸计数\n"
"  -z, --elide-empty-files\t删除空的输出文件\n"

#: src/csplit.c:1512
msgid ""
"\n"
"Each PATTERN may be:\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %REGEXP%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required '+' or '-' followed by a positive integer.\n"
msgstr ""

#. This is a proper name. See the gettext manual, section Names.
#: src/cut.c:45 src/paste.c:52
msgid "David M. Ihnat"
msgstr "David M. Ihnat"

#: src/cut.c:147
#, c-format
msgid "Usage: %s OPTION... [FILE]...\n"
msgstr "用法：%s [选项]... [文件]...\n"

#: src/cut.c:151
msgid "Print selected parts of lines from each FILE to standard output.\n"
msgstr ""

#: src/cut.c:158
msgid ""
"  -b, --bytes=LIST        select only these bytes\n"
"  -c, --characters=LIST   select only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
msgstr ""
"  -b, --bytes=列表\t\t只选中指定的这些字节\n"
"  -c, --characters=列表\t\t只选中指定的这些字符\n"
"  -d, --delimiter=分界符\t使用指定分界符代替制表符作为区域分界\n"

#: src/cut.c:163
msgid ""
"  -f, --fields=LIST       select only these fields;  also print any line\n"
"                            that contains no delimiter character, unless\n"
"                            the -s option is specified\n"
"  -n                      (ignored)\n"
msgstr ""
"  -f, --fields=列表\t\t只选中指定的这些域；并打印所有不包含分界符的\n"
"\t\t\t\t行，除非-s 选项被指定\n"
"  -n\t\t\t\t(忽略)\n"

#: src/cut.c:169
msgid ""
"      --complement        complement the set of selected bytes, characters\n"
"                            or fields\n"
msgstr "      --complement\t\t补全选中的字节、字符或域\n"

#: src/cut.c:173
msgid ""
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
msgstr ""
"  -s, --only-delimited\t\t不打印没有包含分界符的行\n"
"      --output-delimiter=字符串\t使用指定的字符串作为输出分界符，默认采用输入\n"
"\t\t\t\t的分界符\n"

#: src/cut.c:183
msgid ""
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Selected input is written\n"
"in the same order that it is read, and is written exactly once.\n"
msgstr ""
"\n"
"仅使用f -b, -c 或-f 中的一个。每一个列表都是专门为一个类别作出的，或者您可以用逗号隔\n"
"开要同时显示的不同类别。您的输入顺序将作为读取顺序，每个仅能输入一次。\n"

#: src/cut.c:189
msgid ""
"Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
msgstr ""

#: src/cut.c:511 src/cut.c:519
msgid "only one type of list may be specified"
msgstr "只能指定列表中的一种类型"

#: src/cut.c:528 src/numfmt.c:1521
msgid "the delimiter must be a single character"
msgstr "分界符必须是单个字符"

#: src/cut.c:567
msgid "you must specify a list of bytes, characters, or fields"
msgstr "您必须指定一组字节、字符或域的列表"

#: src/cut.c:570
msgid "an input delimiter may be specified only when operating on fields"
msgstr "只有当操作域时才可以指定输入分界符"

#: src/cut.c:574
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"清除没有分界符的行仅在\n"
"\t操作域时才有意义"

#: src/date.c:130
#, c-format
msgid ""
"Usage: %s [OPTION]... [+FORMAT]\n"
"  or:  %s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n"
msgstr ""
"用法：%s [选项]... [+格式]\n"
"　或：%s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n"

#: src/date.c:135
msgid ""
"Display the current time in the given FORMAT, or set the system date.\n"
msgstr ""

#: src/date.c:141
msgid ""
"  -d, --date=STRING          display time described by STRING, not 'now'\n"
msgstr ""

#: src/date.c:144
msgid ""
"      --debug                annotate the parsed date,\n"
"                              and warn about questionable usage to stderr\n"
msgstr ""

#: src/date.c:148
msgid ""
"  -f, --file=DATEFILE        like --date; once for each line of DATEFILE\n"
msgstr ""

#: src/date.c:151
msgid ""
"  -I[FMT], --iso-8601[=FMT]  output date/time in ISO 8601 format.\n"
"                               FMT='date' for date only (the default),\n"
"                               'hours', 'minutes', 'seconds', or 'ns'\n"
"                               for date and time to the indicated "
"precision.\n"
"                               Example: 2006-08-14T02:34:56-06:00\n"
msgstr ""

#: src/date.c:158
msgid ""
"  -R, --rfc-email            output date and time in RFC 5322 format.\n"
"                               Example: Mon, 14 Aug 2006 02:34:56 -0600\n"
msgstr ""

#: src/date.c:162
msgid ""
"      --rfc-3339=FMT         output date/time in RFC 3339 format.\n"
"                               FMT='date', 'seconds', or 'ns'\n"
"                               for date and time to the indicated "
"precision.\n"
"                               Example: 2006-08-14 02:34:56-06:00\n"
msgstr ""

#: src/date.c:168
msgid ""
"  -r, --reference=FILE       display the last modification time of FILE\n"
msgstr ""

#: src/date.c:171
msgid ""
"  -s, --set=STRING           set time described by STRING\n"
"  -u, --utc, --universal     print or set Coordinated Universal Time (UTC)\n"
msgstr ""

#: src/date.c:177
msgid ""
"\n"
"FORMAT controls the output.  Interpreted sequences are:\n"
"\n"
"  %%   a literal %\n"
"  %a   locale's abbreviated weekday name (e.g., Sun)\n"
msgstr ""
"\n"
"给定的格式FORMAT 控制着输出，解释序列如下：\n"
"\n"
"  %%\t一个文字的 %\n"
"  %a\t当前locale 的星期名缩写(例如： 日，代表星期日)\n"

#: src/date.c:184
msgid ""
"  %A   locale's full weekday name (e.g., Sunday)\n"
"  %b   locale's abbreviated month name (e.g., Jan)\n"
"  %B   locale's full month name (e.g., January)\n"
"  %c   locale's date and time (e.g., Thu Mar  3 23:05:25 2005)\n"
msgstr ""
"  %A\t当前locale 的星期名全称 (如：星期日)\n"
"  %b\t当前locale 的月名缩写 (如：一，代表一月)\n"
"  %B\t当前locale 的月名全称 (如：一月)\n"
"  %c\t当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25)\n"

#: src/date.c:190
msgid ""
"  %C   century; like %Y, except omit last two digits (e.g., 20)\n"
"  %d   day of month (e.g., 01)\n"
"  %D   date; same as %m/%d/%y\n"
"  %e   day of month, space padded; same as %_d\n"
msgstr ""
"  %C\t世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20)\n"
"  %d\t按月计的日期(例如：01)\n"
"  %D\t按月计的日期；等于%m/%d/%y\n"
"  %e\t按月计的日期，添加空格，等于%_d\n"

#: src/date.c:196
msgid ""
"  %F   full date; same as %Y-%m-%d\n"
"  %g   last two digits of year of ISO week number (see %G)\n"
"  %G   year of ISO week number (see %V); normally useful only with %V\n"
msgstr ""
"  %F\t完整日期格式，等价于 %Y-%m-%d\n"
"  %g\tISO-8601 格式年份的最后两位 (参见%G)\n"
"  %G\tISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用\n"

#: src/date.c:201
msgid ""
"  %h   same as %b\n"
"  %H   hour (00..23)\n"
"  %I   hour (01..12)\n"
"  %j   day of year (001..366)\n"
msgstr ""
"  %h\t等于%b\n"
"  %H\t小时(00-23)\n"
"  %I\t小时(00-12)\n"
"  %j\t按年计的日期(001-366)\n"

#: src/date.c:207
msgid ""
"  %k   hour, space padded ( 0..23); same as %_H\n"
"  %l   hour, space padded ( 1..12); same as %_I\n"
"  %m   month (01..12)\n"
"  %M   minute (00..59)\n"
msgstr ""

#: src/date.c:213
msgid ""
"  %n   a newline\n"
"  %N   nanoseconds (000000000..999999999)\n"
"  %p   locale's equivalent of either AM or PM; blank if not known\n"
"  %P   like %p, but lower case\n"
"  %q   quarter of year (1..4)\n"
"  %r   locale's 12-hour clock time (e.g., 11:11:04 PM)\n"
"  %R   24-hour hour and minute; same as %H:%M\n"
"  %s   seconds since 1970-01-01 00:00:00 UTC\n"
msgstr ""

#: src/date.c:223
msgid ""
"  %S   second (00..60)\n"
"  %t   a tab\n"
"  %T   time; same as %H:%M:%S\n"
"  %u   day of week (1..7); 1 is Monday\n"
msgstr ""
"  %S\t秒(00-60)\n"
"  %t\t输出制表符 Tab\n"
"  %T\t时间，等于%H:%M:%S\n"
"  %u\t星期，1 代表星期一\n"

#: src/date.c:229
msgid ""
"  %U   week number of year, with Sunday as first day of week (00..53)\n"
"  %V   ISO week number, with Monday as first day of week (01..53)\n"
"  %w   day of week (0..6); 0 is Sunday\n"
"  %W   week number of year, with Monday as first day of week (00..53)\n"
msgstr ""
"  %U\t一年中的第几周，以周日为每星期第一天(00-53)\n"
"  %V\tISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53)\n"
"  %w\t一星期中的第几日(0-6)，0 代表周一\n"
"  %W\t一年中的第几周，以周一为每星期第一天(00-53)\n"

#: src/date.c:235
msgid ""
"  %x   locale's date representation (e.g., 12/31/99)\n"
"  %X   locale's time representation (e.g., 23:13:48)\n"
"  %y   last two digits of year (00..99)\n"
"  %Y   year\n"
msgstr ""
"  %x\t当前locale 下的日期描述 (如：12/31/99)\n"
"  %X\t当前locale 下的时间描述 (如：23:13:48)\n"
"  %y\t年份最后两位数位 (00-99)\n"
"  %Y\t年份\n"

#: src/date.c:241
msgid ""
"  %z   +hhmm numeric time zone (e.g., -0400)\n"
"  %:z  +hh:mm numeric time zone (e.g., -04:00)\n"
"  %::z  +hh:mm:ss numeric time zone (e.g., -04:00:00)\n"
"  %:::z  numeric time zone with : to necessary precision (e.g., -04, "
"+05:30)\n"
"  %Z   alphabetic time zone abbreviation (e.g., EDT)\n"
"\n"
"By default, date pads numeric fields with zeroes.\n"
msgstr ""
"  %z +hhmm\t\t数字时区(例如，-0400)\n"
"  %:z +hh:mm\t\t数字时区(例如，-04:00)\n"
"  %::z +hh:mm:ss\t数字时区(例如，-04:00:00)\n"
"  %:::z\t\t\t数字时区带有必要的精度 (例如，-04，+05:30)\n"
"  %Z\t\t\t按字母表排序的时区缩写 (例如，EDT)\n"
"\n"
"默认情况下，日期的数字区域以0 填充。\n"

#: src/date.c:250
msgid ""
"The following optional flags may follow '%':\n"
"\n"
"  -  (hyphen) do not pad the field\n"
"  _  (underscore) pad with spaces\n"
"  0  (zero) pad with zeros\n"
"  ^  use upper case if possible\n"
"  #  use opposite case if possible\n"
msgstr ""

#: src/date.c:259
msgid ""
"\n"
"After any flags comes an optional field width, as a decimal number;\n"
"then an optional modifier, which is either\n"
"E to use the locale's alternate representations if available, or\n"
"O to use the locale's alternate numeric symbols if available.\n"
msgstr ""
"\n"
"在任何标记之后还允许一个可选的域宽度指定，它是一个十进制数字。\n"
"作为一个可选的修饰声明，它可以是E，在可能的情况下使用本地环境关联的\n"
"表示方式；或者是O，在可能的情况下使用本地环境关联的数字符号。\n"

#: src/date.c:266
msgid ""
"\n"
"Examples:\n"
"Convert seconds since the epoch (1970-01-01 UTC) to a date\n"
"  $ date --date='@2147483647'\n"
"\n"
"Show the time on the west coast of the US (use tzselect(1) to find TZ)\n"
"  $ TZ='America/Los_Angeles' date\n"
"\n"
"Show the local time for 9AM next Friday on the west coast of the US\n"
"  $ date --date='TZ=\"America/Los_Angeles\" 09:00 next Fri'\n"
msgstr ""

#: src/date.c:300 src/dd.c:2416 src/head.c:880 src/md5sum.c:672
#: src/md5sum.c:1107 src/od.c:913 src/od.c:1978 src/pr.c:1148 src/pr.c:1347
#: src/pr.c:1470 src/stty.c:1368 src/tac.c:574 src/tail.c:364 src/tee.c:174
#: src/tr.c:1911 src/tsort.c:541 src/wc.c:205
msgid "standard input"
msgstr "标准输入"

#: src/date.c:329 src/date.c:557
#, c-format
msgid "invalid date %s"
msgstr "无效的日期%s"

#: src/date.c:443 src/date.c:477
msgid "multiple output formats specified"
msgstr "指定了多种输出格式"

#: src/date.c:455
#, c-format
msgid "the options to specify dates for printing are mutually exclusive"
msgstr "被指定的这几种日期显示选项是相互抵触的"

#: src/date.c:462
#, c-format
msgid "the options to print and set the time may not be used together"
msgstr "显示与设置时间的选项不能同时使用"

#: src/date.c:483
#, c-format
msgid ""
"the argument %s lacks a leading '+';\n"
"when using an option to specify date(s), any non-option\n"
"argument must be a format string beginning with '+'"
msgstr ""

#: src/date.c:565
#, c-format
msgid "cannot set date"
msgstr "无法设置日期"

#: src/date.c:599 src/du.c:388
#, c-format
msgid "time %s is out of range"
msgstr "时间%s 超出范围"

#. This is a proper name. See the gettext manual, section Names.
#: src/dd.c:45 src/factor.c:128 src/rm.c:40 src/tail.c:72 src/touch.c:42
#: src/wc.c:50
msgid "Paul Rubin"
msgstr "Paul Rubin"

#: src/dd.c:564
#, c-format
msgid ""
"Usage: %s [OPERAND]...\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s [操作数] ...\n"
"　或：%s 选项\n"

#: src/dd.c:569
msgid ""
"Copy a file, converting and formatting according to the operands.\n"
"\n"
"  bs=BYTES        read and write up to BYTES bytes at a time (default: "
"512);\n"
"                  overrides ibs and obs\n"
"  cbs=BYTES       convert BYTES bytes at a time\n"
"  conv=CONVS      convert the file as per the comma separated symbol list\n"
"  count=N         copy only N input blocks\n"
"  ibs=BYTES       read up to BYTES bytes at a time (default: 512)\n"
msgstr ""

#: src/dd.c:579
msgid ""
"  if=FILE         read from FILE instead of stdin\n"
"  iflag=FLAGS     read as per the comma separated symbol list\n"
"  obs=BYTES       write BYTES bytes at a time (default: 512)\n"
"  of=FILE         write to FILE instead of stdout\n"
"  oflag=FLAGS     write as per the comma separated symbol list\n"
"  seek=N          skip N obs-sized blocks at start of output\n"
"  skip=N          skip N ibs-sized blocks at start of input\n"
"  status=LEVEL    The LEVEL of information to print to stderr;\n"
"                  'none' suppresses everything but error messages,\n"
"                  'noxfer' suppresses the final transfer statistics,\n"
"                  'progress' shows periodic transfer statistics\n"
msgstr ""

#: src/dd.c:592
msgid ""
"\n"
"N and BYTES may be followed by the following multiplicative suffixes:\n"
"c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, xM =M,\n"
"GB =1000*1000*1000, G =1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"\n"
"Each CONV symbol may be:\n"
"\n"
msgstr ""

#: src/dd.c:601
msgid ""
"  ascii     from EBCDIC to ASCII\n"
"  ebcdic    from ASCII to EBCDIC\n"
"  ibm       from ASCII to alternate EBCDIC\n"
"  block     pad newline-terminated records with spaces to cbs-size\n"
"  unblock   replace trailing spaces in cbs-size records with newline\n"
"  lcase     change upper case to lower case\n"
"  ucase     change lower case to upper case\n"
"  sparse    try to seek rather than write the output for NUL input blocks\n"
"  swab      swap every pair of input bytes\n"
"  sync      pad every input block with NULs to ibs-size; when used\n"
"            with block or unblock, pad with spaces rather than NULs\n"
msgstr ""

#: src/dd.c:614
msgid ""
"  excl      fail if the output file already exists\n"
"  nocreat   do not create the output file\n"
"  notrunc   do not truncate the output file\n"
"  noerror   continue after read errors\n"
"  fdatasync  physically write output file data before finishing\n"
"  fsync     likewise, but also write metadata\n"
msgstr ""
"  excl\t\tfail if the output file already exists\n"
"  nocreat\tdo not create the output file\n"
"  notrunc\t不截断输出文件\n"
"  noerror\t读取数据发生错误后仍然继续\n"
"  fdatasync\t结束前将输出文件数据写入磁盘\n"
"  fsync\t类似上面，但是元数据也一同写入\n"

#: src/dd.c:622
msgid ""
"\n"
"Each FLAG symbol may be:\n"
"\n"
"  append    append mode (makes sense only for output; conv=notrunc "
"suggested)\n"
msgstr ""
"\n"
"FLAG 符号可以是：\n"
"\n"
"  append\t追加模式(仅对输出有意义；隐含了conv=notrunc)\n"

#: src/dd.c:629
msgid "  cio       use concurrent I/O for data\n"
msgstr "  cio\t使用并行I/O 存取模式\n"

#: src/dd.c:631
msgid "  direct    use direct I/O for data\n"
msgstr "  direct\t使用直接I/O 存取模式\n"

#: src/dd.c:633
msgid "  directory  fail unless a directory\n"
msgstr "  directory\t除非是目录，否则 directory 失败\n"

#: src/dd.c:635
msgid "  dsync     use synchronized I/O for data\n"
msgstr "  dsync\t\t使用同步I/O 存取模式\n"

#: src/dd.c:637
msgid "  sync      likewise, but also for metadata\n"
msgstr "  sync\t\t与上者类似，但同时也对元数据生效\n"

#: src/dd.c:638
msgid "  fullblock  accumulate full blocks of input (iflag only)\n"
msgstr "  fullblock\t为输入积累完整块(仅iflag)\n"

#: src/dd.c:641
msgid "  nonblock  use non-blocking I/O\n"
msgstr "  nonblock\t使用无阻塞I/O 存取模式\n"

#: src/dd.c:643
msgid "  noatime   do not update access time\n"
msgstr "  noatime\t不更新存取时间\n"

#: src/dd.c:646
msgid "  nocache   Request to drop cache.  See also oflag=sync\n"
msgstr ""

#: src/dd.c:650
msgid "  noctty    do not assign controlling terminal from file\n"
msgstr "  noctty\t不根据文件指派控制终端\n"

#: src/dd.c:653
msgid "  nofollow  do not follow symlinks\n"
msgstr "  nofollow\t不跟随链接文件\n"

#: src/dd.c:655
msgid "  nolinks   fail if multiply-linked\n"
msgstr "  nolinks\t如果有多重链接，则nolinks 失败\n"

#: src/dd.c:657
msgid "  binary    use binary I/O for data\n"
msgstr "  binary\t使用二进制I/O 存取模式\n"

#: src/dd.c:659
msgid "  text      use text I/O for data\n"
msgstr "  text\t使用文本I/O 存取模式\n"

#: src/dd.c:661
msgid "  count_bytes  treat 'count=N' as a byte count (iflag only)\n"
msgstr ""

#: src/dd.c:664
msgid "  skip_bytes  treat 'skip=N' as a byte count (iflag only)\n"
msgstr ""

#: src/dd.c:667
msgid "  seek_bytes  treat 'seek=N' as a byte count (oflag only)\n"
msgstr ""

#: src/dd.c:671
#, c-format
msgid ""
"\n"
"Sending a %s signal to a running 'dd' process makes it\n"
"print I/O statistics to standard error and then resume copying.\n"
"\n"
"Options are:\n"
"\n"
msgstr ""

#: src/dd.c:707
#, c-format
msgid "memory exhausted by input buffer of size %<PRIuMAX> bytes (%s)"
msgstr ""

#: src/dd.c:735
#, c-format
msgid "memory exhausted by output buffer of size %<PRIuMAX> bytes (%s)"
msgstr ""

#: src/dd.c:803 src/du.c:400
msgid "Infinity"
msgstr ""

#: src/dd.c:822
#, c-format
msgid "%<PRIuMAX> byte copied, %s, %s"
msgid_plural "%<PRIuMAX> bytes copied, %s, %s"
msgstr[0] ""
msgstr[1] ""

#: src/dd.c:828
#, c-format
msgid "%<PRIuMAX> bytes (%s) copied, %s, %s"
msgstr ""

#: src/dd.c:831
#, c-format
msgid "%<PRIuMAX> bytes (%s, %s) copied, %s, %s"
msgstr ""

#: src/dd.c:863
#, c-format
msgid ""
"%<PRIuMAX>+%<PRIuMAX> records in\n"
"%<PRIuMAX>+%<PRIuMAX> records out\n"
msgstr ""
"记录了%<PRIuMAX>+%<PRIuMAX> 的读入\n"
"记录了%<PRIuMAX>+%<PRIuMAX> 的写出\n"

#: src/dd.c:869
#, c-format
msgid "%<PRIuMAX> truncated record\n"
msgid_plural "%<PRIuMAX> truncated records\n"
msgstr[0] "%<PRIuMAX> 个被截断了的块\n"

#: src/dd.c:954
#, c-format
msgid "closing input file %s"
msgstr "正在关闭输入文件%s"

#: src/dd.c:961
#, c-format
msgid "closing output file %s"
msgstr "正在关闭输出文件%s"

#: src/dd.c:1194
#, c-format
msgid "failed to turn off O_DIRECT: %s"
msgstr "无法关闭O_DIRECT：%s"

#: src/dd.c:1269 src/dd.c:2138
#, c-format
msgid "writing to %s"
msgstr "正在写入%s"

#: src/dd.c:1388
#, c-format
msgid "warning: %s is a zero multiplier; use %s if that is intended"
msgstr ""

#: src/dd.c:1426 src/dd.c:1487
#, c-format
msgid "unrecognized operand %s"
msgstr "无法识别的操作数%s"

#: src/dd.c:1438
msgid "invalid conversion"
msgstr "转换无效"

#: src/dd.c:1441 src/dd.c:1530
msgid "invalid input flag"
msgstr "输入标志无效"

#: src/dd.c:1444 src/dd.c:1524 src/dd.c:1536
msgid "invalid output flag"
msgstr "输出标志无效"

#: src/dd.c:1447
msgid "invalid status level"
msgstr ""

#: src/dd.c:1582
msgid "cannot combine any two of {ascii,ebcdic,ibm}"
msgstr "不可将{ascii、ebcdic、idm}中的任意两个结合使用"

#: src/dd.c:1584
msgid "cannot combine block and unblock"
msgstr "不可将block 和unblock 结合使用"

#: src/dd.c:1586
msgid "cannot combine lcase and ucase"
msgstr "不可将lcase 和ucase 结合使用"

#: src/dd.c:1588
msgid "cannot combine excl and nocreat"
msgstr "不可将excl 和nocreat 结合使用"

#: src/dd.c:1591
msgid "cannot combine direct and nocache"
msgstr "不可将direct 和nocreat 结合使用"

#: src/dd.c:1748
#, c-format
msgid ""
"warning: working around lseek kernel bug for file (%s)\n"
"  of mt_type=0x%0lx -- see <sys/mtio.h> for the list of types"
msgstr ""
"警告：暂时避免有关文件%s 的lseek 内核错误\n"
"  错误地址在mt_type=0x%0lx -- 有关mt_type 类型的列表请参考<sys/mtio.h>"

#: src/dd.c:1836
#, c-format
msgid "%s: cannot skip"
msgstr "%s：无法跳过"

#: src/dd.c:1838 src/dd.c:1869 src/dd.c:1930
#, c-format
msgid "%s: cannot seek"
msgstr "%s：无法搜索"

#: src/dd.c:1910
#, c-format
msgid "offset overflow while reading file %s"
msgstr "读入文件%s 时偏移量溢出"

#: src/dd.c:1922
#, c-format
msgid "warning: invalid file offset after failed read"
msgstr "警告：文件读取失败后偏移错误"

#: src/dd.c:1926
#, c-format
msgid "cannot work around kernel bug after all"
msgstr "无法避免内核的错误"

#: src/dd.c:2065
#, c-format
msgid "setting flags for %s"
msgstr "正在设置%s 的标记"

#: src/dd.c:2119
#, c-format
msgid "%s: cannot skip to specified offset"
msgstr "%s：无法跳至指定偏移量"

#: src/dd.c:2348
#, c-format
msgid "failed to truncate to %<PRIdMAX> bytes in output file %s"
msgstr ""

#: src/dd.c:2361
#, c-format
msgid "fdatasync failed for %s"
msgstr "%s 的fdatasync 失败"

#: src/dd.c:2371
#, c-format
msgid "fsync failed for %s"
msgstr "%s 的fsync 失败"

#: src/dd.c:2422 src/dd.c:2452 src/nohup.c:164 src/nohup.c:166
#, c-format
msgid "failed to open %s"
msgstr "打开%s 失败"

#: src/dd.c:2462
#, c-format
msgid ""
"offset too large: cannot truncate to a length of seek=%<PRIuMAX> (%lu-byte) "
"blocks"
msgstr "偏移量过大：无法在seek=%<PRIuMAX> (%lu-字节) 块的长度上实施截断"

#: src/dd.c:2483
#, c-format
msgid "failed to truncate to %<PRIuMAX> bytes in output file %s"
msgstr "无法针对输出文件%2$s 的%1$<PRIuMAX> 字节处实施截断"

#: src/dd.c:2500 src/dd.c:2506
#, c-format
msgid "failed to discard cache for: %s"
msgstr "无法丢弃缓存：%s"

#. This is a proper name. See the gettext manual, section Names.
#: src/df.c:46 src/du.c:55 src/expr.c:153 src/kill.c:34 src/pathchk.c:31
#: src/shuf.c:41 src/sleep.c:36 src/sort.c:67
msgid "Paul Eggert"
msgstr "Paul Eggert"

# ## Proof reading to here.
#: src/df.c:178
msgid "Filesystem"
msgstr "文件系统"

#: src/df.c:181
msgid "Type"
msgstr "类型"

#: src/df.c:184 src/df.c:551
msgid "blocks"
msgstr "块"

#: src/df.c:187
msgid "Used"
msgstr "已用"

#: src/df.c:190
msgid "Available"
msgstr "可用"

#: src/df.c:193
msgid "Use%"
msgstr "已用%"

#: src/df.c:196
msgid "Inodes"
msgstr "Inode"

#: src/df.c:199
msgid "IUsed"
msgstr "已用(I)"

#: src/df.c:202
msgid "IFree"
msgstr "可用(I)"

#: src/df.c:205
msgid "IUse%"
msgstr "已用(I)%"

#: src/df.c:208
msgid "Mounted on"
msgstr "挂载点"

#: src/df.c:211
msgid "File"
msgstr "文件"

#: src/df.c:391
#, c-format
msgid "option --output: field %s unknown"
msgstr ""

#: src/df.c:398
#, c-format
msgid "option --output: field %s used more than once"
msgstr ""

#: src/df.c:419 src/df.c:458
msgid "Size"
msgstr "容量"

#: src/df.c:423 src/df.c:460
msgid "Avail"
msgstr "可用"

#: src/df.c:483
msgid "Capacity"
msgstr "配额"

#. TRANSLATORS: this is the "1K-blocks" header in "df" output.
#. TRANSLATORS: this is the "1024-blocks" header in "df -P".
#: src/df.c:554 src/df.c:563
#, c-format
msgid "%s-%s"
msgstr "%s-%s"

#: src/df.c:1290
#, c-format
msgid "cannot access %s: over-mounted by another device"
msgstr ""

#: src/df.c:1459
msgid ""
"Show information about the file system on which each FILE resides,\n"
"or all file systems by default.\n"
msgstr ""

#. TRANSLATORS: The thousands and decimal separators are best
#. adjusted to an appropriate default for your locale.
#: src/df.c:1468
msgid ""
"  -a, --all             include pseudo, duplicate, inaccessible file "
"systems\n"
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes;\n"
"                           see SIZE format below\n"
"  -h, --human-readable  print sizes in powers of 1024 (e.g., 1023M)\n"
"  -H, --si              print sizes in powers of 1000 (e.g., 1.1G)\n"
msgstr ""

#: src/df.c:1476
msgid ""
"  -i, --inodes          list inode information instead of block usage\n"
"  -k                    like --block-size=1K\n"
"  -l, --local           limit listing to local file systems\n"
"      --no-sync         do not invoke sync before getting usage info "
"(default)\n"
msgstr ""
"  -i, --inodes\t\t显示inode 信息而非块使用量\n"
"  -k\t\t\t即--block-size=1K\n"
"  -l, --local\t\t只显示本机的文件系统\n"
"      --no-sync\t\t取得使用量数据前不进行同步动作(默认)\n"

#: src/df.c:1483
msgid ""
"      --output[=FIELD_LIST]  use the output format defined by FIELD_LIST,\n"
"                               or print all fields if FIELD_LIST is "
"omitted.\n"
"  -P, --portability     use the POSIX output format\n"
"      --sync            invoke sync before getting usage info\n"
msgstr ""

#: src/df.c:1489
msgid ""
"      --total           elide all entries insignificant to available space,\n"
"                          and produce a grand total\n"
msgstr ""

#: src/df.c:1493
msgid ""
"  -t, --type=TYPE       limit listing to file systems of type TYPE\n"
"  -T, --print-type      print file system type\n"
"  -x, --exclude-type=TYPE   limit listing to file systems not of type TYPE\n"
"  -v                    (ignored)\n"
msgstr ""

#: src/df.c:1503
msgid ""
"\n"
"FIELD_LIST is a comma-separated list of columns to be included.  Valid\n"
"field names are: 'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent',\n"
"'size', 'used', 'avail', 'pcent', 'file' and 'target' (see info page).\n"
msgstr ""

#: src/df.c:1540
#, c-format
msgid "options %s and %s are mutually exclusive"
msgstr ""

#: src/df.c:1690
#, c-format
msgid "file system type %s both selected and excluded"
msgstr "不能同时选择和排除文件系统类型%s"

#: src/df.c:1749
msgid "Warning: "
msgstr "警告： "

#: src/df.c:1751 src/stat.c:904
msgid "cannot read table of mounted file systems"
msgstr "%s 无法读取已挂载上的文件系统的目录"

#: src/df.c:1788
msgid "no file systems processed"
msgstr "未处理文件系统"

#. This is a proper name. See the gettext manual, section Names.
#: src/dircolors.c:37
msgid "H. Peter Anvin"
msgstr "H. Peter Anvin"

#: src/dircolors.c:99 src/uptime.c:204 src/users.c:111
#, c-format
msgid "Usage: %s [OPTION]... [FILE]\n"
msgstr "用法：%s [选项]... [文件]\n"

#: src/dircolors.c:100
msgid ""
"Output commands to set the LS_COLORS environment variable.\n"
"\n"
"Determine format of output:\n"
"  -b, --sh, --bourne-shell    output Bourne shell code to set LS_COLORS\n"
"  -c, --csh, --c-shell        output C shell code to set LS_COLORS\n"
"  -p, --print-database        output defaults\n"
msgstr ""
"输出用来设置 LS_COLORS 环境变量的命令。\n"
"\n"
"指定输出的规格：\n"
"  -b, --sh, --bourne-shell\t输出设置LS_COLORS 的Bourne shell 命令\n"
"  -c, --csh, --c-shell\t\t输出设置LS_COLORS 的C shell 命令\n"
"  -p, --print-database\t\t输出默认的色彩设置\n"

#: src/dircolors.c:110
msgid ""
"\n"
"If FILE is specified, read it to determine which colors to use for which\n"
"file types and extensions.  Otherwise, a precompiled database is used.\n"
"For details on the format of these files, run 'dircolors --print-database'.\n"
msgstr ""

#: src/dircolors.c:288
#, c-format
msgid "%s:%lu: invalid line;  missing second token"
msgstr "%s：%lu：此行无效；缺少了第二栏数据"

#: src/dircolors.c:360
#, c-format
msgid "%s:%lu: unrecognized keyword %s"
msgstr "%s：%lu：无法识别的关键字%s"

#: src/dircolors.c:361
msgid "<internal>"
msgstr "<内部数据>"

#: src/dircolors.c:442
#, c-format
msgid ""
"the options to output dircolors' internal database and\n"
"to select a shell syntax are mutually exclusive"
msgstr ""
"显示 dircolors 内部数据库的选项和选择 shell 语法的选项\n"
"是互相抵触的"

#: src/dircolors.c:452
msgid "file operands cannot be combined with --print-database (-p)"
msgstr "文件操作和--print-database (-p)不能同时使用"

#: src/dircolors.c:475
msgid "no SHELL environment variable, and no shell type option given"
msgstr "没有设置SHELL 环境变量，也没有指定shell 类型的选项"

#: src/dirname.c:50
#, c-format
msgid "Usage: %s [OPTION] NAME...\n"
msgstr "用法：%s [选项] 名称...\n"

#: src/dirname.c:54
msgid ""
"Output each NAME with its last non-slash component and trailing slashes\n"
"removed; if NAME contains no /'s, output '.' (meaning the current "
"directory).\n"
"\n"
msgstr ""

#: src/dirname.c:59
msgid "  -z, --zero     end each output line with NUL, not newline\n"
msgstr ""

#: src/dirname.c:64
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/          -> \"/usr\"\n"
"  %s dir1/str dir2/str  -> \"dir1\" followed by \"dir2\"\n"
"  %s stdio.h            -> \".\"\n"
msgstr ""

#: src/du.c:284 src/sort.c:427 src/wc.c:115
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [OPTION]... --files0-from=F\n"
msgstr ""
"用法：%s [选项]... [文件]...\n"
"　或：%s [选项]... --files0-from=F\n"

#: src/du.c:288
msgid ""
"Summarize disk usage of the set of FILEs, recursively for directories.\n"
msgstr ""

#: src/du.c:294
msgid ""
"  -0, --null            end each output line with NUL, not newline\n"
"  -a, --all             write counts for all files, not just directories\n"
"      --apparent-size   print apparent sizes, rather than disk usage; "
"although\n"
"                          the apparent size is usually smaller, it may be\n"
"                          larger due to holes in ('sparse') files, internal\n"
"                          fragmentation, indirect blocks, and the like\n"
msgstr ""

#: src/du.c:303
msgid ""
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes;\n"
"                           see SIZE format below\n"
"  -b, --bytes           equivalent to '--apparent-size --block-size=1'\n"
"  -c, --total           produce a grand total\n"
"  -D, --dereference-args  dereference only symlinks that are listed on the\n"
"                          command line\n"
"  -d, --max-depth=N     print the total for a directory (or file, with --"
"all)\n"
"                          only if it is N or fewer levels below the command\n"
"                          line argument;  --max-depth=0 is the same as\n"
"                          --summarize\n"
msgstr ""

#: src/du.c:316
msgid ""
"      --files0-from=F   summarize disk usage of the\n"
"                          NUL-terminated file names specified in file F;\n"
"                          if F is -, then read names from standard input\n"
"  -H                    equivalent to --dereference-args (-D)\n"
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
"      --inodes          list inode usage information instead of block usage\n"
msgstr ""

#: src/du.c:325
msgid ""
"  -k                    like --block-size=1K\n"
"  -L, --dereference     dereference all symbolic links\n"
"  -l, --count-links     count sizes many times if hard linked\n"
"  -m                    like --block-size=1M\n"
msgstr ""

#: src/du.c:331
msgid ""
"  -P, --no-dereference  don't follow any symbolic links (this is the "
"default)\n"
"  -S, --separate-dirs   for directories do not include size of "
"subdirectories\n"
"      --si              like -h, but use powers of 1000 not 1024\n"
"  -s, --summarize       display only a total for each argument\n"
msgstr ""

#: src/du.c:337
msgid ""
"  -t, --threshold=SIZE  exclude entries smaller than SIZE if positive,\n"
"                          or entries greater than SIZE if negative\n"
"      --time            show time of the last modification of any file in "
"the\n"
"                          directory, or any of its subdirectories\n"
"      --time=WORD       show time as WORD instead of modification time:\n"
"                          atime, access, use, ctime or status\n"
"      --time-style=STYLE  show times using STYLE, which can be:\n"
"                            full-iso, long-iso, iso, or +FORMAT;\n"
"                            FORMAT is interpreted like in 'date'\n"
msgstr ""

#: src/du.c:348
msgid ""
"  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n"
"      --exclude=PATTERN    exclude files that match PATTERN\n"
"  -x, --one-file-system    skip directories on different file systems\n"
msgstr ""

#: src/du.c:695
#, c-format
msgid "fts_read failed: %s"
msgstr "fts_read 失败：%s"

#: src/du.c:819
#, c-format
msgid "invalid maximum depth %s"
msgstr "目录最大深度%s 无效"

#: src/du.c:848
msgid "invalid --threshold argument '-0'"
msgstr ""

#: src/du.c:931
#, c-format
msgid "cannot both summarize and show all entries"
msgstr "不能既显示总用量，同时又显示每个项目"

#: src/du.c:938
#, c-format
msgid "warning: summarizing is the same as using --max-depth=0"
msgstr "警告：显示总用量等价于使用--max-depth=0"

#: src/du.c:944
#, c-format
msgid "warning: summarizing conflicts with --max-depth=%lu"
msgstr "警告：显示总用量的选项和--max-depth=%lu 互斥"

#: src/du.c:955
#, c-format
msgid "warning: options --apparent-size and -b are ineffective with --inodes"
msgstr ""

#: src/du.c:1020 src/sort.c:4597 src/wc.c:739
msgid "file operands cannot be combined with --files0-from"
msgstr "文件操作数不能于--files0-from 参数一起使用"

#: src/du.c:1087 src/sort.c:4618 src/wc.c:817
#, c-format
msgid "when reading file names from stdin, no file name of %s allowed"
msgstr "当从标准输入读取时，不允许指定文件名%s"

#: src/du.c:1104 src/du.c:1112 src/wc.c:830 src/wc.c:838
msgid "invalid zero-length file name"
msgstr "无效的零长度文件名"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:26
msgid "Brian Fox"
msgstr "Brian Fox"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:27
msgid "Chet Ramey"
msgstr "Chet Ramey"

#: src/echo.c:41
#, c-format
msgid ""
"Usage: %s [SHORT-OPTION]... [STRING]...\n"
"  or:  %s LONG-OPTION\n"
msgstr ""
"用法：%s [短选项]... [字符串]...\n"
"　或：%s 长选项\n"

#: src/echo.c:45
msgid ""
"Echo the STRING(s) to standard output.\n"
"\n"
"  -n             do not output the trailing newline\n"
msgstr ""
"将 STRING 回显到标准输出。\n"
"\n"
"  -n\t\t不尾随换行符\n"

#: src/echo.c:51
msgid ""
"  -e             enable interpretation of backslash escapes (default)\n"
"  -E             disable interpretation of backslash escapes\n"
msgstr ""
"  -e\t\t启用解释反斜杠的转义功能(默认)\n"
"  -E\t\t禁用解释反斜杠的转义功能\n"

#: src/echo.c:54
msgid ""
"  -e             enable interpretation of backslash escapes\n"
"  -E             disable interpretation of backslash escapes (default)\n"
msgstr ""
"  -e\t\t启用解释反斜杠的转义功能\n"
"  -E\t\t禁用解释反斜杠的转义功能(默认)\n"

#: src/echo.c:60
msgid ""
"\n"
"If -e is in effect, the following sequences are recognized:\n"
"\n"
msgstr ""
"\n"
"若-e 可用，则以下序列即可识别：\n"
"\n"

#: src/echo.c:65 src/printf.c:110
msgid ""
"  \\\\      backslash\n"
"  \\a      alert (BEL)\n"
"  \\b      backspace\n"
"  \\c      produce no further output\n"
"  \\e      escape\n"
"  \\f      form feed\n"
"  \\n      new line\n"
"  \\r      carriage return\n"
"  \\t      horizontal tab\n"
"  \\v      vertical tab\n"
msgstr ""
"  \\\\    反斜杠\n"
"  \\a    响铃声\n"
"  \\b    退格\n"
"  \\c    不再产生新的输出\n"
"  \\e    转义符  \n"
"  \\f    换页\n"
"  \\n    新行\n"
"  \\r    回车\n"
"  \\t    水平制表符\n"
"  \\v    竖直制表符\n"

#: src/echo.c:77
msgid ""
"  \\0NNN   byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
msgstr ""
"  \\0NNN   字节数以八进制数 NNN (1至3位)表示\n"
"  \\xHH    字节数以十六进制数 HH (1至2位)表示\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/env.c:35 src/printenv.c:45 src/whoami.c:36
msgid "Richard Mlynarik"
msgstr "Richard Mlynarik"

#. This is a proper name. See the gettext manual, section Names.
#: src/env.c:37 src/numfmt.c:43
msgid "Assaf Gordon"
msgstr ""

#: src/env.c:73
#, c-format
msgid "Usage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n"
msgstr "用法：%s [选项]... [-] [名称=值]... [命令 [参数]...]\n"

#: src/env.c:76
msgid "Set each NAME to VALUE in the environment and run COMMAND.\n"
msgstr ""

#: src/env.c:82
msgid ""
"  -i, --ignore-environment  start with an empty environment\n"
"  -0, --null           end each output line with NUL, not newline\n"
"  -u, --unset=NAME     remove variable from the environment\n"
msgstr ""

#: src/env.c:87
msgid "  -C, --chdir=DIR      change working directory to DIR\n"
msgstr "  -C, --chdir=目录     将工作目录变更为指定目录\n"

#: src/env.c:90
msgid ""
"  -S, --split-string=S  process and split S into separate arguments;\n"
"                        used to pass multiple arguments on shebang lines\n"
"  -v, --debug          print verbose information for each processing step\n"
msgstr ""

#: src/env.c:97
msgid ""
"\n"
"A mere - implies -i.  If no COMMAND, print the resulting environment.\n"
msgstr ""
"\n"
"单纯的 - 意味着 -i。如果没有命令，则打印结果环境。\n"

#: src/env.c:122
#, c-format
msgid "cannot unset %s"
msgstr "无法撤消 %s"

#: src/env.c:256
msgid "'\\c' must not appear in double-quoted -S string"
msgstr ""

#: src/env.c:260
msgid "invalid backslash at end of string in -S"
msgstr ""

#: src/env.c:263
#, c-format
msgid "invalid sequence '\\%c' in -S"
msgstr ""

#: src/env.c:277
#, c-format
msgid "only ${VARNAME} expansion is supported, error at: %s"
msgstr ""

#: src/env.c:288
msgid "no terminating quote in -S string"
msgstr ""

#: src/env.c:573
#, c-format
msgid "invalid option -- '%c'"
msgstr ""

#: src/env.c:574 src/env.c:658
#, c-format
msgid "use -[v]S to pass options in shebang lines"
msgstr ""

#: src/env.c:607
#, c-format
msgid "cannot set %s"
msgstr "无法设定 %s"

#: src/env.c:617
#, c-format
msgid "cannot specify --null (-0) with command"
msgstr "无法以命令指定--null (-0)"

#: src/env.c:623
#, c-format
msgid "must specify command with --chdir (-C)"
msgstr ""

#: src/env.c:641
#, c-format
msgid "cannot change directory to %s"
msgstr ""

#: src/expand-common.c:90
msgid "tabs are too far apart"
msgstr "制表符过于分散"

#: src/expand-common.c:103
#, c-format
msgid "'/' specifier only allowed with the last value"
msgstr ""

#: src/expand-common.c:120
#, c-format
msgid "'+' specifier only allowed with the last value"
msgstr ""

#: src/expand-common.c:172
#, c-format
msgid "'/' specifier not at start of number: %s"
msgstr ""

#: src/expand-common.c:183
#, c-format
msgid "'+' specifier not at start of number: %s"
msgstr ""

#: src/expand-common.c:204
#, c-format
msgid "tab stop is too large %s"
msgstr "%s：制表符跳格量过大"

#: src/expand-common.c:212
#, c-format
msgid "tab size contains invalid character(s): %s"
msgstr "制表符尺寸中包含无效字符：%s"

#: src/expand-common.c:244
msgid "tab size cannot be 0"
msgstr "制表符尺寸不可为0"

#: src/expand-common.c:246
msgid "tab sizes must be ascending"
msgstr "制表符尺寸必须是升序的"

#: src/expand-common.c:251
msgid "'/' specifier is mutually exclusive with '+'"
msgstr ""

#: src/expand-common.c:390
msgid "  -t, --tabs=LIST  use comma separated list of tab positions\n"
msgstr ""

#: src/expand-common.c:393
msgid ""
"                     The last specified position can be prefixed with '/'\n"
"                     to specify a tab size to use after the last\n"
"                     explicitly specified tab stop.  Also a prefix of '+'\n"
"                     can be used to align remaining tab stops relative to\n"
"                     the last specified tab stop instead of the first "
"column\n"
msgstr ""

#: src/expand.c:73
msgid "Convert tabs in each FILE to spaces, writing to standard output.\n"
msgstr ""

#: src/expand.c:80
msgid ""
"  -i, --initial    do not convert tabs after non blanks\n"
"  -t, --tabs=N     have tabs N characters apart, not 8\n"
msgstr ""

#: src/expand.c:146 src/expand.c:165 src/unexpand.c:181 src/unexpand.c:226
msgid "input line is too long"
msgstr "输入行太长"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:151 src/ln.c:42 src/mv.c:42 src/tee.c:36
msgid "Mike Parker"
msgstr "Mike Parker"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:152 src/groups.c:37
msgid "James Youngman"
msgstr "James Youngman"

#: src/expr.c:345
#, c-format
msgid ""
"Usage: %s EXPRESSION\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 表达式\n"
"　或：%s 选项\n"

#: src/expr.c:353
msgid ""
"\n"
"Print the value of EXPRESSION to standard output.  A blank line below\n"
"separates increasing precedence groups.  EXPRESSION may be:\n"
"\n"
"  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n"
"\n"
"  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0\n"
msgstr ""
"\n"
"将表达式的值列印到标准输出，分隔符下面的空行可提升算式优先级。\n"
"可用的表达式有：\n"
"\n"
"  ARG1 | ARG2       若ARG1 的值不为0 或者为空，则返回ARG1，否则返回ARG2\n"
"\n"
"  ARG1 & ARG2       若两边的值都不为0 或为空，则返回ARG1，否则返回 0\n"

#: src/expr.c:362
msgid ""
"\n"
"  ARG1 < ARG2       ARG1 is less than ARG2\n"
"  ARG1 <= ARG2      ARG1 is less than or equal to ARG2\n"
"  ARG1 = ARG2       ARG1 is equal to ARG2\n"
"  ARG1 != ARG2      ARG1 is unequal to ARG2\n"
"  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2\n"
"  ARG1 > ARG2       ARG1 is greater than ARG2\n"
msgstr ""
"\n"
"  ARG1 < ARG2       ARG1 小于ARG2\n"
"  ARG1 <= ARG2      ARG1 小于或等于ARG2\n"
"  ARG1 = ARG2       ARG1 等于ARG2\n"
"  ARG1 != ARG2      ARG1 不等于ARG2\n"
"  ARG1 >= ARG2      ARG1 大于或等于ARG2\n"
"  ARG1 > ARG2       ARG1 大于ARG2\n"

#: src/expr.c:371
msgid ""
"\n"
"  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2\n"
"  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2\n"
msgstr ""
"\n"
"  ARG1 + ARG2       计算 ARG1 与ARG2 相加之和\n"
"  ARG1 - ARG2       计算 ARG1 与ARG2 相减之差\n"

#: src/expr.c:378
#, no-c-format
msgid ""
"\n"
"  ARG1 * ARG2       arithmetic product of ARG1 and ARG2\n"
"  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2\n"
"  ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2\n"
msgstr ""
"\n"
"  ARG1 * ARG2       计算 ARG1 与ARG2 相乘之积\n"
"  ARG1 / ARG2       计算 ARG1 与ARG2 相除之商\n"
"  ARG1 % ARG2       计算 ARG1 与ARG2 相除之余数\n"

#: src/expr.c:384
msgid ""
"\n"
"  STRING : REGEXP   anchored pattern match of REGEXP in STRING\n"
"\n"
"  match STRING REGEXP        same as STRING : REGEXP\n"
"  substr STRING POS LENGTH   substring of STRING, POS counted from 1\n"
"  index STRING CHARS         index in STRING where any CHARS is found, or 0\n"
"  length STRING              length of STRING\n"
msgstr ""
"\n"
"  字符串 : 表达式\t\t定位字符串中匹配表达式的模式\n"
"\n"
"  match 字符串 表达式\t\t等于\"字符串 :表达式\"\n"
"  substr 字符串 偏移量 长度\t替换字符串的子串，偏移的数值从 1 起计\n"
"  index 字符串 字符\t\t在字符串中发现字符的地方建立下标，或者标0\n"
"  length 字符串\t\t\t字符串的长度\n"

#: src/expr.c:393
msgid ""
"  + TOKEN                    interpret TOKEN as a string, even if it is a\n"
"                               keyword like 'match' or an operator like '/'\n"
"\n"
"  ( EXPRESSION )             value of EXPRESSION\n"
msgstr ""

#: src/expr.c:399
msgid ""
"\n"
"Beware that many operators need to be escaped or quoted for shells.\n"
"Comparisons are arithmetic if both ARGs are numbers, else lexicographical.\n"
"Pattern matches return the string matched between \\( and \\) or null; if\n"
"\\( and \\) are not used, they return the number of characters matched or "
"0.\n"
msgstr ""
"\n"
"请注意有许多运算操作符都可能需要由 shell 先实施转义。\n"
"如果参与运算的 ARG 自变量都是数字，比较符就会被视作数学符号，否则就是多义的。\n"
"模式匹配会返回\"\\\"和\"\\\"之间被匹配的子字符串或空(null)；如果未使用\"\\\"和\"\\\"，\n"
"则会返回匹配字符数量或是 0。\n"

#: src/expr.c:406
msgid ""
"\n"
"Exit status is 0 if EXPRESSION is neither null nor 0, 1 if EXPRESSION is "
"null\n"
"or 0, 2 if EXPRESSION is syntactically invalid, and 3 if an error occurred.\n"
msgstr ""
"\n"
"若表达式的值既不是空也不是 0，退出状态值为 0；若表达式的值为空或为 0，\n"
"退出状态值为 1。如果表达式的句法无效，则会在出错时返回退出状态值 3。\n"

#: src/expr.c:462
#, c-format
msgid "syntax error: unexpected argument %s"
msgstr ""

#: src/expr.c:665
#, c-format
msgid "syntax error: missing argument after %s"
msgstr ""

#: src/expr.c:748 src/ptx.c:289
msgid "error in regular expression matcher"
msgstr "正则表达式匹配器出错"

#: src/expr.c:776
#, c-format
msgid "syntax error: expecting ')' after %s"
msgstr ""

#: src/expr.c:779
#, c-format
msgid "syntax error: expecting ')' instead of %s"
msgstr ""

#: src/expr.c:785
msgid "syntax error: unexpected ')'"
msgstr ""

#: src/expr.c:931 src/expr.c:968
msgid "non-integer argument"
msgstr "非整数参数"

#: src/expr.c:933 src/truncate.c:289
msgid "division by zero"
msgstr "除以零"

#: src/expr.c:1027 src/sort.c:2113
#, c-format
msgid "set LC_ALL='C' to work around the problem"
msgstr "请设置LC_ALL='C' 以避免出现问题。"

#: src/expr.c:1029
#, c-format
msgid "the strings compared were %s and %s"
msgstr "已比较的字符串为%s 和%s"

#. This is a proper name. See the gettext manual, section Names.
#: src/factor.c:130
msgid "Niels Moller"
msgstr ""

#: src/factor.c:1276 src/factor.c:1376 src/factor.c:1452
#, c-format
msgid "Lucas prime test failure.  This should not happen"
msgstr ""

#: src/factor.c:2103
msgid "squfof queue overflow"
msgstr ""

#: src/factor.c:2525
#, c-format
msgid "%s is not a valid positive integer"
msgstr "%s 不是有效的正整数"

#: src/factor.c:2549 src/od.c:1691 src/od.c:1772
#, c-format
msgid "%s is too large"
msgstr "%s 太大"

#: src/factor.c:2561
#, c-format
msgid ""
"Usage: %s [NUMBER]...\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s [数字]...\n"
"　或：%s 选项\n"

#: src/factor.c:2566
msgid ""
"Print the prime factors of each specified integer NUMBER.  If none\n"
"are specified on the command line, read them from standard input.\n"
"\n"
msgstr ""
"输出每个指定的数字的素因子，如果没有在命令行中指定则从标准输入读取。\n"
"\n"

#: src/find-mount-point.c:40
#, c-format
msgid "cannot get current directory"
msgstr "无法获得当前目录"

#: src/find-mount-point.c:50 src/find-mount-point.c:64
#: src/find-mount-point.c:92
#, c-format
msgid "cannot change to directory %s"
msgstr "无法进入目录%s"

#: src/find-mount-point.c:70
#, c-format
msgid "cannot stat current directory (now %s)"
msgstr "无法获取当前目录的文件状态(stat，当前目录是%s)"

#. This is a proper name. See the gettext manual, section Names.
#: src/fmt.c:37
msgid "Ross Paterson"
msgstr "Ross Paterson"

#: src/fmt.c:269
#, c-format
msgid "Usage: %s [-WIDTH] [OPTION]... [FILE]...\n"
msgstr "用法：%s [-宽度] [选项]... [文件]...\n"

#: src/fmt.c:270
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"The option -WIDTH is an abbreviated form of --width=DIGITS.\n"
msgstr ""

#: src/fmt.c:278
msgid ""
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       reformat only lines beginning with STRING,\n"
"                              reattaching the prefix to reformatted lines\n"
"  -s, --split-only          split long lines, but do not refill\n"
msgstr ""
"  -c --crown-margin\t\t保持前两行的缩进\n"
"  -p, --prefix=字符串\t\t只对以指定字符串开头的行重新格式化，\n"
"\t\t\t\t将前缀重新附着到被重新格式化的行上\n"
"  -s, --split-only\t\t分割过长的行，但不自动补足\n"

#: src/fmt.c:287
#, no-c-format
msgid ""
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=WIDTH         maximum line width (default of 75 columns)\n"
"  -g, --goal=WIDTH          goal width (default of 93% of width)\n"
msgstr ""

#: src/fmt.c:355
#, c-format
msgid ""
"invalid option -- %c; -WIDTH is recognized only when it is the first\n"
"option; use -w N instead"
msgstr "无效选项 -- %c；宽度必须是第一个选项才能被正确识别；请使用 -w N"

#: src/fmt.c:399 src/fmt.c:406
msgid "invalid width"
msgstr ""

#: src/fold.c:70
msgid "Wrap input lines in each FILE, writing to standard output.\n"
msgstr ""

#: src/fold.c:77
msgid ""
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""
"  -b, --bytes\t\t计算字节数而不是列数\n"
"  -s,  --spaces\t\t在空格处断行\n"
"  -w, --width=宽度\t使用指定的列宽度代替默认的80\n"

#: src/fold.c:284 src/pr.c:840
msgid "invalid number of columns"
msgstr ""

#. This is a proper name. See the gettext manual, section Names.
#: src/getlimits.c:30 src/md5sum.c:107 src/realpath.c:33 src/stdbuf.c:38
#: src/timeout.c:78 src/truncate.c:38
msgid "Padraig Brady"
msgstr "Padraig Brady"

#: src/getlimits.c:66
#, c-format
msgid "Usage: %s\n"
msgstr "用法：%s\n"

#: src/getlimits.c:70
msgid ""
"Output platform dependent limits in a format useful for shell scripts.\n"
"\n"
msgstr ""
"为Shell 脚本格式输出基于操作平台的限制参数。\n"
"\n"

#: src/group-list.c:68 src/id.c:414
#, c-format
msgid "failed to get groups for user %s"
msgstr "获取用户%s 的属组失败"

#: src/group-list.c:73 src/id.c:417
#, c-format
msgid "failed to get groups for the current process"
msgstr "获取当前进程用户组失败"

#: src/group-list.c:113
#, c-format
msgid "cannot find name for group ID %lu"
msgstr "无法找到ID 为%lu 的用户的属组"

#: src/groups.c:54
#, c-format
msgid "Usage: %s [OPTION]... [USERNAME]...\n"
msgstr "用法：%s [选项]... [用户名]...\n"

#: src/groups.c:55
msgid ""
"Print group memberships for each USERNAME or, if no USERNAME is specified, "
"for\n"
"the current process (which may differ if the groups database has changed).\n"
msgstr "显示每个输入的用户名所在的全部组，如果没有指定用户名则默认为当前进程用户(当用户组数据库发生变更时可能导致差异)。\n"

#: src/groups.c:106 src/id.c:277
msgid "cannot get real UID"
msgstr ""

#: src/groups.c:111 src/id.c:285
msgid "cannot get effective GID"
msgstr ""

#: src/groups.c:116 src/id.c:290
msgid "cannot get real GID"
msgstr ""

#: src/groups.c:130 src/id.c:249
#, c-format
msgid "%s: no such user"
msgstr "%s：无此用户"

#: src/head.c:114
#, c-format
msgid ""
"Print the first %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
msgstr ""

#: src/head.c:122
#, c-format
msgid ""
"  -c, --bytes=[-]NUM       print the first NUM bytes of each file;\n"
"                             with the leading '-', print all but the last\n"
"                             NUM bytes of each file\n"
"  -n, --lines=[-]NUM       print the first NUM lines instead of the first "
"%d;\n"
"                             with the leading '-', print all but the last\n"
"                             NUM lines of each file\n"
msgstr ""

#: src/head.c:130
msgid ""
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
msgstr ""
"  -q, --quiet, --silent\t不显示包含给定文件名的文件头\n"
"  -v, --verbose\t\t总是显示包含给定文件名的文件头\n"

#: src/head.c:139
msgid ""
"\n"
"NUM may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
msgstr ""

#: src/head.c:159
#, c-format
msgid "%s: file has shrunk too much"
msgstr "%s：文件被过度收缩"

#: src/head.c:231 src/tail.c:484
#, c-format
msgid "%s: cannot seek to offset %s"
msgstr "%s：无法检索到偏移量%s"

#: src/head.c:232 src/tail.c:488
#, c-format
msgid "%s: cannot seek to relative offset %s"
msgstr "%s：无法检索相对偏移量 %s"

#: src/head.c:274
#, c-format
msgid "%s: number of bytes is too large"
msgstr "%s：字节数过大"

#: src/head.c:912 src/split.c:1367 src/split.c:1534 src/tail.c:2181
msgid "invalid number of lines"
msgstr "无效的号码%s"

#: src/head.c:913 src/head.c:1077 src/split.c:1359 src/split.c:1375
#: src/tail.c:2182
msgid "invalid number of bytes"
msgstr "无效的号码%s"

#: src/head.c:1003 src/head.c:1065
#, c-format
msgid "invalid trailing option -- %c"
msgstr "无效的加附选项 -- %c"

#: src/hostid.c:47
#, c-format
msgid ""
"Usage: %s [OPTION]\n"
"Print the numeric identifier (in hexadecimal) for the current host.\n"
"\n"
msgstr ""
"用法：%s [选项]\n"
"显示当前主机的数字标识符(十六进制)。\n"
"\n"

#: src/hostname.c:62
#, c-format
msgid ""
"Usage: %s [NAME]\n"
"  or:  %s OPTION\n"
"Print or set the hostname of the current system.\n"
"\n"
msgstr ""
"用法：%s [名称]\n"
"　或：%s 选项\n"
"显示或设置当前系统的主机名。\n"
"\n"

#: src/hostname.c:100
#, c-format
msgid "cannot set name to %s"
msgstr "无法设置主机名为%s"

#: src/hostname.c:104
msgid "cannot set hostname; this system lacks the functionality"
msgstr "无法设置主机名，此系统似乎不具备此功能"

#: src/hostname.c:112
msgid "cannot determine hostname"
msgstr "无法确定主机名"

#. This is a proper name. See the gettext manual, section Names.
#: src/id.c:41 src/touch.c:43
msgid "Arnold Robbins"
msgstr "Arnold Robbins"

#: src/id.c:85
#, c-format
msgid "Usage: %s [OPTION]... [USER]\n"
msgstr ""

#: src/id.c:86
msgid ""
"Print user and group information for the specified USER,\n"
"or (when USER omitted) for the current user.\n"
"\n"
msgstr ""

#: src/id.c:91
msgid ""
"  -a             ignore, for compatibility with other versions\n"
"  -Z, --context  print only the security context of the process\n"
"  -g, --group    print only the effective group ID\n"
"  -G, --groups   print all group IDs\n"
"  -n, --name     print a name instead of a number, for -ugG\n"
"  -r, --real     print the real ID instead of the effective ID, with -ugG\n"
"  -u, --user     print only the effective user ID\n"
"  -z, --zero     delimit entries with NUL characters, not whitespace;\n"
"                   not permitted in default format\n"
msgstr ""

#: src/id.c:104
msgid ""
"\n"
"Without any OPTION, print some useful set of identified information.\n"
msgstr ""
"\n"
"如果不附带任何选项，程序会显示一些可供识别用户身份的有用信息。\n"

#: src/id.c:152
msgid "--context (-Z) works only on an SELinux/SMACK-enabled kernel"
msgstr ""

#: src/id.c:157
msgid "--context (-Z) works only on an SELinux-enabled kernel"
msgstr "--context (-Z) 选项只能在开启SELinux 支持的内核上使用"

#: src/id.c:196
msgid "cannot print security context when user specified"
msgstr "不能显示特定用户的安全环境"

#: src/id.c:199
msgid "cannot print \"only\" of more than one choice"
msgstr "有多种选择，无法输出唯一的"

#: src/id.c:208
msgid "cannot print only names or real IDs in default format"
msgstr "以默认格式无法只显示名称或只显示真实ID。"

#: src/id.c:212
msgid "option --zero not permitted in default format"
msgstr ""

#: src/id.c:228
msgid "can't get process context"
msgstr "不能得到进程环境"

#: src/id.c:268
msgid "cannot get effective UID"
msgstr ""

#: src/id.c:357
#, c-format
msgid "cannot find name for user ID %s"
msgstr ""

#: src/id.c:375
#, c-format
msgid "uid=%s"
msgstr ""

#: src/id.c:380
#, c-format
msgid " gid=%s"
msgstr ""

#: src/id.c:387
#, c-format
msgid " euid=%s"
msgstr ""

#: src/id.c:395
#, c-format
msgid " egid=%s"
msgstr ""

#: src/id.c:423
msgid " groups="
msgstr " 组="

#: src/id.c:439
#, c-format
msgid " context=%s"
msgstr " 环境=%s"

#: src/install.c:378
#, c-format
msgid "warning: %s: failed to change context to %s"
msgstr "警告：%s：切换到%s 用户环境失败"

#: src/install.c:420
#, c-format
msgid "creating directory %s"
msgstr "正在创建目录%s"

#: src/install.c:432 src/mkdir.c:128 src/mkdir.c:161
#, c-format
msgid "failed to set default creation context for %s"
msgstr ""

#: src/install.c:462 src/mkdir.c:181
#, c-format
msgid "failed to restore context for %s"
msgstr ""

#: src/install.c:510
#, c-format
msgid "cannot change ownership of %s"
msgstr "无法更改%s 的所有权"

#: src/install.c:534
#, c-format
msgid "cannot set timestamps for %s"
msgstr ""

#: src/install.c:556 src/split.c:522 src/timeout.c:506
#, c-format
msgid "fork system call failed"
msgstr "创建系统进程(fork)出错"

#: src/install.c:560
#, c-format
msgid "cannot run %s"
msgstr "无法运行%s"

#: src/install.c:563
#, c-format
msgid "waiting for strip"
msgstr "等待拆解"

#: src/install.c:565
#, c-format
msgid "strip process terminated abnormally"
msgstr "拆解过程非正常中止"

#: src/install.c:589
#, c-format
msgid "invalid user %s"
msgstr "无效的用户%s"

#: src/install.c:627
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
"  or:  %s [OPTION]... -d DIRECTORY...\n"
msgstr ""
"用法：%s [选项]... [-T] 源文件 目标文件\n"
"　或：%s [选项]... 源文件... 目录\n"
"　或：%s [选项]... -t 目录 源文件...\n"
"　或：%s [选项]... -d 目录...\n"

#: src/install.c:634
msgid ""
"\n"
"This install program copies files (often just compiled) into destination\n"
"locations you choose.  If you want to download and install a ready-to-use\n"
"package on a GNU/Linux system, you should instead be using a package "
"manager\n"
"like yum(1) or apt-get(1).\n"
"\n"
"In the first three forms, copy SOURCE to DEST or multiple SOURCE(s) to\n"
"the existing DIRECTORY, while setting permission modes and owner/group.\n"
"In the 4th form, create all components of the given DIRECTORY(ies).\n"
msgstr ""

#: src/install.c:648
msgid ""
"      --backup[=CONTROL]  make a backup of each existing destination file\n"
"  -b                  like --backup but does not accept an argument\n"
"  -c                  (ignored)\n"
"  -C, --compare       compare each pair of source and destination files, "
"and\n"
"                        in some cases, do not modify the destination at all\n"
"  -d, --directory     treat all arguments as directory names; create all\n"
"                        components of the specified directories\n"
msgstr ""
"      --backup[=CONTROL]\t为每个已存在的文件创建备份\n"
"  -b\t\t\t类似--backup 但不接受参数\n"
"  -c\t\t\t(忽略)\n"
"  -C, --compare\t\t比较每组源文件和目标文件，在一些情况下不修改目标文件\n"
"  -d, --directory\t将所有参数视为目录名称；为指定的目录创建所有组件\n"

#: src/install.c:657
msgid ""
"  -D                  create all leading components of DEST except the "
"last,\n"
"                        or all components of --target-directory,\n"
"                        then copy SOURCE to DEST\n"
"  -g, --group=GROUP   set group ownership, instead of process' current "
"group\n"
"  -m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-xr-"
"x\n"
"  -o, --owner=OWNER   set ownership (super-user only)\n"
msgstr ""

#: src/install.c:665
msgid ""
"  -p, --preserve-timestamps   apply access/modification times of SOURCE "
"files\n"
"                        to corresponding destination files\n"
"  -s, --strip         strip symbol tables\n"
"      --strip-program=PROGRAM  program used to strip binaries\n"
"  -S, --suffix=SUFFIX  override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory  treat DEST as a normal file\n"
"  -v, --verbose       print the name of each directory as it is created\n"
msgstr ""
"  -p, --preserve-timestamps\t修改源文件的访问/修改时间以与目标文件保持一致\n"
"  -s, --strip\t\t\t拆解符号表\n"
"      --strip-program=程序\t指定拆解二进制文件的程序\n"
"  -S, --suffix=后缀\t\t覆盖常用备份文件后缀\n"
"  -t, --target-directory=目录\t将源文件所有参数复制到指定目录\n"
"  -T, --no-target-directory\t将目标文件视为普通文件\n"
"  -v, --verbose\t\t\t创建目录时显示其名称\n"

#: src/install.c:675
msgid ""
"      --preserve-context  preserve SELinux security context\n"
"  -Z                      set SELinux security context of destination\n"
"                            file and each created directory to default type\n"
"      --context[=CTX]     like -Z, or if CTX is specified then set the\n"
"                            SELinux or SMACK security context to CTX\n"
msgstr ""

#: src/install.c:711 src/unlink.c:92
#, c-format
msgid "cannot unlink %s"
msgstr "无法清除%s 的链接"

#: src/install.c:892
#, c-format
msgid ""
"WARNING: ignoring --preserve-context; this kernel is not SELinux-enabled"
msgstr "警告：忽略 --preserve-context 参数；当前运行的内核没有启用 SELinux 支持"

#: src/install.c:932
msgid "the strip option may not be used when installing a directory"
msgstr "安装目录时不能用strip 选项"

#: src/install.c:935
msgid "target directory not allowed when installing a directory"
msgstr "安装目录时不能用目标目录选项"

#: src/install.c:1002 src/mkdir.c:284 src/stdbuf.c:351
#, c-format
msgid "invalid mode %s"
msgstr "无效模式%s"

#: src/install.c:1009
#, c-format
msgid ""
"WARNING: ignoring --strip-program option as -s option was not specified"
msgstr "警告：忽略 --strip-program 选项，因为 -s 选项没有指明"

#: src/install.c:1014
#, c-format
msgid ""
"options --compare (-C) and --preserve-timestamps are mutually exclusive"
msgstr "选项--compare (-C) 和--preserve-timestamps 是互斥的"

#: src/install.c:1021
#, c-format
msgid "options --compare (-C) and --strip are mutually exclusive"
msgstr "选项--compare (-C) 和--strip 是互斥的"

#: src/install.c:1027
#, c-format
msgid ""
"the --compare (-C) option is ignored when you specify a mode with non-"
"permission bits"
msgstr "当您使用不允许的比特数指定模式是--compare (-C) 选项被忽略"

#. This is a proper name. See the gettext manual, section Names.
#: src/join.c:41 src/sort.c:66
msgid "Mike Haertel"
msgstr "Mike Haertel"

#: src/join.c:196
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited by blanks.\n"
msgstr ""

#: src/join.c:205
msgid ""
"\n"
"  -a FILENUM        also print unpairable lines from file FILENUM, where\n"
"                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
msgstr ""

#: src/join.c:211
msgid ""
"  -i, --ignore-case  ignore differences in case when comparing fields\n"
"  -j FIELD          equivalent to '-1 FIELD -2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
msgstr ""

#: src/join.c:217
msgid ""
"  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
"  --header          treat the first line in each file as field headers,\n"
"                      print them without trying to pair them\n"
msgstr ""
"  -v 文件编号        \t类似 -a 文件编号，但禁止组合输出行\n"
"  -1 域          \t在文件1 的此域组合\n"
"  -2 域          \t在文件2 的此域组合\n"
"  --check-order     \t检查输入行是否正确排序，即使所有输入行均是成对的\n"
"  --nocheck-order   \t不检查输入是否正确排序\n"
"  --header          \t将首行视作域的头部，直接输出而不对其进行匹配\n"

#: src/join.c:227 src/shuf.c:83 src/sort.c:512 src/uniq.c:206
msgid "  -z, --zero-terminated     line delimiter is NUL, not newline\n"
msgstr ""

#: src/join.c:232
msgid ""
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n"
"line of each file determines the number of fields output for each line.\n"
"\n"
"Important: FILE1 and FILE2 must be sorted on the join fields.\n"
"E.g., use \"sort -k 1b,1\" if 'join' has no options,\n"
"or use \"join -t ''\" if 'sort' has no options.\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
"If the input is not sorted and some lines cannot be joined, a\n"
"warning message will be given.\n"
msgstr ""

#: src/join.c:417
#, c-format
msgid "%s:%<PRIuMAX>: is not sorted: %.*s"
msgstr ""

#: src/join.c:849 src/join.c:1047
#, c-format
msgid "invalid field number: %s"
msgstr "无效的区块编号%s"

#: src/join.c:870 src/join.c:879
#, c-format
msgid "invalid field specifier: %s"
msgstr "无效的区块定义符：%s"

#: src/join.c:886
#, c-format
msgid "invalid file number in field spec: %s"
msgstr "在区块定义中出现无效的文件编号：%s"

#: src/join.c:930
#, c-format
msgid "incompatible join fields %lu, %lu"
msgstr "不兼容的连接区块%lu，%lu"

#: src/join.c:1058
msgid "conflicting empty-field replacement strings"
msgstr "有冲突的空区块替换字符串"

#: src/join.c:1110 src/sort.c:4534
#, c-format
msgid "multi-character tab %s"
msgstr "多字符标签%s"

#: src/join.c:1114 src/sort.c:4539
msgid "incompatible tabs"
msgstr "不兼容的标签"

#: src/join.c:1187
msgid "both files cannot be standard input"
msgstr "不能从标准输入同时读取两个文件"

#: src/kill.c:77
#, c-format
msgid ""
"Usage: %s [-s SIGNAL | -SIGNAL] PID...\n"
"  or:  %s -l [SIGNAL]...\n"
"  or:  %s -t [SIGNAL]...\n"
msgstr ""
"用法：%s [-s 信号 | -信号] 进程号...\n"
"　或：%s -l [信号]...\n"
"　或：%s -t [信号]...\n"

#: src/kill.c:83
msgid "Send signals to processes, or list signals.\n"
msgstr ""

#: src/kill.c:89
msgid ""
"  -s, --signal=SIGNAL, -SIGNAL\n"
"                   specify the name or number of the signal to be sent\n"
"  -l, --list       list signal names, or convert signal names to/from "
"numbers\n"
"  -t, --table      print a table of signal information\n"
msgstr ""
"  -s, --signal=信号，-信号\n"
"                   \t指定要发送的信号名或信号代码。\n"
"  -l, --list    \t列出可用的信号名称，同时提供信号名与信号代码的对照\n"
"  -t, --table    \t显示一个有关信号具体信息的表格。\n"

#: src/kill.c:97
msgid ""
"\n"
"SIGNAL may be a signal name like 'HUP', or a signal number like '1',\n"
"or the exit status of a process terminated by a signal.\n"
"PID is an integer; if negative it identifies a process group.\n"
msgstr ""

#: src/kill.c:206
#, c-format
msgid "%s: invalid process id"
msgstr "%s：无效的进程号"

#: src/kill.c:260
#, c-format
msgid "invalid option -- %c"
msgstr "无效的选项 -- %c"

#: src/kill.c:269
#, c-format
msgid "%s: multiple signals specified"
msgstr "%s：同时指定了多个信号"

#: src/kill.c:284
#, c-format
msgid "multiple -l or -t options specified"
msgstr "同时指定了多个-l 或-t 选项"

#: src/kill.c:301
#, c-format
msgid "cannot combine signal with -l or -t"
msgstr "无法将-l 或-t 选项结合使用"

#: src/kill.c:307
#, c-format
msgid "no process ID specified"
msgstr "未指定进程号"

#: src/libstdbuf.c:112
#, c-format
msgid "failed to allocate a %<PRIuMAX> byte stdio buffer\n"
msgstr "分配 %<PRIuMAX> 字节标准输入输出(stdio)缓冲区失败\n"

#: src/libstdbuf.c:119
#, c-format
msgid "invalid buffering mode %s for %s\n"
msgstr "%2$s 的缓冲模式%1$s 无效\n"

#: src/libstdbuf.c:127
#, c-format
msgid "could not set buffering of %s to mode %s\n"
msgstr "无法将%2$s 的缓冲模式设置为%1$s\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/link.c:37 src/unlink.c:37 src/who.c:52
msgid "Michael Stone"
msgstr "Michael Ston"

#: src/link.c:51
#, c-format
msgid ""
"Usage: %s FILE1 FILE2\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 文件1 文件2\n"
"　或：%s 选项\n"

#: src/link.c:54
msgid ""
"Call the link function to create a link named FILE2 to an existing FILE1.\n"
"\n"
msgstr ""
"调用 link 函数创建从既存的文件1 到文件2 的链接。\n"
"\n"

#: src/link.c:96
#, c-format
msgid "cannot create link %s to %s"
msgstr "无法创建指向%2$s 的链接%1$s"

#: src/ln.c:207
#, c-format
msgid "%s: hard link not allowed for directory"
msgstr "%s: 不允许将硬链接指向目录"

#: src/ln.c:272
#, c-format
msgid "%s: cannot overwrite directory"
msgstr "%s：无法覆盖目录"

#: src/ln.c:277
#, c-format
msgid "%s: replace %s? "
msgstr "%s：是否替换%s？ "

#: src/ln.c:349
#, c-format
msgid "failed to create symbolic link %s"
msgstr "无法创建符号链接%s"

#: src/ln.c:350
#, c-format
msgid "failed to create symbolic link %s -> %s"
msgstr "无法创建符号链接%s -> %s"

#: src/ln.c:352
#, c-format
msgid "failed to create hard link to %.0s%s"
msgstr "无法创建硬链接%.0s%s"

#: src/ln.c:355
#, c-format
msgid "failed to create hard link %s"
msgstr "无法创建硬链接%s"

#: src/ln.c:356
#, c-format
msgid "failed to create hard link %s => %s"
msgstr "无法创建硬链接%s => %s"

#: src/ln.c:378
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] TARGET LINK_NAME\n"
"  or:  %s [OPTION]... TARGET\n"
"  or:  %s [OPTION]... TARGET... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY TARGET...\n"
msgstr ""

#: src/ln.c:385
msgid ""
"In the 1st form, create a link to TARGET with the name LINK_NAME.\n"
"In the 2nd form, create a link to TARGET in the current directory.\n"
"In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.\n"
"Create hard links by default, symbolic links with --symbolic.\n"
"By default, each destination (name of new link) should not already exist.\n"
"When creating hard links, each TARGET must exist.  Symbolic links\n"
"can hold arbitrary text; if later resolved, a relative link is\n"
"interpreted in relation to its parent directory.\n"
msgstr ""

#: src/ln.c:398
msgid ""
"      --backup[=CONTROL]      make a backup of each existing destination "
"file\n"
"  -b                          like --backup but does not accept an argument\n"
"  -d, -F, --directory         allow the superuser to attempt to hard link\n"
"                                directories (note: will probably fail due "
"to\n"
"                                system restrictions, even for the "
"superuser)\n"
"  -f, --force                 remove existing destination files\n"
msgstr ""
"      --backup[=CONTROL]\t为每个已存在的目标文件创建备份文件\n"
"  -b\t\t\t\t类似--backup，但不接受任何参数\n"
"  -d, -F, --directory\t\t创建指向目录的硬链接(只适用于超级用户)\n"
"  -f, --force\t\t\t强行删除任何已存在的目标文件\n"

#: src/ln.c:406
msgid ""
"  -i, --interactive           prompt whether to remove destinations\n"
"  -L, --logical               dereference TARGETs that are symbolic links\n"
"  -n, --no-dereference        treat LINK_NAME as a normal file if\n"
"                                it is a symbolic link to a directory\n"
"  -P, --physical              make hard links directly to symbolic links\n"
"  -r, --relative              create symbolic links relative to link "
"location\n"
"  -s, --symbolic              make symbolic links instead of hard links\n"
msgstr ""

#: src/ln.c:415
msgid ""
"  -S, --suffix=SUFFIX         override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  specify the DIRECTORY in which to "
"create\n"
"                                the links\n"
"  -T, --no-target-directory   treat LINK_NAME as a normal file always\n"
"  -v, --verbose               print name of each linked file\n"
msgstr ""

#: src/ln.c:425
#, c-format
msgid ""
"\n"
"Using -s ignores -L and -P.  Otherwise, the last option specified controls\n"
"behavior when a TARGET is a symbolic link, defaulting to %s.\n"
msgstr ""

#: src/ln.c:542
msgid "cannot combine --target-directory and --no-target-directory"
msgstr "无法同时使用 --target-directory 和 --no-target-directory"

#: src/ln.c:574
msgid "cannot do --relative without --symbolic"
msgstr ""

#. This is a proper name. See the gettext manual, section Names.
#: src/logname.c:31
msgid "FIXME: unknown"
msgstr "FIXME：未知"

#: src/logname.c:45
#, c-format
msgid "Usage: %s [OPTION]\n"
msgstr "用法：%s [选项]\n"

#: src/logname.c:46
msgid ""
"Print the name of the current user.\n"
"\n"
msgstr ""
"显示当前用户的名称。\n"
"\n"

#: src/logname.c:85
msgid "no login name"
msgstr "无登录名"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:770
msgid "%b %e  %Y"
msgstr "%b %e %Y"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:783
msgid "%b %e %H:%M"
msgstr "%b %e %H:%M"

#: src/ls.c:1751
#, c-format
msgid "ignoring invalid width in environment variable COLUMNS: %s"
msgstr "忽略无效的环境变量 COLUMNS 所示的宽度值：%s"

#: src/ls.c:1779
#, c-format
msgid "ignoring invalid tab size in environment variable TABSIZE: %s"
msgstr "忽略无效的环境变量 TABSIZE 所示的制表符尺寸值：%s"

#: src/ls.c:1898
msgid "invalid line width"
msgstr ""

#: src/ls.c:1966
msgid "invalid tab size"
msgstr ""

#: src/ls.c:2199
#, c-format
msgid "invalid time style format %s"
msgstr "无效的日期时间格式%s"

#: src/ls.c:2223
msgid "Valid arguments are:\n"
msgstr "有效的参数为：\n"

#: src/ls.c:2227
msgid "  - +FORMAT (e.g., +%H:%M) for a 'date'-style format\n"
msgstr ""

#: src/ls.c:2601
#, c-format
msgid "unrecognized prefix: %s"
msgstr "无法识别的前缀：%s"

#: src/ls.c:2631
#, c-format
msgid "unparsable value for LS_COLORS environment variable"
msgstr "LS_COLORS 环境变量中存在无法解些的值"

#: src/ls.c:2661 src/stat.c:1038
#, c-format
msgid "ignoring invalid value of environment variable QUOTING_STYLE: %s"
msgstr "忽略无效的环境变量QUOTING_STYLE 的键值：%s"

#: src/ls.c:2727 src/pwd.c:164
#, c-format
msgid "cannot open directory %s"
msgstr "无法打开目录%s"

#: src/ls.c:2742
#, c-format
msgid "cannot determine device and inode of %s"
msgstr "无法决定%s 所在的设备及inode"

#: src/ls.c:2751
#, c-format
msgid "%s: not listing already-listed directory"
msgstr "%s：不会再列出已经列出的目录"

#: src/ls.c:2776 src/ls.c:3195 src/selinux.c:127 src/selinux.c:300
#, c-format
msgid "error canonicalizing %s"
msgstr ""

#: src/ls.c:2838 src/pwd.c:232
#, c-format
msgid "reading directory %s"
msgstr "正在读取目录%s"

#: src/ls.c:2853
#, c-format
msgid "closing directory %s"
msgstr "关闭目录%s"

#: src/ls.c:3572
#, c-format
msgid "cannot compare file names %s and %s"
msgstr "无法比较文件名%s 和 %s"

#: src/ls.c:5132
msgid ""
"List information about the FILEs (the current directory by default).\n"
"Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n"
msgstr ""

#: src/ls.c:5139
msgid ""
"  -a, --all                  do not ignore entries starting with .\n"
"  -A, --almost-all           do not list implied . and ..\n"
"      --author               with -l, print the author of each file\n"
"  -b, --escape               print C-style escapes for nongraphic "
"characters\n"
msgstr ""
"  -a, --all\t\t\t不隐藏任何以. 开始的项目\n"
"  -A, --almost-all\t\t列出除. 及.. 以外的任何项目\n"
"      --author\t\t\t与-l 同时使用时列出每个文件的作者\n"
"  -b, --escape\t\t\t以八进制溢出序列表示不可打印的字符\n"

#: src/ls.c:5145
msgid ""
"      --block-size=SIZE      with -l, scale sizes by SIZE when printing "
"them;\n"
"                               e.g., '--block-size=M'; see SIZE format "
"below\n"
msgstr ""

#: src/ls.c:5149
msgid ""
"  -B, --ignore-backups       do not list implied entries ending with ~\n"
"  -c                         with -lt: sort by, and show, ctime (time of "
"last\n"
"                               modification of file status information);\n"
"                               with -l: show ctime and sort by name;\n"
"                               otherwise: sort by ctime, newest first\n"
msgstr ""

#: src/ls.c:5156
msgid ""
"  -C                         list entries by columns\n"
"      --color[=WHEN]         colorize the output; WHEN can be 'always' "
"(default\n"
"                               if omitted), 'auto', or 'never'; more info "
"below\n"
"  -d, --directory            list directories themselves, not their "
"contents\n"
"  -D, --dired                generate output designed for Emacs' dired mode\n"
msgstr ""

#: src/ls.c:5165
msgid ""
"  -f                         do not sort, enable -aU, disable -ls --color\n"
"  -F, --classify             append indicator (one of */=>@|) to entries\n"
"      --file-type            likewise, except do not append '*'\n"
"      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
"                               single-column -1, verbose -l, vertical -C\n"
"      --full-time            like -l --time-style=full-iso\n"
msgstr ""

#: src/ls.c:5173
msgid "  -g                         like -l, but do not list owner\n"
msgstr "  -g\t\t\t\t类似-l，但不列出所有者\n"

#: src/ls.c:5176
msgid ""
"      --group-directories-first\n"
"                             group directories before files;\n"
"                               can be augmented with a --sort option, but "
"any\n"
"                               use of --sort=none (-U) disables grouping\n"
msgstr ""

#: src/ls.c:5182
msgid ""
"  -G, --no-group             in a long listing, don't print group names\n"
msgstr ""

#: src/ls.c:5185
msgid ""
"  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G "
"etc.\n"
"      --si                   likewise, but use powers of 1000 not 1024\n"
msgstr ""

#: src/ls.c:5189
msgid ""
"  -H, --dereference-command-line\n"
"                             follow symbolic links listed on the command "
"line\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             follow each command line symbolic link\n"
"                               that points to a directory\n"
"      --hide=PATTERN         do not list implied entries matching shell "
"PATTERN\n"
"                               (overridden by -a or -A)\n"
msgstr ""

#: src/ls.c:5199
msgid ""
"      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'\n"
"                               (default if omitted), 'auto', or 'never'\n"
msgstr ""

#: src/ls.c:5203
msgid ""
"      --indicator-style=WORD  append indicator with style WORD to entry "
"names:\n"
"                               none (default), slash (-p),\n"
"                               file-type (--file-type), classify (-F)\n"
"  -i, --inode                print the index number of each file\n"
"  -I, --ignore=PATTERN       do not list implied entries matching shell "
"PATTERN\n"
msgstr ""

#: src/ls.c:5212
msgid ""
"  -k, --kibibytes            default to 1024-byte blocks for disk usage;\n"
"                               used only with -s and per directory totals\n"
msgstr ""

#: src/ls.c:5216
msgid ""
"  -l                         use a long listing format\n"
"  -L, --dereference          when showing file information for a symbolic\n"
"                               link, show information for the file the link\n"
"                               references rather than for the link itself\n"
"  -m                         fill width with a comma separated list of "
"entries\n"
msgstr ""
"  -l\t\t\t\t使用较长格式列出信息\n"
"  -L, --dereference\t\t当显示符号链接的文件信息时，显示符号链接所指示\n"
"\t\t\t\t的对象而并非符号链接本身的信息\n"
"  -m\t\t\t\t所有项目以逗号分隔，并填满整行行宽\n"

#: src/ls.c:5224
msgid ""
"  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
"  -N, --literal              print entry names without quoting\n"
"  -o                         like -l, but do not list group information\n"
"  -p, --indicator-style=slash\n"
"                             append / indicator to directories\n"
msgstr ""

#: src/ls.c:5231
msgid ""
"  -q, --hide-control-chars   print ? instead of nongraphic characters\n"
"      --show-control-chars   show nongraphic characters as-is (the default,\n"
"                               unless program is 'ls' and output is a "
"terminal)\n"
"  -Q, --quote-name           enclose entry names in double quotes\n"
"      --quoting-style=WORD   use quoting style WORD for entry names:\n"
"                               literal, locale, shell, shell-always,\n"
"                               shell-escape, shell-escape-always, c, escape\n"
"                               (overrides QUOTING_STYLE environment "
"variable)\n"
msgstr ""

#: src/ls.c:5242
msgid ""
"  -r, --reverse              reverse order while sorting\n"
"  -R, --recursive            list subdirectories recursively\n"
"  -s, --size                 print the allocated size of each file, in "
"blocks\n"
msgstr ""
"  -r, --reverse\t\t\t逆序排列\n"
"  -R, --recursive\t\t递归显示子目录\n"
"  -s, --size\t\t\t以块数形式显示每个文件分配的尺寸\n"

#: src/ls.c:5247
msgid ""
"  -S                         sort by file size, largest first\n"
"      --sort=WORD            sort by WORD instead of name: none (-U), size (-"
"S),\n"
"                               time (-t), version (-v), extension (-X)\n"
"      --time=WORD            with -l, show time as WORD instead of default\n"
"                               modification time: atime or access or use (-"
"u);\n"
"                               ctime or status (-c); also use specified "
"time\n"
"                               as sort key if --sort=time (newest first)\n"
msgstr ""

#: src/ls.c:5258
msgid ""
"      --time-style=TIME_STYLE  time/date format with -l; see TIME_STYLE "
"below\n"
msgstr ""

#: src/ls.c:5261
msgid ""
"  -t                         sort by modification time, newest first\n"
"  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n"
msgstr ""

#: src/ls.c:5265
msgid ""
"  -u                         with -lt: sort by, and show, access time;\n"
"                               with -l: show access time and sort by name;\n"
"                               otherwise: sort by access time, newest first\n"
"  -U                         do not sort; list entries in directory order\n"
"  -v                         natural sort of (version) numbers within text\n"
msgstr ""

#: src/ls.c:5272
msgid ""
"  -w, --width=COLS           set output width to COLS.  0 means no limit\n"
"  -x                         list entries by lines instead of by columns\n"
"  -X                         sort alphabetically by entry extension\n"
"  -Z, --context              print any security context of each file\n"
"  -1                         list one file per line.  Avoid '\\n' with -q or "
"-b\n"
msgstr ""

#: src/ls.c:5283
msgid ""
"\n"
"The TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.\n"
"FORMAT is interpreted like in date(1).  If FORMAT is "
"FORMAT1<newline>FORMAT2,\n"
"then FORMAT1 applies to non-recent files and FORMAT2 to recent files.\n"
"TIME_STYLE prefixed with 'posix-' takes effect only outside the POSIX "
"locale.\n"
"Also the TIME_STYLE environment variable sets the default style to use.\n"
msgstr ""

#: src/ls.c:5291
msgid ""
"\n"
"Using color to distinguish file types is disabled both by default and\n"
"with --color=never.  With --color=auto, ls emits color codes only when\n"
"standard output is connected to a terminal.  The LS_COLORS environment\n"
"variable can change the settings.  Use the dircolors command to set it.\n"
msgstr ""
"\n"
"使用色彩来区分文件类型的功能已被禁用，默认设置和 --color=never 同时禁用了它。\n"
"使用 --color=auto 选项，ls 只在标准输出被连至终端时才生成颜色代码。\n"
"LS_COLORS 环境变量可改变此设置，可使用 dircolors 命令来设置。\n"

#: src/ls.c:5298
msgid ""
"\n"
"Exit status:\n"
" 0  if OK,\n"
" 1  if minor problems (e.g., cannot access subdirectory),\n"
" 2  if serious trouble (e.g., cannot access command-line argument).\n"
msgstr ""
"\n"
"退出状态：\n"
" 0  正常\n"
" 1  一般问题 (例如：无法访问子文件夹)\n"
" 2  严重问题 (例如：无法使用命令行参数)\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:108
msgid "Samuel Neves"
msgstr ""

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:111 src/seq.c:43
msgid "Ulrich Drepper"
msgstr "Ulrich Drepper"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:112
msgid "Scott Miller"
msgstr "Scott Miller"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:113
msgid "David Madore"
msgstr "David Madore"

#: src/md5sum.c:229
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"Print or check %s (%d-bit) checksums.\n"
msgstr ""
"用法：%s [选项]... [文件]...\n"
"显示或检查 %s（%d位）校验和。\n"

#: src/md5sum.c:239
msgid ""
"\n"
"  -b, --binary         read in binary mode (default unless reading tty "
"stdin)\n"
msgstr ""
"\n"
"  -b, --binary         以二进制模式读取（除非从 tty 标准输入读取，否则为默认）\n"

#: src/md5sum.c:244
msgid ""
"\n"
"  -b, --binary         read in binary mode\n"
msgstr ""
"\n"
"  -b, --binary         以二进制模式读取\n"

#: src/md5sum.c:249
#, c-format
msgid "  -c, --check          read %s sums from the FILEs and check them\n"
msgstr "  -c, --check\t\t从文件中读取%s 的校验值并予以检查\n"

#: src/md5sum.c:253
msgid ""
"  -l, --length         digest length in bits; must not exceed the maximum "
"for\n"
"                       the blake2 algorithm and must be a multiple of 8\n"
msgstr ""

#: src/md5sum.c:258
msgid "      --tag            create a BSD-style checksum\n"
msgstr "      --tag            创建一个 BSD 风格的校验和\n"

#: src/md5sum.c:262
msgid ""
"  -t, --text           read in text mode (default if reading tty stdin)\n"
msgstr "  -t, --text\t\t以纯文本模式读取(从tty 标准输入读取时为默认)\n"

#: src/md5sum.c:266
msgid "  -t, --text           read in text mode (default)\n"
msgstr "  -t, --text\t\t以纯文本模式读取(默认)\n"

#: src/md5sum.c:269
msgid ""
"  -z, --zero           end each output line with NUL, not newline,\n"
"                       and disable file name escaping\n"
msgstr ""

#: src/md5sum.c:273
msgid ""
"\n"
"The following five options are useful only when verifying checksums:\n"
"      --ignore-missing  don't fail or report status for missing files\n"
"      --quiet          don't print OK for each successfully verified file\n"
"      --status         don't output anything, status code shows success\n"
"      --strict         exit non-zero for improperly formatted checksum "
"lines\n"
"  -w, --warn           warn about improperly formatted checksum lines\n"
"\n"
msgstr ""

#: src/md5sum.c:285
#, c-format
msgid ""
"\n"
"The sums are computed as described in %s.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print a\n"
"line with checksum, a space, a character indicating input mode ('*' for "
"binary,\n"
"' ' for text or where binary is insignificant), and name for each FILE.\n"
msgstr ""

#: src/md5sum.c:697
#, c-format
msgid "%s: too many checksum lines"
msgstr "%s：校验和的行数过多"

#: src/md5sum.c:720
#, c-format
msgid "%s: %<PRIuMAX>: improperly formatted %s checksum line"
msgstr "%s：%<PRIuMAX>：%s 的校验和行目格式不适当"

#: src/md5sum.c:752
msgid "FAILED open or read"
msgstr ""

#: src/md5sum.c:790
msgid "FAILED"
msgstr "失败"

#: src/md5sum.c:792
msgid "OK"
msgstr "成功"

#: src/md5sum.c:816
#, c-format
msgid "%s: no properly formatted %s checksum lines found"
msgstr "%s：找不到格式适用的%s 校验和"

#: src/md5sum.c:826
#, c-format
msgid "WARNING: %<PRIuMAX> line is improperly formatted"
msgid_plural "WARNING: %<PRIuMAX> lines are improperly formatted"
msgstr[0] "警告：%<PRIuMAX> 行的格式不适当"

#: src/md5sum.c:834
#, c-format
msgid "WARNING: %<PRIuMAX> listed file could not be read"
msgid_plural "WARNING: %<PRIuMAX> listed files could not be read"
msgstr[0] "警告：%<PRIuMAX> 个列出的文件无法读取"

#: src/md5sum.c:842
#, c-format
msgid "WARNING: %<PRIuMAX> computed checksum did NOT match"
msgid_plural "WARNING: %<PRIuMAX> computed checksums did NOT match"
msgstr[0] "警告：%<PRIuMAX> 个校验和不匹配"

#: src/md5sum.c:848
#, c-format
msgid "%s: no file was verified"
msgstr ""

#: src/md5sum.c:898
msgid "invalid length"
msgstr ""

#: src/md5sum.c:902 src/md5sum.c:954
#, c-format
msgid "invalid length: %s"
msgstr ""

#: src/md5sum.c:903
msgid "length is not a multiple of 8"
msgstr ""

#: src/md5sum.c:956
#, c-format
msgid "maximum digest length for %s is %<PRIuMAX> bits"
msgstr ""

#: src/md5sum.c:974
#, c-format
msgid "--tag does not support --text mode"
msgstr "--tag 不支持--text 模式"

#: src/md5sum.c:980
#, c-format
msgid "the --zero option is not supported when verifying checksums"
msgstr ""

#: src/md5sum.c:987
#, c-format
msgid "the --tag option is meaningless when verifying checksums"
msgstr "在校验时--tag 选项无意义"

#: src/md5sum.c:994
#, c-format
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr "在校验时--binary 和--text 选项无意义"

#: src/md5sum.c:1002
#, c-format
msgid ""
"the --ignore-missing option is meaningful only when verifying checksums"
msgstr ""

#: src/md5sum.c:1010
#, c-format
msgid "the --status option is meaningful only when verifying checksums"
msgstr "仅在校验时--status 选项有意义"

#: src/md5sum.c:1017
#, c-format
msgid "the --warn option is meaningful only when verifying checksums"
msgstr "仅在校验时--warn 选项才有意义"

#: src/md5sum.c:1024
#, c-format
msgid "the --quiet option is meaningful only when verifying checksums"
msgstr "只有在校验时--quiet 选项才有意义"

#: src/md5sum.c:1031
#, c-format
msgid "the --strict option is meaningful only when verifying checksums"
msgstr ""

#: src/mkdir.c:59 src/rmdir.c:163
#, c-format
msgid "Usage: %s [OPTION]... DIRECTORY...\n"
msgstr "用法：%s [选项]... 目录...\n"

#: src/mkdir.c:60
msgid "Create the DIRECTORY(ies), if they do not already exist.\n"
msgstr ""

#: src/mkdir.c:66
msgid ""
"  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask\n"
"  -p, --parents     no error if existing, make parent directories as needed\n"
"  -v, --verbose     print a message for each created directory\n"
msgstr ""

#: src/mkdir.c:71
msgid ""
"  -Z                   set SELinux security context of each created "
"directory\n"
"                         to the default type\n"
"      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n"
"                         or SMACK security context to CTX\n"
msgstr ""

#: src/mkdir.c:221
#, c-format
msgid "created directory %s"
msgstr "已创建目录 %s"

#: src/mkdir.c:239 src/mkfifo.c:117 src/mknod.c:134
#, c-format
msgid ""
"warning: ignoring --context; it requires an SELinux/SMACK-enabled kernel"
msgstr ""

#: src/mkfifo.c:54 src/pathchk.c:88
#, c-format
msgid "Usage: %s [OPTION]... NAME...\n"
msgstr "用法：%s [选项]... 名称...\n"

#: src/mkfifo.c:55
msgid "Create named pipes (FIFOs) with the given NAMEs.\n"
msgstr ""

#: src/mkfifo.c:61 src/mknod.c:63
msgid ""
"  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\n"
msgstr "  -m, --mode=模式   \t设置权限模式(类似chmod)，而不是rwxrwxrwx 减umask\n"

#: src/mkfifo.c:64 src/mknod.c:66
msgid ""
"  -Z                   set the SELinux security context to default type\n"
"      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n"
"                         or SMACK security context to CTX\n"
msgstr ""

#: src/mkfifo.c:154 src/mknod.c:151
msgid "invalid mode"
msgstr "无效的权限模式"

#: src/mkfifo.c:161 src/mknod.c:158
msgid "mode must specify only file permission bits"
msgstr "模式必须只指定文件许可位"

#: src/mkfifo.c:175 src/mknod.c:271
#, c-format
msgid "cannot set permissions of %s"
msgstr "无法设定 %s 的权限"

#: src/mknod.c:55
#, c-format
msgid "Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\n"
msgstr "用法：%s [选项]... 名称 类型 [主设备号 次设备号]\n"

#: src/mknod.c:57
msgid "Create the special file NAME of the given TYPE.\n"
msgstr ""

#: src/mknod.c:73
msgid ""
"\n"
"Both MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\n"
"must be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\n"
"it is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\n"
"otherwise, as decimal.  TYPE may be:\n"
msgstr ""
"\n"
"当类型为\"p\"时可不指定主设备号和次设备号，否则它们是必须指定的。\n"
"如果主设备号和次设备号以\"0x\"或\"0X\"开头，它们会被视作十六进制数来\n"
"解析；如果以\"0\"开头，则被视作八进制数；其余情况下被视作十进制数。\n"
"可用的类型包括：\n"

#: src/mknod.c:80
msgid ""
"\n"
"  b      create a block (buffered) special file\n"
"  c, u   create a character (unbuffered) special file\n"
"  p      create a FIFO\n"
msgstr ""
"\n"
"  b      创建(有缓冲的)区块特殊文件\n"
"  c, u   创建(没有缓冲的)字符特殊文件\n"
"  p      创建先进先出(FIFO)特殊文件\n"

#: src/mknod.c:176
msgid "Special files require major and minor device numbers."
msgstr "创建块设备文件时，必需指定主、次设备号。"

#: src/mknod.c:186
msgid "Fifos do not have major and minor device numbers."
msgstr "先进先出(FIFO)文件不需要指定主、次设备号。"

#: src/mknod.c:211
msgid "block special files not supported"
msgstr "不支持区块特殊文件"

#: src/mknod.c:220
msgid "character special files not supported"
msgstr "不支持字符特殊文件"

#: src/mknod.c:236
#, c-format
msgid "invalid major device number %s"
msgstr "无效的主设备号 %s"

#: src/mknod.c:241
#, c-format
msgid "invalid minor device number %s"
msgstr "无效的次设备号 %s"

#: src/mknod.c:246
#, c-format
msgid "invalid device %s %s"
msgstr "无效的设备文件%s %s"

#: src/mknod.c:266
#, c-format
msgid "invalid device type %s"
msgstr "无效的设备类型 %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/mktemp.c:37
msgid "Eric Blake"
msgstr "Eric Blake"

#: src/mktemp.c:67
#, c-format
msgid "Usage: %s [OPTION]... [TEMPLATE]\n"
msgstr "用法：%s [选项]... [TEMPLATE]\n"

#: src/mktemp.c:68
msgid ""
"Create a temporary file or directory, safely, and print its name.\n"
"TEMPLATE must contain at least 3 consecutive 'X's in last component.\n"
"If TEMPLATE is not specified, use tmp.XXXXXXXXXX, and --tmpdir is implied.\n"
msgstr ""

#: src/mktemp.c:73
msgid ""
"Files are created u+rw, and directories u+rwx, minus umask restrictions.\n"
msgstr ""

#: src/mktemp.c:77
msgid ""
"  -d, --directory     create a directory, not a file\n"
"  -u, --dry-run       do not create anything; merely print a name (unsafe)\n"
"  -q, --quiet         suppress diagnostics about file/dir-creation failure\n"
msgstr ""
"  -d, --directory     创建一个目录而非文件\n"
"  -u, --dry-run       不创建任何东西，仅打印出名字。(仅供测试)\n"
"  -q, --quiet         不显示任何有关文件或目录创建错误信息\n"

#: src/mktemp.c:82
msgid ""
"      --suffix=SUFF   append SUFF to TEMPLATE; SUFF must not contain a "
"slash.\n"
"                        This option is implied if TEMPLATE does not end in "
"X\n"
msgstr ""

#: src/mktemp.c:86
msgid ""
"  -p DIR, --tmpdir[=DIR]  interpret TEMPLATE relative to DIR; if DIR is not\n"
"                        specified, use $TMPDIR if set, else /tmp.  With\n"
"                        this option, TEMPLATE must not be an absolute name;\n"
"                        unlike with -t, TEMPLATE may contain slashes, but\n"
"                        mktemp creates only the final component\n"
msgstr ""

#: src/mktemp.c:93
msgid ""
"  -t                  interpret TEMPLATE as a single file name component,\n"
"                        relative to a directory: $TMPDIR, if set; else the\n"
"                        directory specified via -p; else /tmp [deprecated]\n"
msgstr ""

#: src/mktemp.c:211
#, c-format
msgid "too many templates"
msgstr "模板过多"

#: src/mktemp.c:231
#, c-format
msgid "with --suffix, template %s must end in X"
msgstr "使用 --suffix，模板 %s 必须以 X 结尾"

#: src/mktemp.c:256 src/split.c:1344
#, c-format
msgid "invalid suffix %s, contains directory separator"
msgstr "无效后缀 %s，含有目录分隔符"

#: src/mktemp.c:261
#, c-format
msgid "too few X's in template %s"
msgstr "模板%s 中X 太少"

#: src/mktemp.c:277
#, c-format
msgid "invalid template, %s, contains directory separator"
msgstr "无效模板，%s，包含目录分隔符"

#: src/mktemp.c:291
#, c-format
msgid "invalid template, %s; with --tmpdir, it may not be absolute"
msgstr "无效模板，%s；如果与--tmpdir 同时使用则不可以是绝对路径"

#: src/mktemp.c:312
#, c-format
msgid "failed to create directory via template %s"
msgstr "无法通过模板%s 创建目录"

#: src/mktemp.c:323
#, c-format
msgid "failed to create file via template %s"
msgstr "无法通过模板%s 创建文件"

#: src/mv.c:298
msgid "Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n"
msgstr ""

#: src/mv.c:304
msgid ""
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"  -f, --force                  do not prompt before overwriting\n"
"  -i, --interactive            prompt before overwrite\n"
"  -n, --no-clobber             do not overwrite an existing file\n"
"If you specify more than one of -i, -f, -n, only the final one takes "
"effect.\n"
msgstr ""
"      --backup[=CONTROL]       为每个已存在的目标文件创建备份\n"
"  -b                           类似--backup 但不接受参数\n"
"  -f, --force                  覆盖前不询问\n"
"  -i, --interactive            覆盖前询问\n"
"  -n, --no-clobber             不覆盖已存在文件\n"
"如果您指定了-i、-f、-n 中的多个，仅最后一个生效。\n"

#: src/mv.c:313
msgid ""
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
msgstr ""
"      --strip-trailing-slashes\t去掉每个源文件参数尾部的斜线\n"
"  -S, --suffix=SUFFIX\t\t替换常用的备份文件后缀\n"

#: src/mv.c:318
msgid ""
"  -t, --target-directory=DIRECTORY  move all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
"  -u, --update                 move only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -Z, --context                set SELinux security context of destination\n"
"                                 file to default type\n"
msgstr ""

#: src/nice.c:73
#, c-format
msgid "Usage: %s [OPTION] [COMMAND [ARG]...]\n"
msgstr "用法：%s [选项] [命令 [参数]...]\n"

#: src/nice.c:74
#, c-format
msgid ""
"Run COMMAND with an adjusted niceness, which affects process scheduling.\n"
"With no COMMAND, print the current niceness.  Niceness values range from\n"
"%d (most favorable to the process) to %d (least favorable to the process).\n"
msgstr ""

#: src/nice.c:83
msgid "  -n, --adjustment=N   add integer N to the niceness (default 10)\n"
msgstr ""

#: src/nice.c:173
#, c-format
msgid "invalid adjustment %s"
msgstr "无效的调整值%s"

#: src/nice.c:182
#, c-format
msgid "a command must be given with an adjustment"
msgstr "命令必须和调整值配合指定"

#: src/nice.c:189 src/nice.c:200
msgid "cannot get niceness"
msgstr "无法获取优先级"

#: src/nice.c:206
#, c-format
msgid "cannot set niceness"
msgstr "无法设置优先级"

#. This is a proper name. See the gettext manual, section Names.
#: src/nl.c:41
msgid "Scott Bartram"
msgstr "Scott Bartram"

#: src/nl.c:180
msgid "Write each FILE to standard output, with line numbers added.\n"
msgstr ""

#: src/nl.c:187
msgid ""
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for logical page delimiters\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
msgstr ""

#: src/nl.c:192
msgid ""
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --line-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers for each "
"section\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
msgstr ""

#: src/nl.c:200
msgid ""
"  -v, --starting-line-number=NUMBER  first line number for each section\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
msgstr ""

#: src/nl.c:206
msgid ""
"\n"
"Default options are: -bt -d'\\:' -fn -hn -i1 -l1 -n'rn' -s<TAB> -v1 -w6\n"
"\n"
"CC are two delimiter characters used to construct logical page delimiters;\n"
"a missing second character implies ':'.\n"
msgstr ""

#: src/nl.c:213
msgid ""
"\n"
"STYLE is one of:\n"
"\n"
"  a      number all lines\n"
"  t      number only nonempty lines\n"
"  n      number no lines\n"
"  pBRE   number only lines that contain a match for the basic regular\n"
"         expression, BRE\n"
msgstr ""

#: src/nl.c:223
msgid ""
"\n"
"FORMAT is one of:\n"
"\n"
"  ln     left justified, no leading zeros\n"
"  rn     right justified, no leading zeros\n"
"  rz     right justified, leading zeros\n"
"\n"
msgstr ""

#: src/nl.c:284
msgid "line number overflow"
msgstr "行号溢出"

#: src/nl.c:488
#, c-format
msgid "invalid header numbering style: %s"
msgstr "无效的页眉号样式：%s"

#: src/nl.c:496
#, c-format
msgid "invalid body numbering style: %s"
msgstr "无效的正文号样式：%s"

#: src/nl.c:504
#, c-format
msgid "invalid footer numbering style: %s"
msgstr "无效的页脚号样式：%s"

#: src/nl.c:511
msgid "invalid starting line number"
msgstr ""

#: src/nl.c:516
msgid "invalid line number increment"
msgstr ""

#: src/nl.c:523
msgid "invalid line number of blank lines"
msgstr ""

#: src/nl.c:530
msgid "invalid line number field width"
msgstr ""

#: src/nl.c:541
#, c-format
msgid "invalid line numbering format: %s"
msgstr "无效的编号格式：%s"

#: src/nohup.c:56
#, c-format
msgid ""
"Usage: %s COMMAND [ARG]...\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 命令 [参数]...\n"
"　或：%s 选项\n"

#: src/nohup.c:62
msgid ""
"Run COMMAND, ignoring hangup signals.\n"
"\n"
msgstr ""
"忽略挂起信号运行指定的命令。\n"
"\n"

#: src/nohup.c:68
#, c-format
msgid ""
"\n"
"If standard input is a terminal, redirect it from an unreadable file.\n"
"If standard output is a terminal, append output to 'nohup.out' if possible,\n"
"'$HOME/nohup.out' otherwise.\n"
"If standard error is a terminal, redirect it to standard output.\n"
"To save output to FILE, use '%s COMMAND > FILE'.\n"
msgstr ""

#: src/nohup.c:130
#, c-format
msgid "failed to render standard input unusable"
msgstr "标准输入不可用，无法重定向"

#: src/nohup.c:132
#, c-format
msgid "ignoring input"
msgstr "忽略输入"

#: src/nohup.c:176
#, c-format
msgid "ignoring input and appending output to %s"
msgstr "忽略输入并把输出追加到%s"

#: src/nohup.c:177
#, c-format
msgid "appending output to %s"
msgstr "把输出追加到%s"

#: src/nohup.c:195
#, c-format
msgid "ignoring input and redirecting stderr to stdout"
msgstr "忽略输入重定向错误到标准输出端"

#: src/nohup.c:196
#, c-format
msgid "redirecting stderr to stdout"
msgstr "重定向标准错误到标准输出"

#: src/nohup.c:200
#, c-format
msgid "failed to redirect standard error"
msgstr "重定向标准错误失败"

#. This is a proper name. See the gettext manual, section Names.
#: src/nproc.c:33 src/sync.c:34
msgid "Giuseppe Scrivano"
msgstr "Giuseppe Scrivano"

#: src/nproc.c:57 src/pwd.c:57 src/tty.c:65 src/uname.c:121 src/whoami.c:50
#, c-format
msgid "Usage: %s [OPTION]...\n"
msgstr "用法：%s [选项]...\n"

#: src/nproc.c:58
msgid ""
"Print the number of processing units available to the current process,\n"
"which may be less than the number of online processors\n"
"\n"
msgstr ""
"打印当前进程可用的处理器数，\n"
"此数目可能小于实际工作数\n"
"\n"

#: src/nproc.c:63
msgid ""
"      --all      print the number of installed processors\n"
"      --ignore=N  if possible, exclude N processing units\n"
msgstr ""

#: src/numfmt.c:694
#, c-format
msgid "value too large to be converted: %s"
msgstr ""

#: src/numfmt.c:698
#, c-format
msgid "invalid number: %s"
msgstr ""

#: src/numfmt.c:702
#, c-format
msgid "rejecting suffix in input: %s (consider using --from)"
msgstr ""

#: src/numfmt.c:706
#, c-format
msgid "invalid suffix in input: %s"
msgstr ""

#: src/numfmt.c:710
#, c-format
msgid "missing 'i' suffix in input: %s (e.g Ki/Mi/Gi)"
msgstr ""

#: src/numfmt.c:757 src/numfmt.c:809
#, c-format
msgid "failed to prepare value '%Lf' for printing"
msgstr ""

#: src/numfmt.c:858
#, c-format
msgid "invalid unit size: %s"
msgstr ""

#: src/numfmt.c:884
#, c-format
msgid "Usage: %s [OPTION]... [NUMBER]...\n"
msgstr ""

#: src/numfmt.c:887
msgid ""
"Reformat NUMBER(s), or the numbers from standard input if none are "
"specified.\n"
msgstr ""

#: src/numfmt.c:891
msgid "      --debug          print warnings about invalid input\n"
msgstr ""

#: src/numfmt.c:894
msgid ""
"  -d, --delimiter=X    use X instead of whitespace for field delimiter\n"
msgstr ""

#: src/numfmt.c:897
msgid ""
"      --field=FIELDS   replace the numbers in these input fields "
"(default=1)\n"
"                         see FIELDS below\n"
msgstr ""

#: src/numfmt.c:901
msgid ""
"      --format=FORMAT  use printf style floating-point FORMAT;\n"
"                         see FORMAT below for details\n"
msgstr ""

#: src/numfmt.c:905
msgid ""
"      --from=UNIT      auto-scale input numbers to UNITs; default is "
"'none';\n"
"                         see UNIT below\n"
msgstr ""

#: src/numfmt.c:909
msgid ""
"      --from-unit=N    specify the input unit size (instead of the default "
"1)\n"
msgstr ""

#: src/numfmt.c:912
msgid ""
"      --grouping       use locale-defined grouping of digits, e.g. "
"1,000,000\n"
"                         (which means it has no effect in the C/POSIX "
"locale)\n"
msgstr ""

#: src/numfmt.c:916
msgid ""
"      --header[=N]     print (without converting) the first N header lines;\n"
"                         N defaults to 1 if not specified\n"
msgstr ""

#: src/numfmt.c:920
msgid ""
"      --invalid=MODE   failure mode for invalid numbers: MODE can be:\n"
"                         abort (default), fail, warn, ignore\n"
msgstr ""

#: src/numfmt.c:924
msgid ""
"      --padding=N      pad the output to N characters; positive N will\n"
"                         right-align; negative N will left-align;\n"
"                         padding is ignored if the output is wider than N;\n"
"                         the default is to automatically pad if a "
"whitespace\n"
"                         is found\n"
msgstr ""

#: src/numfmt.c:931
msgid ""
"      --round=METHOD   use METHOD for rounding when scaling; METHOD can be:\n"
"                         up, down, from-zero (default), towards-zero, "
"nearest\n"
msgstr ""

#: src/numfmt.c:935
msgid ""
"      --suffix=SUFFIX  add SUFFIX to output numbers, and accept optional\n"
"                         SUFFIX in input numbers\n"
msgstr ""

#: src/numfmt.c:939
msgid ""
"      --to=UNIT        auto-scale output numbers to UNITs; see UNIT below\n"
msgstr ""

#: src/numfmt.c:942
msgid ""
"      --to-unit=N      the output unit size (instead of the default 1)\n"
msgstr ""

#: src/numfmt.c:951
msgid ""
"\n"
"UNIT options:\n"
msgstr ""

#: src/numfmt.c:954
msgid ""
"  none       no auto-scaling is done; suffixes will trigger an error\n"
msgstr ""

#: src/numfmt.c:957
msgid ""
"  auto       accept optional single/two letter suffix:\n"
"               1K = 1000,\n"
"               1Ki = 1024,\n"
"               1M = 1000000,\n"
"               1Mi = 1048576,\n"
msgstr ""

#: src/numfmt.c:963
msgid ""
"  si         accept optional single letter suffix:\n"
"               1K = 1000,\n"
"               1M = 1000000,\n"
"               ...\n"
msgstr ""

#: src/numfmt.c:968
msgid ""
"  iec        accept optional single letter suffix:\n"
"               1K = 1024,\n"
"               1M = 1048576,\n"
"               ...\n"
msgstr ""

#: src/numfmt.c:973
msgid ""
"  iec-i      accept optional two-letter suffix:\n"
"               1Ki = 1024,\n"
"               1Mi = 1048576,\n"
"               ...\n"
msgstr ""

#: src/numfmt.c:979
msgid ""
"\n"
"FIELDS supports cut(1) style field ranges:\n"
"  N    N'th field, counted from 1\n"
"  N-   from N'th field, to end of line\n"
"  N-M  from N'th to M'th field (inclusive)\n"
"  -M   from first to M'th field (inclusive)\n"
"  -    all fields\n"
"Multiple fields/ranges can be separated with commas\n"
msgstr ""

#: src/numfmt.c:989
#, c-format
msgid ""
"\n"
"FORMAT must be suitable for printing one floating-point argument '%f'.\n"
"Optional quote (%'f) will enable --grouping (if supported by current "
"locale).\n"
"Optional width value (%10f) will pad output. Optional zero (%010f) width\n"
"will zero pad the number. Optional negative values (%-10f) will left align.\n"
"Optional precision (%.1f) will override the input determined precision.\n"
msgstr ""

#: src/numfmt.c:997
#, c-format
msgid ""
"\n"
"Exit status is 0 if all input numbers were successfully converted.\n"
"By default, %s will stop at the first conversion error with exit status 2.\n"
"With --invalid='fail' a warning is printed for each conversion error\n"
"and the exit status is 2.  With --invalid='warn' each conversion error is\n"
"diagnosed, but the exit status is 0.  With --invalid='ignore' conversion\n"
"errors are not diagnosed and the exit status is 0.\n"
msgstr ""

#: src/numfmt.c:1006
#, c-format
msgid ""
"\n"
"Examples:\n"
"  $ %s --to=si 1000\n"
"            -> \"1.0K\"\n"
"  $ %s --to=iec 2048\n"
"           -> \"2.0K\"\n"
"  $ %s --to=iec-i 4096\n"
"           -> \"4.0Ki\"\n"
"  $ echo 1K | %s --from=si\n"
"           -> \"1000\"\n"
"  $ echo 1K | %s --from=iec\n"
"           -> \"1024\"\n"
"  $ df -B1 | %s --header --field 2-4 --to=si\n"
"  $ ls -l  | %s --header --field 5 --to=iec\n"
"  $ ls -lh | %s --header --field 5 --from=iec --padding=10\n"
"  $ ls -lh | %s --header --field 5 --from=iec --format %%10f\n"
msgstr ""

#: src/numfmt.c:1059 src/seq.c:240
#, c-format
msgid "format %s has no %% directive"
msgstr "格式%s 没有%% 指令"

#: src/numfmt.c:1086
#, c-format
msgid "invalid format %s (width overflow)"
msgstr ""

#: src/numfmt.c:1091
#, c-format
msgid "--format padding overriding --padding"
msgstr ""

#: src/numfmt.c:1110 src/seq.c:257
#, c-format
msgid "format %s ends in %%"
msgstr "格式%s 以%% 结束"

#: src/numfmt.c:1126
#, c-format
msgid "invalid precision in format %s"
msgstr ""

#: src/numfmt.c:1132
#, c-format
msgid "invalid format %s, directive must be %%[0]['][-][N][.][N]f"
msgstr ""

#: src/numfmt.c:1140 src/seq.c:264
#, c-format
msgid "format %s has too many %% directives"
msgstr "格式%s 中%% 指令过多"

#: src/numfmt.c:1183
#, c-format
msgid "invalid suffix in input %s: %s"
msgstr ""

#: src/numfmt.c:1212
#, c-format
msgid ""
"value/precision too large to be printed: '%Lg/%<PRIuMAX>' (consider using --"
"to)"
msgstr ""

#: src/numfmt.c:1216
#, c-format
msgid "value too large to be printed: '%Lg' (consider using --to)"
msgstr ""

#: src/numfmt.c:1225
#, c-format
msgid "value too large to be printed: '%Lg' (cannot handle values > 999Y)"
msgstr ""

#: src/numfmt.c:1311
#, c-format
msgid "large input value %s: possible precision loss"
msgstr ""

#: src/numfmt.c:1500
#, c-format
msgid "invalid padding value %s"
msgstr ""

#: src/numfmt.c:1513
msgid "multiple field specifications"
msgstr ""

#: src/numfmt.c:1547
#, c-format
msgid "invalid header value %s"
msgstr ""

#: src/numfmt.c:1574
msgid "--grouping cannot be combined with --format"
msgstr ""

#: src/numfmt.c:1577 src/sort.c:4685
#, c-format
msgid "failed to set locale"
msgstr ""

#: src/numfmt.c:1582
#, c-format
msgid "no conversion option specified"
msgstr ""

#: src/numfmt.c:1590
msgid "grouping cannot be combined with --to"
msgstr ""

#: src/numfmt.c:1592
#, c-format
msgid "grouping has no effect in this locale"
msgstr ""

#: src/numfmt.c:1605
#, c-format
msgid "--header ignored with command-line input"
msgstr ""

#: src/numfmt.c:1632
#, c-format
msgid "error reading input"
msgstr ""

#: src/numfmt.c:1643
#, c-format
msgid "failed to convert some of the input numbers"
msgstr ""

#: src/od.c:322
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]\n"
"  or:  %s --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] "
"[+][LABEL][.][b]]\n"
msgstr ""
"用法：%s [选项]... [文件]...\n"
"　或：%s [-abcdfilosx]... [文件] [[+]偏移量[.][b]]\n"
"　或：%s --traditional [选项]... [文件] [[+]偏移量[.][b] [+][标签][.][b]]\n"

#: src/od.c:328
msgid ""
"\n"
"Write an unambiguous representation, octal bytes by default,\n"
"of FILE to standard output.  With more than one FILE argument,\n"
"concatenate them in the listed order to form the input.\n"
msgstr ""

#: src/od.c:336
msgid ""
"\n"
"If first and second call formats both apply, the second format is assumed\n"
"if the last operand begins with + or (if there are 2 operands) a digit.\n"
"An OFFSET operand means -j OFFSET.  LABEL is the pseudo-address\n"
"at first byte printed, incremented when dump is progressing.\n"
"For OFFSET and LABEL, a 0x or 0X prefix indicates hexadecimal;\n"
"suffixes may be . for octal and b for multiply by 512.\n"
msgstr ""
"\n"
"如果两个调用格式都适用，系统会在最后一个运算量以\"+\"或数字开始\n"
"(如果有两个运算量)的情况下采用第二种格式。\n"
"偏移量是指 -j 偏移量。标签是第一个字节的伪地址，\n"
"随着累积过程递增。偏移量和标签如果冠以\"0x\"或\"0X\"前缀则\n"
"表示十六进制数；后缀\".\"代表八进制数，后缀\"b\"表示乘以 512。\n"

#: src/od.c:348
msgid ""
"  -A, --address-radix=RADIX   output format for file offsets; RADIX is one\n"
"                                of [doxn], for Decimal, Octal, Hex or None\n"
"      --endian={big|little}   swap input bytes according the specified "
"order\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
msgstr ""

#: src/od.c:354
msgid ""
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
"  -S BYTES, --strings[=BYTES]  output strings of at least BYTES graphic "
"chars;\n"
"                                3 is implied when BYTES is not specified\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w[BYTES], --width[=BYTES]  output BYTES bytes per output line;\n"
"                                32 is implied when BYTES is not specified\n"
"      --traditional           accept arguments in third form above\n"
msgstr ""

#: src/od.c:367
msgid ""
"\n"
"\n"
"Traditional format specifications may be intermixed; they accumulate:\n"
"  -a   same as -t a,  select named characters, ignoring high-order bit\n"
"  -b   same as -t o1, select octal bytes\n"
"  -c   same as -t c,  select printable characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal 2-byte units\n"
msgstr ""

#: src/od.c:376
msgid ""
"  -f   same as -t fF, select floats\n"
"  -i   same as -t dI, select decimal ints\n"
"  -l   same as -t dL, select decimal longs\n"
"  -o   same as -t o2, select octal 2-byte units\n"
"  -s   same as -t d2, select decimal 2-byte units\n"
"  -x   same as -t x2, select hexadecimal 2-byte units\n"
msgstr ""
"  -f\t即 -t fF，指定浮点数对照输出格式\n"
"  -i\t即 -t dl，指定十进制整数对照输出格式\n"
"  -l\t即 -t dL，指定十进制长整数对照输出格式\n"
"  -o\t即 -t o2，指定双字节单位八进制数的对照输出格式\n"
"  -s\t即 -t d2，指定双字节单位十进制数的对照输出格式\n"
"  -x\t即 -t x2，指定双字节单位十六进制数的对照输出格式\n"

#: src/od.c:384
msgid ""
"\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"  a          named character, ignoring high-order bit\n"
"  c          printable character or backslash escape\n"
msgstr ""

#: src/od.c:391
msgid ""
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per float\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
msgstr ""

#: src/od.c:398
msgid ""
"\n"
"SIZE is a number.  For TYPE in [doux], SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
msgstr ""

#: src/od.c:405
msgid ""
"\n"
"Adding a z suffix to any type displays printable characters at the end of\n"
"each output line.\n"
msgstr ""

#: src/od.c:410
msgid ""
"\n"
"\n"
"BYTES is hex with 0x or 0X prefix, and may have a multiplier suffix:\n"
"  b    512\n"
"  KB   1000\n"
"  K    1024\n"
"  MB   1000*1000\n"
"  M    1024*1024\n"
"and so on for G, T, P, E, Z, Y.\n"
msgstr ""

#: src/od.c:683 src/od.c:803
#, c-format
msgid "invalid type string %s"
msgstr "无效类型的字符串%s"

#: src/od.c:693
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"无效的类型字符串%s；\n"
"系统无法提供对%lu-字节整形类型数值的支持"

#: src/od.c:814
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"无效的类型字符串%s；\n"
"系统无法提供对%lu-字节浮点类型数值的支持"

#: src/od.c:872
#, c-format
msgid "invalid character '%c' in type string %s"
msgstr ""

#: src/od.c:1104
msgid "cannot skip past end of combined input"
msgstr "无法略过输入内容的报尾"

#: src/od.c:1654
#, c-format
msgid ""
"invalid output address radix '%c'; it must be one character from [doxn]"
msgstr ""

#: src/od.c:1792
msgid "no type may be specified when dumping strings"
msgstr "在转储字符串时不能指定类型"

#: src/od.c:1867
msgid "compatibility mode supports at most one file"
msgstr "兼容模式最多支持一个文件"

#: src/od.c:1888
msgid "skip-bytes + read-bytes is too large"
msgstr "略过字节数+ 读入字节数的值过大"

#: src/od.c:1931
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "警告：无效的宽度值%lu，已使用%d 代替"

#: src/operand2sig.c:88
#, c-format
msgid "%s: invalid signal"
msgstr "%s：无效的信号"

#: src/paste.c:222
msgid "standard input is closed"
msgstr "标准输入已关闭"

#: src/paste.c:440
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
msgstr ""

#: src/paste.c:448
msgid ""
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
msgstr ""
"  -d, --delimiters=列表\t改用指定列表里的字符替代制表分隔符\n"
"  -s, --serial\t\t不使用平行的行目输出模式，而是每个文件占用一行\n"

#: src/paste.c:518
#, c-format
msgid "delimiter list ends with an unescaped backslash: %s"
msgstr "分割符列表以一个未跳过的反斜线结束：%s"

#: src/pathchk.c:89
msgid ""
"Diagnose invalid or unportable file names.\n"
"\n"
"  -p                  check for most POSIX systems\n"
"  -P                  check for empty names and leading \"-\"\n"
"      --portability   check for all POSIX systems (equivalent to -p -P)\n"
msgstr ""
"判断无效或未移植的文件名。\n"
"\n"
"  -p                  \t为类POSIX 兼容系统检查\n"
"  -P                  \t检查空文件名和前导\"-\"文件名\n"
"      --portability   \t为完整POSIX 兼容系统检查(等于-p -P)\n"

#: src/pathchk.c:169
#, c-format
msgid "leading '-' in a component of file name %s"
msgstr ""

#: src/pathchk.c:195
#, c-format
msgid "nonportable character %s in file name %s"
msgstr "有不通用的字符%s 被包含在文件名%s 中"

#: src/pathchk.c:271
#, c-format
msgid "empty file name"
msgstr "空文件名"

#: src/pathchk.c:313
#, c-format
msgid "%s: unable to determine maximum file name length"
msgstr "%s：不能确定最大文件名长度"

#: src/pathchk.c:324
#, c-format
msgid "limit %lu exceeded by length %lu of file name %s"
msgstr "文件名%3$s 的长度%2$lu 超出限值%1$lu"

#: src/pathchk.c:410
#, c-format
msgid "limit %lu exceeded by length %lu of file name component %s"
msgstr "文件名成分%3$s 的长度%2$lu 超出限值%1$lu"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:37 src/uptime.c:46 src/users.c:36 src/who.c:50
msgid "Joseph Arceneaux"
msgstr "Joseph Arceneaux"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:39 src/uptime.c:48
msgid "Kaveh Ghazi"
msgstr "Kaveh Ghazi"

#. TRANSLATORS: Real name is unknown; at most 19 characters.
#: src/pinky.c:241
msgid "        ???"
msgstr "        ???"

#. TRANSLATORS: Idle time is unknown; at most 5 characters.
#: src/pinky.c:265
msgid "?????"
msgstr "?????"

#: src/pinky.c:313
#, c-format
msgid "Login name: "
msgstr "登录名： "

#: src/pinky.c:316
#, c-format
msgid "In real life: "
msgstr "真名： "

#. TRANSLATORS: Real name is unknown; no hard limit.
#: src/pinky.c:320
msgid "???\n"
msgstr "???\n"

#: src/pinky.c:340
#, c-format
msgid "Directory: "
msgstr "主目录： "

#: src/pinky.c:342
#, c-format
msgid "Shell: "
msgstr "Shell： "

#: src/pinky.c:361
#, c-format
msgid "Project: "
msgstr "项目： "

#: src/pinky.c:385
#, c-format
msgid "Plan:\n"
msgstr "计划：\n"

#: src/pinky.c:404
msgid "Login"
msgstr "登录名"

#: src/pinky.c:406
msgid "Name"
msgstr "名字"

#: src/pinky.c:407
msgid " TTY"
msgstr " TTY"

#: src/pinky.c:409
msgid "Idle"
msgstr "空闲时间"

#: src/pinky.c:410
msgid "When"
msgstr "起始时间"

#: src/pinky.c:413
msgid "Where"
msgstr "来自"

#: src/pinky.c:489
#, c-format
msgid "Usage: %s [OPTION]... [USER]...\n"
msgstr "用法: %s [选项]... [用户]...\n"

#: src/pinky.c:490
msgid ""
"\n"
"  -l              produce long format output for the specified USERs\n"
"  -b              omit the user's home directory and shell in long format\n"
"  -h              omit the user's project file in long format\n"
"  -p              omit the user's plan file in long format\n"
"  -s              do short format output, this is the default\n"
msgstr ""
"\n"
"  -l\t对指定用户输出完整的长格式信息\n"
"  -b\t在长格式中省略用户主目录以及登录 shell\n"
"  -h\t在长格式中省略用户的项目文件\n"
"  -p\t在长格式中省略用户的计划文件\n"
"  -s\t输出短格式信息(默认)\n"

#: src/pinky.c:498
msgid ""
"  -f              omit the line of column headings in short format\n"
"  -w              omit the user's full name in short format\n"
"  -i              omit the user's full name and remote host in short format\n"
"  -q              omit the user's full name, remote host and idle time\n"
"                  in short format\n"
msgstr ""
"  -f\t在短格式中省略列栏报头\n"
"  -w\t在短格式中省略用户全名\n"
"  -i\t在短格式中省略用户全名以及远程主机\n"
"  -q\t在短格式中省略用户全名、远程主机以及空闲时间\n"

#: src/pinky.c:507
#, c-format
msgid ""
"\n"
"A lightweight 'finger' program;  print user information.\n"
"The utmp file will be %s.\n"
msgstr ""
"\n"
"一个轻量级的\"finger\"程序，用于显示用户信息。\n"
"用到的 utmp 文件为 %s。\n"

#: src/pinky.c:591
#, c-format
msgid "no username specified; at least one must be specified when using -l"
msgstr "没有指定用户名，当使用 -l 选项时至少需要指定一个"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:331
msgid "Pete TerMaat"
msgstr "Pete TerMaat"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:332
msgid "Roland Huebner"
msgstr "Roland Huebner"

#: src/pr.c:777
msgid "integer overflow"
msgstr "整数溢出"

#: src/pr.c:916
msgid "'--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr ""

#: src/pr.c:918
#, c-format
msgid "invalid page range %s"
msgstr "页码范围%s 无效"

#: src/pr.c:978
msgid "'-l PAGE_LENGTH' invalid number of lines"
msgstr ""

#: src/pr.c:993
msgid "'-N NUMBER' invalid starting line number"
msgstr ""

#: src/pr.c:997
msgid "'-o MARGIN' invalid line offset"
msgstr ""

#: src/pr.c:1034
msgid "'-w PAGE_WIDTH' invalid number of characters"
msgstr ""

#: src/pr.c:1043
msgid "'-W PAGE_WIDTH' invalid number of characters"
msgstr ""

#: src/pr.c:1072
msgid "cannot specify number of columns when printing in parallel"
msgstr "在平行输出参数时不能指定栏数"

#: src/pr.c:1076
msgid "cannot specify both printing across and printing in parallel"
msgstr "无法同时指定相交输出和平行输出参数"

#: src/pr.c:1179
#, c-format
msgid "'-%c' extra characters or invalid number in the argument: %s"
msgstr ""

#: src/pr.c:1281
msgid "page width too narrow"
msgstr "过窄"

#: src/pr.c:2337
#, c-format
msgid "starting page number %<PRIuMAX> exceeds page count %<PRIuMAX>"
msgstr "起始页码%<PRIuMAX> 超出了最大页数%<PRIuMAX>"

#: src/pr.c:2364
msgid "page number overflow"
msgstr "页码溢出"

#: src/pr.c:2369
#, c-format
msgid "Page %<PRIuMAX>"
msgstr "第 %<PRIuMAX> 页"

#: src/pr.c:2741
msgid "Paginate or columnate FILE(s) for printing.\n"
msgstr ""

#: src/pr.c:2748
msgid ""
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    output COLUMN columns and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page\n"
msgstr ""
"  +首页[:末页], --pages=首页[:末页]\n"
"\t\t\t在指定的首页/末页处开始/停止打印\n"
"  -列数, --columns=列数\n"
"\t\t\t输出指定的列数。如果指定了-a 选项，则从上到下列印。\n"
"\t\t\t程序会自动在每一页均衡每列占用的行数。\n"

#: src/pr.c:2756
msgid ""
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
msgstr ""
"  -a, --across\t\t设置每列从上到下输出，配合\"-列数\"选项一起使用\n"
"  -c, --show-control-chars\n"
"\t\t\t使用头标(^G)和八进制反斜杠标记\n"
"  -d, --double-space\t加倍输出空白区域\n"

#: src/pr.c:2764
msgid ""
"  -D, --date-format=FORMAT\n"
"                    use FORMAT for the header date\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"  -D, --date-format=格式\n"
"\t\t\t使用遵循指定格式的页眉日期\n"
"  -e[字符[宽度]], --expand-tabs[=字符[宽度]]\n"
"\t\t\t扩展输入的字符(制表符) 到制表符宽度(8)\n"
"  -F, -f, --form-feed\t使用出纸页页标代替新行作为页面间的分隔符\n"
"\t\t\t(使用-F 选项时报头为3 行,不使用时为5 行)\n"

#: src/pr.c:2774
msgid ""
"  -h, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, --sep-string[=STRING] sets separators\n"
msgstr ""
"  -h, --header=页眉\t在页眉中使用居中的指定字符代替文件名\n"
"\t\t\t-h \"\" 输出一个空行，不要使用 -h\"\"\n"
"  -i[字符[宽度]], --output-tabs[=字符[宽度]]\n"
"\t\t\t使用指定字符(或制表符)代替空格不足到指定制表符宽度(默认8)\n"
"  -J, --join-lines\t合并整个行，关闭-W 选项的行截断，不使用栏调整，使用\n"
"\t\t\t\t--sep-string[=字符串] 设置分隔符\n"

#: src/pr.c:2783
msgid ""
"  -l, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63).\n"
"                    implies -t if PAGE_LENGTH <= 10\n"
msgstr ""

#: src/pr.c:2789
msgid ""
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
msgstr ""

#: src/pr.c:2793
msgid ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
msgstr ""
"  -n[分隔符[位数]], --number-lines[=分隔符[位数]]\n"
"\t\t\t显示行号，使用指定(默认5) 位数，后接分隔符(默认TAB)\n"
"\t\t\t默认从输入文件的第一行开始计数\n"
"  -N, --first-line-number=数字\n"
"\t\t\t从首页的首行以指定数字开始计数(参看\"+首页\")\n"

#: src/pr.c:2801
msgid ""
"  -o, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""
"  -o, --indent=缩进量\n"
"\t\t\t将每行缩进(默认0)个空格，不影响-w 或-W 参数，\n"
"\t\t\t缩进亮的值将被加入页面宽度\n"
"  -r, --no-file-warnings\n"
"\t\t\t当文件无法打开时忽略警告\n"

#: src/pr.c:2808
msgid ""
"  -s[CHAR], --separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -"
"w.\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
msgstr ""

#: src/pr.c:2816
msgid ""
"  -S[STRING], --sep-string[=STRING]\n"
"                    separate columns by STRING,\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
msgstr ""

#: src/pr.c:2822
msgid ""
"  -t, --omit-header  omit page headers and trailers;\n"
"                     implied if PAGE_LENGTH <= 10\n"
msgstr ""

#: src/pr.c:2826
msgid ""
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
msgstr ""
"  -T, --omit-pagination\n"
"\t\t\t按照输入文件中的设置忽略页眉和页脚并除去所有分页记号\n"
"  -v, --show-nonprinting\n"
"\t\t\t使用八进制反斜杠标记\n"
"  -w, --width=页面宽度\n"
"\t\t\t为多栏页面输出将设置为指定的字符数(默认72)，\n"
"\t\t\t仅当-s[char] 选项不启用时有效(即保持默认值 72)。\n"

#: src/pr.c:2836
msgid ""
"  -W, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
msgstr ""
"  -W, --page-width=页宽\n"
"\t\t\t总是将页宽设置为指定的(默认72)字符数，\n"
"\t\t\t除非-J 选项启用总是截断行，此参数与-S 或-s 冲突\n"

#: src/printenv.c:62
#, c-format
msgid ""
"Usage: %s [OPTION]... [VARIABLE]...\n"
"Print the values of the specified environment VARIABLE(s).\n"
"If no VARIABLE is specified, print name and value pairs for them all.\n"
"\n"
msgstr ""
"用法： %s [选项]... [变量]...\n"
"显示指定的环境变量的值。\n"
"如果没有指定变量，则打印出所有变量的名称和值。\n"
"\n"

#: src/printenv.c:69
msgid "  -0, --null     end each output line with NUL, not newline\n"
msgstr ""

#: src/printf.c:84
#, c-format
msgid ""
"warning: %s: character(s) following character constant have been ignored"
msgstr "警告：%s：跟随在常量字符后的其它字符已被忽略"

#: src/printf.c:93
#, c-format
msgid ""
"Usage: %s FORMAT [ARGUMENT]...\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 格式 [参数]\n"
"　或：%s 选项\n"

#: src/printf.c:98
msgid ""
"Print ARGUMENT(s) according to FORMAT, or execute according to OPTION:\n"
"\n"
msgstr ""
"按照指定格式打印参数或按照选项执行该参数：\n"
"\n"

#: src/printf.c:104
msgid ""
"\n"
"FORMAT controls the output as in C printf.  Interpreted sequences are:\n"
"\n"
"  \\\"      double quote\n"
msgstr ""
"\n"
"指定格式类似 C 中的 printf 函数，可控制输出。有效的解释序列有：\n"
"\n"
"  \\\"\t\t双引号\n"

#: src/printf.c:122
msgid ""
"  \\NNN    byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
"  \\uHHHH  Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)\n"
"  \\UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits)\n"
msgstr ""
"  \\NNN          字节以八进制数 NNN(1至3位数)表示\n"
"  \\xHH\t\t字节以十六进制数 HH(1至2位数)表示\n"
"  \\uHHHH\tUnicode(ISO/IEC 10646)字符以十六进制数 HHHH(4位数)表示\n"
"  \\UHHHHHHHH\tUnicode 字符以十六进制数 HHHHHHHH(8位数)表示\n"

#: src/printf.c:128
msgid ""
"  %%      a single %\n"
"  %b      ARGUMENT as a string with '\\' escapes interpreted,\n"
"          except that octal escapes are of the form \\0 or \\0NNN\n"
"  %q      ARGUMENT is printed in a format that can be reused as shell "
"input,\n"
"          escaping non-printable characters with the proposed POSIX $'' "
"syntax.\n"
"\n"
"and all C format specifications ending with one of diouxXfeEgGcs, with\n"
"ARGUMENTs converted to proper type first.  Variable widths are handled.\n"
msgstr ""

#: src/printf.c:155
#, c-format
msgid "%s: expected a numeric value"
msgstr "%s：需要一个数值"

#: src/printf.c:157
#, c-format
msgid "%s: value not completely converted"
msgstr "%s：给定值不能完全转换"

#: src/printf.c:254 src/printf.c:281
msgid "missing hexadecimal number in escape"
msgstr "Escape 中缺失十六进制数"

#: src/printf.c:293
#, c-format
msgid "invalid universal character name \\%c%0*x"
msgstr "无效的通用字符名称\\%c%0*x"

#: src/printf.c:566
#, c-format
msgid "invalid field width: %s"
msgstr "无效的域宽度：%s"

#: src/printf.c:601
#, c-format
msgid "invalid precision: %s"
msgstr "无效的精度：%s"

#: src/printf.c:628
#, c-format
msgid "%.*s: invalid conversion specification"
msgstr "%.*s：无效的转换声明"

#: src/printf.c:711
#, c-format
msgid "warning: ignoring excess arguments, starting with %s"
msgstr "警告：从%s 开始已忽略超量的参数"

#. TRANSLATORS: Please translate "F. Pinard" to "François Pinard"
#. if "ç" (c-with-cedilla) is available in the translation's character
#. set and encoding.
#. This is a proper name. See the gettext manual, section Names.
#: src/ptx.c:42
msgid "F. Pinard"
msgstr "F. Pinard"

#: src/ptx.c:424
#, c-format
msgid "%s (for regexp %s)"
msgstr "%s (正则表达式 %s)"

#: src/ptx.c:823
#, c-format
msgid "error: regular expression has a match of length zero: %s"
msgstr ""

#: src/ptx.c:1814
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"用法：%s [选项]... [输入]... (不包括 -G 选项)\n"
"　或：%s -G [选项]... [输入 [输出]]\n"

#: src/ptx.c:1818
msgid ""
"Output a permuted index, including context, of the words in the input "
"files.\n"
msgstr ""

#: src/ptx.c:1825
msgid ""
"  -A, --auto-reference           output automatically generated references\n"
"  -G, --traditional              behave more like System V 'ptx'\n"
msgstr ""

#: src/ptx.c:1829
msgid ""
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations.\n"
"                                 The default is '/'\n"
msgstr ""

#: src/ptx.c:1833
msgid ""
"  -M, --macro-name=STRING        macro name to use instead of 'xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
msgstr ""

#: src/ptx.c:1840
msgid ""
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
msgstr ""
"  -W, --word-regexp=正则表达式\t使用正则表达式匹配每个关键字\n"
"  -b, --break-file=文件\t\t以文件中包含的单词为分隔字符\n"
"  -f, --ignore-case\t\t排序时合并小写字母和大写字母\n"
"  -g, --gap-size=数值\t\t指定多个输出区块间的列间隙尺寸\n"
"  -i, --ignore-file=文件\t从指定文件中读取忽略单词的列表\n"
"  -o, --only-file=文件\t\t只从指定文件中读取单词列表\n"

#: src/ptx.c:1848
msgid ""
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
msgstr ""
"  -r, --references\t\t设置每行的第一个区块为关联引用\n"
"  -t, --typeset-mode\t\t -- 此功能尚未实现 --\n"
"  -w, --width=数值\t\t每列的输出宽度，不计关联引用\n"

#: src/ptx.c:1945
#, c-format
msgid "invalid gap width: %s"
msgstr "无效的间隙宽度：%s"

#: src/ptx.c:1972
#, c-format
msgid "invalid line width: %s"
msgstr "无效的行宽：%s"

#: src/pwd.c:58
msgid ""
"Print the full filename of the current working directory.\n"
"\n"
msgstr ""
"输出当前工作目录的完整名称。\n"
"\n"

#: src/pwd.c:62
msgid ""
"  -L, --logical   use PWD from environment, even if it contains symlinks\n"
"  -P, --physical  avoid all symlinks\n"
msgstr ""
"  -L, --logical\t\t使用环境变量中的PWD，即使其中包含符号链接\n"
"  -P, --physical\t避免所有符号链接\n"

#: src/pwd.c:68
msgid ""
"\n"
"If no option is specified, -P is assumed.\n"
msgstr ""

#: src/pwd.c:169
#, c-format
msgid "failed to chdir to %s"
msgstr "无法切换到目录%s"

#: src/pwd.c:173 src/pwd.c:280 src/split.c:469
#, c-format
msgid "failed to stat %s"
msgstr "获取%s 的文件状态失败(stat)"

#: src/pwd.c:238
#, c-format
msgid "couldn't find directory entry in %s with matching i-node"
msgstr "在匹配的inode %s 上找不到目录入口"

#: src/pwd.c:367
#, c-format
msgid "ignoring non-option arguments"
msgstr "忽略不是选项的参数"

#. This is a proper name. See the gettext manual, section Names.
#: src/readlink.c:32
msgid "Dmitry V. Levin"
msgstr "Dmitry V. Levin"

#: src/readlink.c:62 src/realpath.c:71 src/shred.c:170 src/stat.c:1497
#: src/touch.c:213
#, c-format
msgid "Usage: %s [OPTION]... FILE...\n"
msgstr "用法：%s [选项]... 文件...\n"

#: src/readlink.c:63
msgid ""
"Print value of a symbolic link or canonical file name\n"
"\n"
msgstr ""
"输出符号链接值或规范文件名。\n"
"\n"

#: src/readlink.c:65
msgid ""
"  -f, --canonicalize            canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively;\n"
"                                all but the last component must exist\n"
"  -e, --canonicalize-existing   canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                all components must exist\n"
msgstr ""
"  -f, --canonicalize\t\t递归的跟随给定文件名的所有符号链接以规范化，\n"
"\t\t\t\t除最后一个外所有组件必须存在\n"
"  -e, --canonicalize-existing\t递归跟随给定文件名的所有符号链接以规范化，\n"
"\t\t\t\t所有组件都必须存在\n"

#: src/readlink.c:75
msgid ""
"  -m, --canonicalize-missing    canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                without requirements on components "
"existence\n"
"  -n, --no-newline              do not output the trailing delimiter\n"
"  -q, --quiet\n"
"  -s, --silent                  suppress most error messages (on by "
"default)\n"
"  -v, --verbose                 report error messages\n"
"  -z, --zero                    end each output line with NUL, not newline\n"
msgstr ""

#: src/readlink.c:152
#, c-format
msgid "ignoring --no-newline with multiple arguments"
msgstr ""

#: src/realpath.c:72
msgid ""
"Print the resolved absolute file name;\n"
"all but the last component must exist\n"
"\n"
msgstr ""

#: src/realpath.c:77
msgid ""
"  -e, --canonicalize-existing  all components of the path must exist\n"
"  -m, --canonicalize-missing   no path components need exist or be a "
"directory\n"
"  -L, --logical                resolve '..' components before symlinks\n"
"  -P, --physical               resolve symlinks as encountered (default)\n"
"  -q, --quiet                  suppress most error messages\n"
"      --relative-to=DIR        print the resolved path relative to DIR\n"
"      --relative-base=DIR      print absolute paths unless paths below DIR\n"
"  -s, --strip, --no-symlinks   don't expand symlinks\n"
"  -z, --zero                   end each output line with NUL, not newline\n"
"\n"
msgstr ""

#: src/relpath.c:130
msgid "generating relative path"
msgstr ""

#: src/remove.c:273
#, c-format
msgid "%s: descend into write-protected directory %s? "
msgstr "%s：是否进入有写保护的目录%s ？ "

#: src/remove.c:274
#, c-format
msgid "%s: descend into directory %s? "
msgstr "%s：是否进入目录%s? "

#. TRANSLATORS: In the next two strings the second %s is
#. replaced by the type of the file.  To avoid grammatical
#. problems, it may be more convenient to translate these
#. strings instead as: "%1$s: %3$s is write-protected and
#. is of type '%2$s' -- remove it? ".
#: src/remove.c:291
#, c-format
msgid "%s: remove write-protected %s %s? "
msgstr "%s：是否删除有写保护的%s %s？ "

#: src/remove.c:292
#, c-format
msgid "%s: remove %s %s? "
msgstr "%s：是否删除%s %s？ "

#: src/remove.c:375
#, c-format
msgid "removed directory %s\n"
msgstr ""

#: src/remove.c:447
#, c-format
msgid "refusing to remove %s or %s directory: skipping %s"
msgstr ""

#: src/remove.c:476
#, c-format
msgid "failed to stat %s: skipping %s"
msgstr ""

#: src/remove.c:489 src/remove.c:539
#, c-format
msgid "skipping %s, since it's on a different device"
msgstr "跳过%s，因为它位于不同的设备上"

#: src/remove.c:491
#, c-format
msgid "and --preserve-root=all is in effect"
msgstr ""

#: src/remove.c:559
#, c-format
msgid "traversal failed: %s"
msgstr "遍历失败：%s"

#: src/remove.c:565
#, c-format
msgid ""
"unexpected failure: fts_info=%d: %s\n"
"please report to %s"
msgstr ""
"异常错误：fts_info=%d: %s\n"
"请报告给 %s"

#: src/rm.c:117
#, c-format
msgid "Try '%s ./%s' to remove the file %s.\n"
msgstr ""

#: src/rm.c:134
msgid ""
"Remove (unlink) the FILE(s).\n"
"\n"
"  -f, --force           ignore nonexistent files and arguments, never "
"prompt\n"
"  -i                    prompt before every removal\n"
msgstr ""

#: src/rm.c:140
msgid ""
"  -I                    prompt once before removing more than three files, "
"or\n"
"                          when removing recursively; less intrusive than -"
"i,\n"
"                          while still giving protection against most "
"mistakes\n"
"      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or\n"
"                          always (-i); without WHEN, prompt always\n"
msgstr ""

#: src/rm.c:147
msgid ""
"      --one-file-system  when removing a hierarchy recursively, skip any\n"
"                          directory that is on a file system different from\n"
"                          that of the corresponding command line argument\n"
msgstr ""
"      --one-file-system\t\t递归删除一个层级时，跳过所有不符合命令行参\n"
"\t\t\t\t数的文件系统上的文件\n"

#: src/rm.c:152
msgid ""
"      --no-preserve-root  do not treat '/' specially\n"
"      --preserve-root[=all]  do not remove '/' (default);\n"
"                              with 'all', reject any command line argument\n"
"                              on a separate device from its parent\n"
msgstr ""

#: src/rm.c:158
msgid ""
"  -r, -R, --recursive   remove directories and their contents recursively\n"
"  -d, --dir             remove empty directories\n"
"  -v, --verbose         explain what is being done\n"
msgstr ""

#: src/rm.c:165
msgid ""
"\n"
"By default, rm does not remove directories.  Use the --recursive (-r or -R)\n"
"option to remove each listed directory, too, along with all of its "
"contents.\n"
msgstr ""
"\n"
"默认时，rm 不会删除目录。使用--recursive(-r 或-R)选项可删除每个给定\n"
"的目录，以及其下所有的内容。\n"

#: src/rm.c:170
#, c-format
msgid ""
"\n"
"To remove a file whose name starts with a '-', for example '-foo',\n"
"use one of these commands:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"
msgstr ""

#: src/rm.c:179
msgid ""
"\n"
"Note that if you use rm to remove a file, it might be possible to recover\n"
"some of its contents, given sufficient expertise and/or time.  For greater\n"
"assurance that the contents are truly unrecoverable, consider using shred.\n"
msgstr ""
"\n"
"请注意，如果使用rm 来删除文件，通常仍可以将该文件恢复原状。如果想保证\n"
"该文件的内容无法还原，请考虑使用shred。\n"

#: src/rm.c:297
msgid "you may not abbreviate the --no-preserve-root option"
msgstr ""

#: src/rm.c:309
#, c-format
msgid "unrecognized --preserve-root argument: %s"
msgstr ""

#: src/rm.c:359
#, c-format
msgid "%s: remove %<PRIuMAX> argument recursively? "
msgid_plural "%s: remove %<PRIuMAX> arguments recursively? "
msgstr[0] ""
msgstr[1] ""

#: src/rm.c:362
#, c-format
msgid "%s: remove %<PRIuMAX> argument? "
msgid_plural "%s: remove %<PRIuMAX> arguments? "
msgstr[0] ""
msgstr[1] ""

#: src/rmdir.c:133 src/rmdir.c:232
#, c-format
msgid "removing directory, %s"
msgstr "正在删除目录 %s"

#: src/rmdir.c:147
#, c-format
msgid "failed to remove directory %s"
msgstr "删除目录 %s 失败"

#: src/rmdir.c:164
msgid ""
"Remove the DIRECTORY(ies), if they are empty.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  ignore each failure that is solely because a directory\n"
"                    is non-empty\n"
msgstr ""
"删除指定的空目录。\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"\t\t\t忽略仅由目录非空产生的所有错误\n"

#: src/rmdir.c:171
msgid ""
"  -p, --parents   remove DIRECTORY and its ancestors; e.g., 'rmdir -p a/b/c' "
"is\n"
"                    similar to 'rmdir a/b/c a/b a'\n"
"  -v, --verbose   output a diagnostic for every directory processed\n"
msgstr ""

#: src/rmdir.c:241
#, c-format
msgid "failed to remove %s"
msgstr "删除 %s 失败"

#: src/runcon.c:78
#, c-format
msgid ""
"Usage: %s CONTEXT COMMAND [args]\n"
"  or:  %s [ -c ] [-u USER] [-r ROLE] [-t TYPE] [-l RANGE] COMMAND [args]\n"
msgstr ""
"用法: %s 环境 命令 [参数]\n"
"　或: %s [ -c ] [-u 用户] [-r 角色] [-t 类型] [-l 范围] 命令 [参数]\n"

#: src/runcon.c:82
msgid ""
"Run a program in a different SELinux security context.\n"
"With neither CONTEXT nor COMMAND, print the current security context.\n"
msgstr ""

#: src/runcon.c:89
msgid ""
"  CONTEXT            Complete security context\n"
"  -c, --compute      compute process transition context before modifying\n"
"  -t, --type=TYPE    type (for same role as parent)\n"
"  -u, --user=USER    user identity\n"
"  -r, --role=ROLE    role\n"
"  -l, --range=RANGE  levelrange\n"
"\n"
msgstr ""

#: src/runcon.c:139
msgid "multiple roles"
msgstr "多角色"

#: src/runcon.c:144
msgid "multiple types"
msgstr "多类型"

#: src/runcon.c:149
msgid "multiple users"
msgstr "多用户"

#: src/runcon.c:154
msgid "multiple levelranges"
msgstr "复合级别范围"

#: src/runcon.c:172 src/runcon.c:208
msgid "failed to get current context"
msgstr "无法获得当前安全环境"

#: src/runcon.c:182
#, c-format
msgid "you must specify -c, -t, -u, -l, -r, or context"
msgstr "您必须指定-c，-t，-u，-l，-r 或环境"

#: src/runcon.c:190
#, c-format
msgid "no command specified"
msgstr "没有指定命令"

#: src/runcon.c:195
#, c-format
msgid "%s may be used only on a SELinux kernel"
msgstr "%s 只能用于启用了SELinux 支持的内核"

#: src/runcon.c:222
msgid "failed to compute a new context"
msgstr "计算新的环境失败"

#: src/runcon.c:236
#, c-format
msgid "failed to set new user: %s"
msgstr ""

#: src/runcon.c:239
#, c-format
msgid "failed to set new type: %s"
msgstr ""

#: src/runcon.c:242
#, c-format
msgid "failed to set new range: %s"
msgstr ""

#: src/runcon.c:245
#, c-format
msgid "failed to set new role: %s"
msgstr ""

#: src/runcon.c:254
#, c-format
msgid "unable to set security context %s"
msgstr "无法设置安全环境%s"

#: src/seq.c:72
#, c-format
msgid ""
"Usage: %s [OPTION]... LAST\n"
"  or:  %s [OPTION]... FIRST LAST\n"
"  or:  %s [OPTION]... FIRST INCREMENT LAST\n"
msgstr ""
"用法：%s [选项]... 尾数\n"
"　或：%s [选项]... 首数 尾数\n"
"　或：%s [选项]... 首数 增量 尾数\n"

#: src/seq.c:77
msgid "Print numbers from FIRST to LAST, in steps of INCREMENT.\n"
msgstr ""

#: src/seq.c:83
msgid ""
"  -f, --format=FORMAT      use printf style floating-point FORMAT\n"
"  -s, --separator=STRING   use STRING to separate numbers (default: \\n)\n"
"  -w, --equal-width        equalize width by padding with leading zeroes\n"
msgstr ""

#: src/seq.c:90
msgid ""
"\n"
"If FIRST or INCREMENT is omitted, it defaults to 1.  That is, an\n"
"omitted INCREMENT defaults to 1 even when LAST is smaller than FIRST.\n"
"The sequence of numbers ends when the sum of the current number and\n"
"INCREMENT would become greater than LAST.\n"
"FIRST, INCREMENT, and LAST are interpreted as floating point values.\n"
"INCREMENT is usually positive if FIRST is smaller than LAST, and\n"
"INCREMENT is usually negative if FIRST is greater than LAST.\n"
"INCREMENT must not be 0; none of FIRST, INCREMENT and LAST may be NaN.\n"
msgstr ""

#: src/seq.c:101
msgid ""
"FORMAT must be suitable for printing one argument of type 'double';\n"
"it defaults to %.PRECf if FIRST, INCREMENT, and LAST are all fixed point\n"
"decimal numbers with maximum precision PREC, and to %g otherwise.\n"
msgstr ""

#: src/seq.c:147
#, c-format
msgid "invalid floating point argument: %s"
msgstr "无效的浮点参数：%s"

#: src/seq.c:153
#, c-format
msgid "invalid %s argument: %s"
msgstr "无效的 %s 参数：%s"

#: src/seq.c:260
#, c-format
msgid "format %s has unknown %%%c directive"
msgstr "格式%s 中包含未知%%%c 指令"

#: src/seq.c:628
#, c-format
msgid "format string may not be specified when printing equal width strings"
msgstr "当输出等宽字符串时不应再指定格式字符串"

#: src/seq.c:665
#, c-format
msgid "invalid Zero increment value: %s"
msgstr ""

#: src/set-fields.c:167
msgid "invalid byte or character range"
msgstr ""

#: src/set-fields.c:168
msgid "invalid field range"
msgstr ""

#: src/set-fields.c:175 src/set-fields.c:221
msgid "byte/character positions are numbered from 1"
msgstr ""

#: src/set-fields.c:176 src/set-fields.c:222
msgid "fields are numbered from 1"
msgstr ""

#: src/set-fields.c:196
msgid "invalid range with no endpoint: -"
msgstr "无终点的无效的范围：-"

#: src/set-fields.c:210
msgid "invalid decreasing range"
msgstr "无效的缩小的范围"

#: src/set-fields.c:259
#, c-format
msgid "byte/character offset %s is too large"
msgstr ""

#: src/set-fields.c:260
#, c-format
msgid "field number %s is too large"
msgstr "域编号%s 过大"

#: src/set-fields.c:271
#, c-format
msgid "invalid byte/character position %s"
msgstr ""

#: src/set-fields.c:272
#, c-format
msgid "invalid field value %s"
msgstr ""

#: src/set-fields.c:280
msgid "missing list of byte/character positions"
msgstr ""

#: src/set-fields.c:281
msgid "missing list of fields"
msgstr "缺少域列表"

#. This is a proper name. See the gettext manual, section Names.
#: src/shred.c:74
msgid "Colin Plumb"
msgstr "Colin Plumb"

#: src/shred.c:171
msgid ""
"Overwrite the specified FILE(s) repeatedly, in order to make it harder\n"
"for even very expensive hardware probing to recover the data.\n"
msgstr ""

#: src/shred.c:175
msgid ""
"\n"
"If FILE is -, shred standard output.\n"
msgstr ""

#: src/shred.c:182
#, c-format
msgid ""
"  -f, --force    change permissions to allow writing if necessary\n"
"  -n, --iterations=N  overwrite N times instead of the default (%d)\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -s, --size=N   shred this many bytes (suffixes like K, M, G accepted)\n"
msgstr ""
"  -f, --force\t\t必要时修改权限以使目标可写\n"
"  -n, --iterations=N\t覆盖N 次，而非使用默认的%d 次\n"
"      --random-source=文件\t从指定文件中取出随机字节\n"
"  -s, --size=N\t\t粉碎数据为指定字节的碎片(可使用K、M 和G 作为单位)\n"

#: src/shred.c:188
msgid ""
"  -u             deallocate and remove file after overwriting\n"
"      --remove[=HOW]  like -u but give control on HOW to delete;  See below\n"
"  -v, --verbose  show progress\n"
"  -x, --exact    do not round file sizes up to the next full block;\n"
"                   this is the default for non-regular files\n"
"  -z, --zero     add a final overwrite with zeros to hide shredding\n"
msgstr ""

#: src/shred.c:198
msgid ""
"\n"
"Delete FILE(s) if --remove (-u) is specified.  The default is not to remove\n"
"the files because it is common to operate on device files like /dev/hda,\n"
"and those files usually should not be removed.\n"
"The optional HOW parameter indicates how to remove a directory entry:\n"
"'unlink' => use a standard unlink call.\n"
"'wipe' => also first obfuscate bytes in the name.\n"
"'wipesync' => also sync each obfuscated byte to disk.\n"
"The default mode is 'wipesync', but note it can be expensive.\n"
"\n"
msgstr ""

#: src/shred.c:210
msgid ""
"CAUTION: Note that shred relies on a very important assumption:\n"
"that the file system overwrites data in place.  This is the traditional\n"
"way to do things, but many modern file system designs do not satisfy this\n"
"assumption.  The following are examples of file systems on which shred is\n"
"not effective, or is not guaranteed to be effective in all file system "
"modes:\n"
"\n"
msgstr ""
"警告：请注意使用shred 时有一个很重要的条件：\n"
"文件系统会在原来的位置覆盖指定的数据。传统的文件系统符合此条件，但许多现代\n"
"的文件系统都不符合条件。以下是会令shred 无效或不担保一定有效的文件系统的\n"
"例子：\n"
"\n"

#: src/shred.c:218
msgid ""
"* log-structured or journaled file systems, such as those supplied with\n"
"AIX and Solaris (and JFS, ReiserFS, XFS, Ext3, etc.)\n"
"\n"
"* file systems that write redundant data and carry on even if some writes\n"
"fail, such as RAID-based file systems\n"
"\n"
"* file systems that make snapshots, such as Network Appliance's NFS server\n"
"\n"
msgstr ""
"* 有纪录结构或是日志式文件系统，如AIX 及Solaris 使用的文件系统 (以及\n"
"   JFS、ReiserFS、XFS、Ext3 等)\n"
"\n"
"* 会重复写入数据，及即使一部份写入动作失败后仍可继续的文件系统，如使用\n"
"   RAID 的文件系统\n"
"\n"
"* 会不时进行快照记录的文件系统，像Network Applicance 的NFS 服务器\n"
"\n"

#: src/shred.c:228
msgid ""
"* file systems that cache in temporary locations, such as NFS\n"
"version 3 clients\n"
"\n"
"* compressed file systems\n"
"\n"
msgstr ""
"* 文件系统是存放于缓存位置，比如NFS 第三版用户端\n"
"\n"
"* 压缩文件系统\n"
"\n"

#: src/shred.c:235
msgid ""
"In the case of ext3 file systems, the above disclaimer applies\n"
"(and shred is thus of limited effectiveness) only in data=journal mode,\n"
"which journals file data in addition to just metadata.  In both the\n"
"data=ordered (default) and data=writeback modes, shred works as usual.\n"
"Ext3 journaling modes can be changed by adding the data=something option\n"
"to the mount options for a particular file system in the /etc/fstab file,\n"
"as documented in the mount man page (man mount).\n"
"\n"
msgstr ""
"在Ext3 文件系统中，以上免责声明仅适用于启用了data=journal 模式的情况，\n"
"此时文件日志记录了附加的元数据 shred 的作用将受到影响。在data=ordered(默认)\n"
"或data=writeback 模式下shred 仍然有效。\n"
"Ext3 日志模式可通过向/etc/fstab 的挂载选项中添加data=something 进行设置，\n"
"您可以查看mount 的man 页面以获得详细信息。\n"
"\n"

#: src/shred.c:245
msgid ""
"In addition, file system backups and remote mirrors may contain copies\n"
"of the file that cannot be removed, and that will allow a shredded file\n"
"to be recovered later.\n"
msgstr ""
"另外，文件系统备份和远程镜像可能会\n"
"包含不能被删除的文件副本，这将会\n"
"允许碎片文件被恢复。\n"

#: src/shred.c:344
#, c-format
msgid "%s: fdatasync failed"
msgstr "%s：fadatsync 失败"

#: src/shred.c:355
#, c-format
msgid "%s: fsync failed"
msgstr "%s：fsync 失败"

#: src/shred.c:472
#, c-format
msgid "%s: cannot rewind"
msgstr "%s：无法反绕操作"

#: src/shred.c:492
#, c-format
msgid "%s: pass %lu/%lu (%s)..."
msgstr "%s：第%lu 次，共%lu 次 (%s)..."

#: src/shred.c:543
#, c-format
msgid "%s: error writing at offset %s"
msgstr "%s：在位置%s 写入时出现错误"

#: src/shred.c:564
#, c-format
msgid "%s: lseek failed"
msgstr "%s：lseek 失败"

#: src/shred.c:576
#, c-format
msgid "%s: file too large"
msgstr "%s：文件过大"

#: src/shred.c:600
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s"
msgstr "%s：第%lu 次，共%lu 次 (%s)...%s"

#: src/shred.c:616
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s/%s %d%%"
msgstr "%s：第%lu 次，共%lu 次 (%s)...%s/%s %d%%"

#: src/shred.c:874
#, c-format
msgid "%s: fstat failed"
msgstr "%s：获取文件状态失败(fstat)"

#: src/shred.c:885
#, c-format
msgid "%s: invalid file type"
msgstr "%s：无效的文件类型"

#: src/shred.c:890
#, c-format
msgid "%s: file has negative size"
msgstr "%s：文件的大小为负数"

#: src/shred.c:984 src/sort.c:967 src/split.c:474
#, c-format
msgid "%s: error truncating"
msgstr "%s：截断文件时出错"

#: src/shred.c:1003
#, c-format
msgid "%s: fcntl failed"
msgstr "%s：文件控制操作失败(fcntl)"

#: src/shred.c:1008
#, c-format
msgid "%s: cannot shred append-only file descriptor"
msgstr "%s：不能对只可追加数据的文件描述符(file descriptor) 进行粉碎"

#: src/shred.c:1091
#, c-format
msgid "%s: removing"
msgstr "%s：正在删除"

#: src/shred.c:1116
#, c-format
msgid "%s: renamed to %s"
msgstr "%s：名称已更改为 %s"

#: src/shred.c:1125
#, c-format
msgid "%s: failed to remove"
msgstr "%s：删除失败"

#: src/shred.c:1129
#, c-format
msgid "%s: removed"
msgstr "%s：已删除"

#: src/shred.c:1136 src/shred.c:1179
#, c-format
msgid "%s: failed to close"
msgstr "%s：无法关闭"

#: src/shred.c:1172
#, c-format
msgid "%s: failed to open for writing"
msgstr "%s：无法以写模式打开"

#: src/shred.c:1235
msgid "invalid number of passes"
msgstr ""

#: src/shred.c:1240 src/shuf.c:462 src/sort.c:4507
msgid "multiple random sources specified"
msgstr "指定了多个随机源"

#: src/shred.c:1254
msgid "invalid file size"
msgstr ""

#: src/shuf.c:62
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]\n"
"  or:  %s -e [OPTION]... [ARG]...\n"
"  or:  %s -i LO-HI [OPTION]...\n"
msgstr ""
"用法： %s [选项]... [文件]\n"
"　或者:  %s -e [选项]... [参数]...\n"
"　或者:  %s -i LO-HI [选项]...\n"

#: src/shuf.c:68
msgid "Write a random permutation of the input lines to standard output.\n"
msgstr ""

#: src/shuf.c:75
msgid ""
"  -e, --echo                treat each ARG as an input line\n"
"  -i, --input-range=LO-HI   treat each number LO through HI as an input "
"line\n"
"  -n, --head-count=COUNT    output at most COUNT lines\n"
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -r, --repeat              output lines can be repeated\n"
msgstr ""

#: src/shuf.c:226
msgid "too many input lines"
msgstr ""

#: src/shuf.c:418
msgid "multiple -i options specified"
msgstr "指定了多个-i 选项"

#: src/shuf.c:425 src/shuf.c:431 src/shuf.c:436
msgid "invalid input range"
msgstr ""

#: src/shuf.c:449
#, c-format
msgid "invalid line count: %s"
msgstr ""

#: src/shuf.c:456 src/sort.c:4501
msgid "multiple output files specified"
msgstr "指定了多个输出文件"

#: src/shuf.c:486
#, c-format
msgid "cannot combine -e and -i options"
msgstr "不能同时指定-e 和-i 选项"

#: src/shuf.c:570
msgid "no lines to repeat"
msgstr ""

#: src/sleep.c:50
#, c-format
msgid ""
"Usage: %s NUMBER[SUFFIX]...\n"
"  or:  %s OPTION\n"
"Pause for NUMBER seconds.  SUFFIX may be 's' for seconds (the default),\n"
"'m' for minutes, 'h' for hours or 'd' for days.  Unlike most "
"implementations\n"
"that require NUMBER be an integer, here NUMBER may be an arbitrary floating\n"
"point number.  Given two or more arguments, pause for the amount of time\n"
"specified by the sum of their values.\n"
"\n"
msgstr ""

#: src/sleep.c:140 src/timeout.c:332
#, c-format
msgid "invalid time interval %s"
msgstr "无效的时间间隔%s"

#: src/sleep.c:151 src/tail.c:1287
msgid "cannot read realtime clock"
msgstr "无法读取实时时钟"

#: src/sort.c:432
msgid "Write sorted concatenation of all FILE(s) to standard output.\n"
msgstr ""

#: src/sort.c:439
msgid ""
"Ordering options:\n"
"\n"
msgstr ""
"排序选项：\n"
"\n"

#: src/sort.c:443
msgid ""
"  -b, --ignore-leading-blanks  ignore leading blanks\n"
"  -d, --dictionary-order      consider only blanks and alphanumeric "
"characters\n"
"  -f, --ignore-case           fold lower case to upper case characters\n"
msgstr ""
"  -b, --ignore-leading-blanks\t忽略前导的空白区域\n"
"  -d, --dictionary-order\t只考虑空白区域和字母字符\n"
"  -f, --ignore-case\t\t忽略字母大小写\n"

#: src/sort.c:449
msgid ""
"  -g, --general-numeric-sort  compare according to general numerical value\n"
"  -i, --ignore-nonprinting    consider only printable characters\n"
"  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n"
msgstr ""

#: src/sort.c:454
msgid ""
"  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n"
msgstr "  -h, --human-numeric-sort    使用易读性数字(例如： 2K 1G)\n"

#: src/sort.c:457
msgid ""
"  -n, --numeric-sort          compare according to string numerical value\n"
"  -R, --random-sort           shuffle, but group identical keys.  See "
"shuf(1)\n"
"      --random-source=FILE    get random bytes from FILE\n"
"  -r, --reverse               reverse the result of comparisons\n"
msgstr ""

#: src/sort.c:463
msgid ""
"      --sort=WORD             sort according to WORD:\n"
"                                general-numeric -g, human-numeric -h, month -"
"M,\n"
"                                numeric -n, random -R, version -V\n"
"  -V, --version-sort          natural sort of (version) numbers within text\n"
"\n"
msgstr ""
"      --sort=WORD\t\t按照WORD 指定的格式排序：\n"
"\t\t\t\t\t一般数字-g，高可读性-h，月份-M，数字-n，\n"
"\t\t\t\t\t随机-R，版本-V\n"
"  -V, --version-sort\t\t在文本内进行自然版本排序\n"
"\n"

#: src/sort.c:471
msgid ""
"Other options:\n"
"\n"
msgstr ""
"其他选项：\n"
"\n"

#: src/sort.c:475
msgid ""
"      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
"                            for more use temp files\n"
msgstr ""
"      --batch-size=NMERGE\t一次最多合并NMERGE 个输入；如果输入更多\n"
"\t\t\t\t\t则使用临时文件\n"

#: src/sort.c:479
msgid ""
"  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
"  -C, --check=quiet, --check=silent  like -c, but do not report first bad "
"line\n"
"      --compress-program=PROG  compress temporaries with PROG;\n"
"                              decompress them with PROG -d\n"
msgstr ""
"  -c, --check, --check=diagnose-first\t检查输入是否已排序，若已有序则不进行操作\n"
"  -C, --check=quiet, --check=silent\t类似-c，但不报告第一个无序行\n"
"      --compress-program=程序\t使用指定程序压缩临时文件；使用该程序\n"
"\t\t\t\t\t的-d 参数解压缩文件\n"

#: src/sort.c:486
msgid ""
"      --debug               annotate the part of the line used to sort,\n"
"                              and warn about questionable usage to stderr\n"
"      --files0-from=F       read input from the files specified by\n"
"                            NUL-terminated names in file F;\n"
"                            If F is - then read names from standard input\n"
msgstr ""
"      --debug\t\t\t为用于排序的行添加注释，并将有可能有问题的\n"
"\t\t\t\t\t用法输出到标准错误输出\n"
"      --files0-from=文件\t从指定文件读取以NUL 终止的名称，如果该文件被\n"
"\t\t\t\t\t指定为\"-\"则从标准输入读文件名\n"

#: src/sort.c:493
msgid ""
"  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
"  -m, --merge               merge already sorted files; do not sort\n"
msgstr ""

#: src/sort.c:497
msgid ""
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"  -s, --stable              stabilize sort by disabling last-resort "
"comparison\n"
"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
msgstr ""
"  -o, --output=文件\t\t将结果写入到文件而非标准输出\n"
"  -s, --stable\t\t\t禁用last-resort 比较以稳定比较算法\n"
"  -S, --buffer-size=大小\t指定主内存缓存大小\n"

#: src/sort.c:503
#, c-format
msgid ""
"  -t, --field-separator=SEP  use SEP instead of non-blank to blank "
"transition\n"
"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or "
"%s;\n"
"                              multiple options specify multiple directories\n"
"      --parallel=N          change the number of sorts run concurrently to "
"N\n"
"  -u, --unique              with -c, check for strict ordering;\n"
"                              without -c, output only the first of an equal "
"run\n"
msgstr ""
"  -t, --field-separator=分隔符\t使用指定的分隔符代替非空格到空格的转换\n"
"  -T, --temporary-directory=目录\t使用指定目录而非$TMPDIR 或%s 作为\n"
"\t\t\t\t\t临时目录，可用多个选项指定多个目录\n"
"      --parallel=N\t\t将同时运行的排序数改变为N\n"
"  -u, --unique\t\t配合-c，严格校验排序；不配合-c，则只输出一次排序结果\n"

#: src/sort.c:517
msgid ""
"\n"
"KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is "
"a\n"
"field number and C a character position in the field; both are origin 1, "
"and\n"
"the stop position defaults to the line's end.  If neither -t nor -b is in\n"
"effect, characters in a field are counted from the beginning of the "
"preceding\n"
"whitespace.  OPTS is one or more single-letter ordering options "
"[bdfgiMhnRrV],\n"
"which override global ordering options for that key.  If no key is given, "
"use\n"
"the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
"\n"
"SIZE may be followed by the following multiplicative suffixes:\n"
msgstr ""

#: src/sort.c:530
msgid ""
"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
"\n"
"*** WARNING ***\n"
"The locale specified by the environment affects sort order.\n"
"Set LC_ALL=C to get the traditional sort order that uses\n"
"native byte values.\n"
msgstr ""
"内存使用率% 1%，b 1、K 1024（默认），M、G、T、P、E、Z、Y 等依此类推。\n"
"\n"
"*** 警告 ***\n"
"地区与语言环境变量（locale）会影响排序结果。\n"
"如果希望以字节的自然值获得最传统的排序结果，\n"
"请设置环境变量 LC_ALL=C。\n"

#: src/sort.c:728
#, c-format
msgid "waiting for %s [-d]"
msgstr "等待 %s [-d]"

#: src/sort.c:733
#, c-format
msgid "%s [-d] terminated abnormally"
msgstr "%s [-d] 不正常结束"

#: src/sort.c:888
#, c-format
msgid "cannot create temporary file in %s"
msgstr "无法在%s 创建临时文件"

#: src/sort.c:985 src/sort.c:2094 src/sort.c:3131 src/sort.c:3779
#: src/sort.c:3870 src/sort.c:3873
msgid "open failed"
msgstr "打开失败"

#: src/sort.c:1005
msgid "fflush failed"
msgstr "冲洗流失败(fflush)"

#: src/sort.c:1010 src/sort.c:2097 src/sort.c:4776
msgid "close failed"
msgstr "关闭失败"

#: src/sort.c:1149
msgid "couldn't create temporary file"
msgstr "无法创建临时文件"

#: src/sort.c:1188
#, c-format
msgid "couldn't create process for %s -d"
msgstr "无法创建进程%s -d"

#: src/sort.c:1261
#, c-format
msgid "warning: cannot remove: %s"
msgstr "警告：无法删除：%s"

#: src/sort.c:1347
#, c-format
msgid "invalid --%s argument %s"
msgstr "无效的 --%s 参数%s"

#: src/sort.c:1350
#, c-format
msgid "minimum --%s argument is %s"
msgstr "最小 --%s 参数是%s"

#: src/sort.c:1365
#, c-format
msgid "--%s argument %s too large"
msgstr "--%s 参数%s 太长"

#: src/sort.c:1368
#, c-format
msgid "maximum --%s argument with current rlimit is %s"
msgstr "最大 --%s 参数在当前资源限制(rlimit)设置下是%s"

#: src/sort.c:1450
msgid "number in parallel must be nonzero"
msgstr "单个的数字必须不为零"

#: src/sort.c:1533
msgid "stat failed"
msgstr "获取文件状态失败(stat)"

#: src/sort.c:1795
msgid "read failed"
msgstr "读取失败"

#: src/sort.c:2112
#, c-format
msgid "string transformation failed"
msgstr "字符串转换失败"

#: src/sort.c:2115
#, c-format
msgid "the untransformed string was %s"
msgstr "未转换的字符串为%s"

#: src/sort.c:2278
#, c-format
msgid "^ no match for key\n"
msgstr "^ 没有匹配项\n"

#: src/sort.c:2450
#, c-format
msgid "obsolescent key %s used; consider %s instead"
msgstr ""

#: src/sort.c:2457
#, c-format
msgid "key %lu has zero width and will be ignored"
msgstr "值%lu 宽度为零，忽略"

#: src/sort.c:2466
#, c-format
msgid ""
"leading blanks are significant in key %lu; consider also specifying 'b'"
msgstr ""

#: src/sort.c:2479
#, c-format
msgid "key %lu is numeric and spans multiple fields"
msgstr "值%lu 为数字且跨多个域"

#: src/sort.c:2511
#, c-format
msgid "option '-%s' is ignored"
msgid_plural "options '-%s' are ignored"
msgstr[0] ""
msgstr[1] ""

#: src/sort.c:2517
#, c-format
msgid "option '-r' only applies to last-resort comparison"
msgstr ""

#: src/sort.c:2791 src/sort.c:2800
msgid "write failed"
msgstr "写入失败"

#: src/sort.c:2843
#, c-format
msgid "%s: %s:%s: disorder: "
msgstr "%s：%s:%s：无序： "

#: src/sort.c:2846
msgid "standard error"
msgstr "标准错误"

#: src/sort.c:3763
msgid "cannot read"
msgstr "无法读取"

#: src/sort.c:4042
#, c-format
msgid "%s: invalid field specification %s"
msgstr "%s：无效的区块规格%s"

#: src/sort.c:4052
#, c-format
msgid "options '-%s' are incompatible"
msgstr ""

#: src/sort.c:4102
#, c-format
msgid "%s: invalid count at start of %s"
msgstr "%s：在%s 处的计数无效"

#: src/sort.c:4361
msgid "invalid number after '-'"
msgstr ""

#: src/sort.c:4368 src/sort.c:4454 src/sort.c:4482
msgid "invalid number after '.'"
msgstr ""

#: src/sort.c:4381 src/sort.c:4487
msgid "stray character in field spec"
msgstr "区块中有孤立字符"

#: src/sort.c:4428
msgid "multiple compress programs specified"
msgstr "指定了多个压缩程序"

#: src/sort.c:4445
msgid "invalid number at field start"
msgstr "区块起始处的编号无效"

#: src/sort.c:4449 src/sort.c:4477
msgid "field number is zero"
msgstr "区块编号为零"

#: src/sort.c:4458
msgid "character offset is zero"
msgstr "字符偏移量为零"

#: src/sort.c:4473
msgid "invalid number after ','"
msgstr ""

#: src/sort.c:4523
msgid "empty tab"
msgstr "空标签"

#: src/sort.c:4606 src/wc.c:763
#, c-format
msgid "cannot read file names from %s"
msgstr "无法从%s 中读取文件名"

#: src/sort.c:4628
#, c-format
msgid "%s:%lu: invalid zero-length file name"
msgstr "%s：%lu：无效的 0 长度文件名"

#: src/sort.c:4634
#, c-format
msgid "no input from %s"
msgstr "没有来自%s 的输入"

#: src/sort.c:4687
#, c-format
msgid "using %s sorting rules"
msgstr "使用%s 排序规则"

#: src/sort.c:4690
msgid "using simple byte comparison"
msgstr "使用简单字节比较"

#: src/sort.c:4722
#, c-format
msgid "extra operand %s not allowed with -%c"
msgstr "不允许额外的操作数%s 与-%c 一起使用"

#: src/split.c:209
#, c-format
msgid "the suffix length needs to be at least %<PRIuMAX>"
msgstr ""

#: src/split.c:226
#, c-format
msgid "Usage: %s [OPTION]... [FILE [PREFIX]]\n"
msgstr ""

#: src/split.c:230
msgid ""
"Output pieces of FILE to PREFIXaa, PREFIXab, ...;\n"
"default size is 1000 lines, and default PREFIX is 'x'.\n"
msgstr ""

#: src/split.c:238
#, c-format
msgid ""
"  -a, --suffix-length=N   generate suffixes of length N (default %d)\n"
"      --additional-suffix=SUFFIX  append an additional SUFFIX to file names\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of records per output file\n"
"  -d                      use numeric suffixes starting at 0, not "
"alphabetic\n"
"      --numeric-suffixes[=FROM]  same as -d, but allow setting the start "
"value\n"
"  -x                      use hex suffixes starting at 0, not alphabetic\n"
"      --hex-suffixes[=FROM]  same as -x, but allow setting the start value\n"
"  -e, --elide-empty-files  do not generate empty output files with '-n'\n"
"      --filter=COMMAND    write to shell COMMAND; file name is $FILE\n"
"  -l, --lines=NUMBER      put NUMBER lines/records per output file\n"
"  -n, --number=CHUNKS     generate CHUNKS output files; see explanation "
"below\n"
"  -t, --separator=SEP     use SEP instead of newline as the record "
"separator;\n"
"                            '\\0' (zero) specifies the NUL character\n"
"  -u, --unbuffered        immediately copy input to output with '-n r/...'\n"
msgstr ""

#: src/split.c:256
msgid ""
"      --verbose           print a diagnostic just before each\n"
"                            output file is opened\n"
msgstr "      --verbose\t\t在每个输出文件打开前输出文件特征\n"

#: src/split.c:263
msgid ""
"\n"
"CHUNKS may be:\n"
"  N       split into N files based on size of input\n"
"  K/N     output Kth of N to stdout\n"
"  l/N     split into N files without splitting lines/records\n"
"  l/K/N   output Kth of N to stdout without splitting lines/records\n"
"  r/N     like 'l' but use round robin distribution\n"
"  r/K/N   likewise but only output Kth of N to stdout\n"
msgstr ""

#: src/split.c:450
msgid "output file suffixes exhausted"
msgstr "已排除输出文件后缀"

#: src/split.c:462
#, c-format
msgid "creating file %s\n"
msgstr "正在创建文件 %s\n"

#: src/split.c:471
#, c-format
msgid "%s would overwrite input; aborting"
msgstr ""

#: src/split.c:487
msgid "failed to set FILE environment variable"
msgstr ""

#: src/split.c:489
#, c-format
msgid "executing with FILE=%s\n"
msgstr ""

#: src/split.c:491
msgid "failed to create pipe"
msgstr ""

#: src/split.c:505
msgid "closing prior pipe"
msgstr ""

#: src/split.c:507
msgid "closing output pipe"
msgstr ""

#: src/split.c:511
msgid "moving input pipe"
msgstr ""

#: src/split.c:513
msgid "closing input pipe"
msgstr ""

#: src/split.c:518
#, c-format
msgid "failed to run command: \"%s -c %s\""
msgstr ""

#: src/split.c:524
msgid "failed to close input pipe"
msgstr ""

#: src/split.c:560
msgid "waiting for child process"
msgstr ""

#: src/split.c:570
#, c-format
msgid "with FILE=%s, signal %s from command: %s"
msgstr ""

#: src/split.c:578
#, c-format
msgid "with FILE=%s, exit %d from command: %s"
msgstr ""

#: src/split.c:585
#, c-format
msgid "unknown status from command (0x%X)"
msgstr "来自命令的未知状态 (0x%X)"

#: src/split.c:1273
#, c-format
msgid "cannot split in more than one way"
msgstr "无法以多于一种的方式切分输入"

#: src/split.c:1285 src/split.c:1400 src/split.c:1601
msgid "invalid number of chunks"
msgstr ""

#: src/split.c:1290
msgid "invalid chunk number"
msgstr ""

#: src/split.c:1337
msgid "invalid suffix length"
msgstr ""

#: src/split.c:1411
msgid "empty record separator"
msgstr ""

#: src/split.c:1422
#, c-format
msgid "multi-character separator %s"
msgstr ""

#: src/split.c:1430
msgid "multiple separator characters specified"
msgstr ""

#: src/split.c:1461
#, c-format
msgid "line count option -%s%c... is too large"
msgstr "行数选项-%s%c... 过大"

#: src/split.c:1478
#, c-format
msgid "%s: invalid start value for numerical suffix"
msgstr ""

#: src/split.c:1479
#, c-format
msgid "%s: invalid start value for hexadecimal suffix"
msgstr ""

#: src/split.c:1503
msgid "invalid IO block size"
msgstr ""

#: src/split.c:1521
#, c-format
msgid "--filter does not process a chunk extracted to stdout"
msgstr ""

#: src/split.c:1561
#, c-format
msgid "numerical suffix start value is too large for the suffix length"
msgstr ""

#: src/split.c:1593
#, c-format
msgid "%s: cannot determine file size"
msgstr "%s：无法确定文件大小"

#. This is a proper name. See the gettext manual, section Names.
#: src/stat.c:190
msgid "Michael Meskes"
msgstr "Michael Meskes"

#: src/stat.c:949
#, c-format
msgid "failed to canonicalize %s"
msgstr "规范化%s 失败"

#: src/stat.c:1217
#, c-format
msgid "warning: unrecognized escape '\\%c'"
msgstr "警告：无法识别的转义字符“\\%c”"

#: src/stat.c:1272
#, c-format
msgid "%s: invalid directive"
msgstr "%s：无效指令"

#: src/stat.c:1319
#, c-format
msgid "warning: backslash at end of format"
msgstr "警告：格式末尾出现反斜杠"

#: src/stat.c:1350
#, c-format
msgid "using %s to denote standard input does not work in file system mode"
msgstr "用 %s 进行标准输入在文件系统模式下无法工作"

#: src/stat.c:1357
#, c-format
msgid "cannot read file system information for %s"
msgstr "无法为 %s 读取文件系统信息"

#: src/stat.c:1378
#, c-format
msgid "cannot stat standard input"
msgstr "无法从标准输入获取文件信息(stat)"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' with --file-system, and NOT from printf.
#: src/stat.c:1414
msgid ""
"  File: \"%n\"\n"
"    ID: %-8i Namelen: %-7l Type: %T\n"
"Block size: %-10s Fundamental block size: %S\n"
"Blocks: Total: %-10b Free: %-10f Available: %a\n"
"Inodes: Total: %-10c Free: %d\n"
msgstr ""
"  文件：\"%n\"\n"
"    ID：%-8i 文件名长度：%-7l 类型：%T\n"
"块大小：%-10s 基本块大小：%S\n"
"    块：总计：%-10b 空闲：%-10f 可用：%a\n"
"Inodes: 总计：%-10c 空闲：%d\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1435
msgid ""
"  File: %N\n"
"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
msgstr ""
"  文件：%N\n"
"  大小：%-10s\t块：%-10b IO 块：%-6o %F\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1445
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %-5h Device type: %t,%T\n"
msgstr "设备：%Dh/%dd\tInode：%-10i  硬链接：%-5h 设备类型：%t,%T\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1453
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
msgstr "设备：%Dh/%dd\tInode：%-10i  硬链接：%h\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1462
msgid "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
msgstr "权限：(%04a/%10.10A)  Uid：(%5u/%8U)   Gid：(%5g/%8G)\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1472
#, c-format
msgid "Context: %C\n"
msgstr "环境：%C\n"

#: src/stat.c:1480
msgid ""
"Access: %x\n"
"Modify: %y\n"
"Change: %z\n"
" Birth: %w\n"
msgstr ""
"最近访问：%x\n"
"最近更改：%y\n"
"最近改动：%z\n"
"创建时间：%w\n"

#: src/stat.c:1498
msgid "Display file or file system status.\n"
msgstr "显示文件或文件系统的状态。\n"

#: src/stat.c:1504
msgid ""
"  -L, --dereference     follow links\n"
"  -f, --file-system     display file system status instead of file status\n"
msgstr ""
"  -L, --dereference     跟随链接\n"
"  -f, --file-system     显示文件系统状态而非文件状态\n"

#: src/stat.c:1508
msgid ""
"  -c  --format=FORMAT   use the specified FORMAT instead of the default;\n"
"                          output a newline after each use of FORMAT\n"
"      --printf=FORMAT   like --format, but interpret backslash escapes,\n"
"                          and do not output a mandatory trailing newline;\n"
"                          if you want a newline, include \\n in FORMAT\n"
"  -t, --terse           print the information in terse form\n"
msgstr ""

#: src/stat.c:1519
msgid ""
"\n"
"The valid format sequences for files (without --file-system):\n"
"\n"
"  %a   access rights in octal (note '#' and '0' printf flags)\n"
"  %A   access rights in human readable form\n"
"  %b   number of blocks allocated (see %B)\n"
"  %B   the size in bytes of each block reported by %b\n"
"  %C   SELinux security context string\n"
msgstr ""

#: src/stat.c:1528
msgid ""
"  %d   device number in decimal\n"
"  %D   device number in hex\n"
"  %f   raw mode in hex\n"
"  %F   file type\n"
"  %g   group ID of owner\n"
"  %G   group name of owner\n"
msgstr ""

#: src/stat.c:1536
msgid ""
"  %h   number of hard links\n"
"  %i   inode number\n"
"  %m   mount point\n"
"  %n   file name\n"
"  %N   quoted file name with dereference if symbolic link\n"
"  %o   optimal I/O transfer size hint\n"
"  %s   total size, in bytes\n"
"  %t   major device type in hex, for character/block device special files\n"
"  %T   minor device type in hex, for character/block device special files\n"
msgstr ""

#: src/stat.c:1547
msgid ""
"  %u   user ID of owner\n"
"  %U   user name of owner\n"
"  %w   time of file birth, human-readable; - if unknown\n"
"  %W   time of file birth, seconds since Epoch; 0 if unknown\n"
"  %x   time of last access, human-readable\n"
"  %X   time of last access, seconds since Epoch\n"
"  %y   time of last data modification, human-readable\n"
"  %Y   time of last data modification, seconds since Epoch\n"
"  %z   time of last status change, human-readable\n"
"  %Z   time of last status change, seconds since Epoch\n"
"\n"
msgstr ""

#: src/stat.c:1561
msgid ""
"Valid format sequences for file systems:\n"
"\n"
"  %a   free blocks available to non-superuser\n"
"  %b   total data blocks in file system\n"
"  %c   total file nodes in file system\n"
"  %d   free file nodes in file system\n"
"  %f   free blocks in file system\n"
msgstr ""

#: src/stat.c:1570
msgid ""
"  %i   file system ID in hex\n"
"  %l   maximum length of filenames\n"
"  %n   file name\n"
"  %s   block size (for faster transfers)\n"
"  %S   fundamental block size (for block counts)\n"
"  %t   file system type in hex\n"
"  %T   file system type in human readable form\n"
msgstr ""

#: src/stat.c:1580
#, c-format
msgid ""
"\n"
"--terse is equivalent to the following FORMAT:\n"
"    %s"
msgstr ""

#: src/stat.c:1591
#, c-format
msgid ""
"--terse --file-system is equivalent to the following FORMAT:\n"
"    %s"
msgstr ""

#: src/stdbuf.c:91
#, c-format
msgid "Usage: %s OPTION... COMMAND\n"
msgstr "用法：%s [选项]... 命令\n"

#: src/stdbuf.c:92
msgid ""
"Run COMMAND, with modified buffering operations for its standard streams.\n"
msgstr "运行给定的命令，同时改变该命令对应标准输入输出流的缓冲操作配置。\n"

#: src/stdbuf.c:98
msgid ""
"  -i, --input=MODE   adjust standard input stream buffering\n"
"  -o, --output=MODE  adjust standard output stream buffering\n"
"  -e, --error=MODE   adjust standard error stream buffering\n"
msgstr ""
"  -i, --input=MODE   调整标准输入流缓冲区\n"
"  -o, --output=MODE  调整标准输出流缓冲区\n"
"  -e, --error=MODE   调整标准错误流缓冲区\n"

#: src/stdbuf.c:105
msgid ""
"\n"
"If MODE is 'L' the corresponding stream will be line buffered.\n"
"This option is invalid with standard input.\n"
msgstr ""
"\n"
"若 MODE 是 \"L\"，则相应的流将是行缓冲模式。\n"
"标准输入流下此选项无效。\n"

#: src/stdbuf.c:108
msgid ""
"\n"
"If MODE is '0' the corresponding stream will be unbuffered.\n"
msgstr ""
"\n"
"若 MODE 是 \"0\"，则相应的流将不缓冲。\n"

#: src/stdbuf.c:111
msgid ""
"\n"
"Otherwise MODE is a number which may be followed by one of the following:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n"
"In this case the corresponding stream will be fully buffered with the "
"buffer\n"
"size set to MODE bytes.\n"
msgstr ""
"\n"
"否则 MODE 就应该是以下数字单位中的一个：\n"
"KB 1000，K 1024，MB 1000*1000，M 1024*1024，以及 G、T、P、E、Z、Y。\n"
"在此情况下，相应的流将缓冲由 MODE 指定大小的缓冲字节。\n"

#: src/stdbuf.c:117
msgid ""
"\n"
"NOTE: If COMMAND adjusts the buffering of its standard streams ('tee' does\n"
"for example) then that will override corresponding changes by 'stdbuf'.\n"
"Also some filters (like 'dd' and 'cat' etc.) don't use streams for I/O,\n"
"and are thus unaffected by 'stdbuf' settings.\n"
msgstr ""
"\n"
"注意：若指定的命令调整了其自身的标准流缓冲区（例如 tee 命令），\n"
"则此操作会覆盖由 \"stdbuf\" 工具所做出的相应设置。\n"
"还有某些过滤器程序（如 \"dd\" 和 \"cat\" 之类）不使用输入输出流，\n"
"因此不受 \"stdbuf\" 设置的影响。\n"

#: src/stdbuf.c:242
#, c-format
msgid "failed to find %s"
msgstr "查找 %s 失败"

#: src/stdbuf.c:266 src/stdbuf.c:299
#, c-format
msgid "failed to update the environment with %s"
msgstr "更新 %s 的环境失败"

#: src/stdbuf.c:345
#, c-format
msgid "line buffering stdin is meaningless"
msgstr "对标准输入进行行缓冲无意义"

#: src/stdbuf.c:376
#, c-format
msgid "you must specify a buffering mode option"
msgstr "您必须指定一个缓冲模式选项"

#: src/stty.c:531
#, c-format
msgid ""
"Usage: %s [-F DEVICE | --file=DEVICE] [SETTING]...\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-a|--all]\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-g|--save]\n"
msgstr ""
"用法：%s [-F 设备 | --file=设备] [设置]...\n"
"　或：%s [-F 设备 | --file=设备] [-a|--all]\n"
"　或：%s [-F 设备 | --file=设备] [-g|--save]\n"

#: src/stty.c:537
msgid "Print or change terminal characteristics.\n"
msgstr ""

#: src/stty.c:543
msgid ""
"  -a, --all          print all current settings in human-readable form\n"
"  -g, --save         print all current settings in a stty-readable form\n"
"  -F, --file=DEVICE  open and use the specified DEVICE instead of stdin\n"
msgstr ""

#: src/stty.c:550
msgid ""
"\n"
"Optional - before SETTING indicates negation.  An * marks non-POSIX\n"
"settings.  The underlying system defines which settings are available.\n"
msgstr ""
"\n"
"可选- 在设置前的指示中，* 标记出了非POSIX 标准的设置。以下系\n"
"统定义象征了哪些设置是有效的。\n"

#: src/stty.c:555
msgid ""
"\n"
"Special characters:\n"
msgstr ""

#: src/stty.c:559
msgid " * discard CHAR  CHAR will toggle discarding of output\n"
msgstr ""

#: src/stty.c:564
msgid ""
" * dsusp CHAR    CHAR will send a terminal stop signal once input flushed\n"
msgstr ""

#: src/stty.c:568
msgid ""
"   eof CHAR      CHAR will send an end of file (terminate the input)\n"
"   eol CHAR      CHAR will end the line\n"
msgstr ""

#: src/stty.c:573
msgid " * eol2 CHAR     alternate CHAR for ending the line\n"
msgstr ""

#: src/stty.c:577
msgid ""
"   erase CHAR    CHAR will erase the last character typed\n"
"   intr CHAR     CHAR will send an interrupt signal\n"
"   kill CHAR     CHAR will erase the current line\n"
msgstr ""

#: src/stty.c:583
msgid " * lnext CHAR    CHAR will enter the next character quoted\n"
msgstr ""

#: src/stty.c:588
msgid " * status CHAR   CHAR will send an info signal\n"
msgstr ""

#: src/stty.c:592
msgid "   quit CHAR     CHAR will send a quit signal\n"
msgstr ""

#: src/stty.c:596
msgid " * rprnt CHAR    CHAR will redraw the current line\n"
msgstr ""

#: src/stty.c:600
msgid ""
"   start CHAR    CHAR will restart the output after stopping it\n"
"   stop CHAR     CHAR will stop the output\n"
"   susp CHAR     CHAR will send a terminal stop signal\n"
msgstr ""

#: src/stty.c:606
msgid " * swtch CHAR    CHAR will switch to a different shell layer\n"
msgstr ""

#: src/stty.c:611
msgid " * werase CHAR   CHAR will erase the last word typed\n"
msgstr ""

#: src/stty.c:615
msgid ""
"\n"
"Special settings:\n"
"   N             set the input and output speeds to N bauds\n"
msgstr ""

#: src/stty.c:621
msgid ""
" * cols N        tell the kernel that the terminal has N columns\n"
" * columns N     same as cols N\n"
msgstr ""

#: src/stty.c:626
#, c-format
msgid ""
" * [-]drain      wait for transmission before applying settings (%s by "
"default)\n"
msgstr ""

#: src/stty.c:628
msgid "on"
msgstr ""

#: src/stty.c:628
msgid "off"
msgstr ""

#: src/stty.c:629
msgid "   ispeed N      set the input speed to N\n"
msgstr ""

#: src/stty.c:633
msgid " * line N        use line discipline N\n"
msgstr ""

#: src/stty.c:637
msgid ""
"   min N         with -icanon, set N characters minimum for a completed "
"read\n"
"   ospeed N      set the output speed to N\n"
msgstr ""

#: src/stty.c:642
msgid ""
" * rows N        tell the kernel that the terminal has N rows\n"
" * size          print the number of rows and columns according to the "
"kernel\n"
msgstr ""

#: src/stty.c:647
msgid ""
"   speed         print the terminal speed\n"
"   time N        with -icanon, set read timeout of N tenths of a second\n"
msgstr ""

#: src/stty.c:651
msgid ""
"\n"
"Control settings:\n"
"   [-]clocal     disable modem control signals\n"
"   [-]cread      allow input to be received\n"
msgstr ""

#: src/stty.c:658
msgid " * [-]crtscts    enable RTS/CTS handshaking\n"
msgstr ""

#: src/stty.c:663
msgid " * [-]cdtrdsr    enable DTR/DSR handshaking\n"
msgstr ""

#: src/stty.c:667
msgid "   csN           set character size to N bits, N in [5..8]\n"
msgstr ""

#: src/stty.c:670
msgid ""
"   [-]cstopb     use two stop bits per character (one with '-')\n"
"   [-]hup        send a hangup signal when the last process closes the tty\n"
"   [-]hupcl      same as [-]hup\n"
"   [-]parenb     generate parity bit in output and expect parity bit in "
"input\n"
"   [-]parodd     set odd parity (or even parity with '-')\n"
msgstr ""

#: src/stty.c:678
msgid " * [-]cmspar     use \"stick\" (mark/space) parity\n"
msgstr ""

#: src/stty.c:682
msgid ""
"\n"
"Input settings:\n"
"   [-]brkint     breaks cause an interrupt signal\n"
"   [-]icrnl      translate carriage return to newline\n"
"   [-]ignbrk     ignore break characters\n"
"   [-]igncr      ignore carriage return\n"
"   [-]ignpar     ignore characters with parity errors\n"
msgstr ""

#: src/stty.c:692
msgid ""
" * [-]imaxbel    beep and do not flush a full input buffer on a character\n"
msgstr ""

#: src/stty.c:696
msgid ""
"   [-]inlcr      translate newline to carriage return\n"
"   [-]inpck      enable input parity checking\n"
"   [-]istrip     clear high (8th) bit of input characters\n"
msgstr ""

#: src/stty.c:702
msgid " * [-]iutf8      assume input characters are UTF-8 encoded\n"
msgstr " * [-]iutf8\t假定输入字符都是UTF-8 编码\n"

#: src/stty.c:707
msgid " * [-]iuclc      translate uppercase characters to lowercase\n"
msgstr ""

#: src/stty.c:712
msgid ""
" * [-]ixany      let any character restart output, not only start character\n"
msgstr ""

#: src/stty.c:716
msgid ""
"   [-]ixoff      enable sending of start/stop characters\n"
"   [-]ixon       enable XON/XOFF flow control\n"
"   [-]parmrk     mark parity errors (with a 255-0-character sequence)\n"
"   [-]tandem     same as [-]ixoff\n"
msgstr ""

#: src/stty.c:722
msgid ""
"\n"
"Output settings:\n"
msgstr ""

#: src/stty.c:727
msgid " * bsN           backspace delay style, N in [0..1]\n"
msgstr ""

#: src/stty.c:732
msgid " * crN           carriage return delay style, N in [0..3]\n"
msgstr ""

#: src/stty.c:737
msgid " * ffN           form feed delay style, N in [0..1]\n"
msgstr ""

#: src/stty.c:742
msgid " * nlN           newline delay style, N in [0..1]\n"
msgstr ""

#: src/stty.c:747
msgid " * [-]ocrnl      translate carriage return to newline\n"
msgstr ""

#: src/stty.c:752
msgid ""
" * [-]ofdel      use delete characters for fill instead of NUL characters\n"
msgstr ""

#: src/stty.c:757
msgid ""
" * [-]ofill      use fill (padding) characters instead of timing for delays\n"
msgstr ""

#: src/stty.c:762
msgid " * [-]olcuc      translate lowercase characters to uppercase\n"
msgstr ""

#: src/stty.c:767
msgid " * [-]onlcr      translate newline to carriage return-newline\n"
msgstr ""

#: src/stty.c:772
msgid " * [-]onlret     newline performs a carriage return\n"
msgstr ""

#: src/stty.c:777
msgid " * [-]onocr      do not print carriage returns in the first column\n"
msgstr ""

#: src/stty.c:781
msgid "   [-]opost      postprocess output\n"
msgstr ""

#: src/stty.c:785
msgid ""
" * tabN          horizontal tab delay style, N in [0..3]\n"
" * tabs          same as tab0\n"
" * -tabs         same as tab3\n"
msgstr ""

#: src/stty.c:792
msgid " * vtN           vertical tab delay style, N in [0..1]\n"
msgstr ""

#: src/stty.c:796
msgid ""
"\n"
"Local settings:\n"
"   [-]crterase   echo erase characters as backspace-space-backspace\n"
msgstr ""

#: src/stty.c:802
msgid ""
" * crtkill       kill all line by obeying the echoprt and echoe settings\n"
" * -crtkill      kill all line by obeying the echoctl and echok settings\n"
msgstr ""

#: src/stty.c:808
msgid " * [-]ctlecho    echo control characters in hat notation ('^c')\n"
msgstr ""

#: src/stty.c:812
msgid "   [-]echo       echo input characters\n"
msgstr ""

#: src/stty.c:816
msgid " * [-]echoctl    same as [-]ctlecho\n"
msgstr ""

#: src/stty.c:820
msgid ""
"   [-]echoe      same as [-]crterase\n"
"   [-]echok      echo a newline after a kill character\n"
msgstr ""

#: src/stty.c:825
msgid " * [-]echoke     same as [-]crtkill\n"
msgstr ""

#: src/stty.c:829
msgid "   [-]echonl     echo newline even if not echoing other characters\n"
msgstr ""

#: src/stty.c:833
msgid ""
" * [-]echoprt    echo erased characters backward, between '\\' and '/'\n"
msgstr ""

#: src/stty.c:838
msgid ""
" * [-]extproc    enable \"LINEMODE\"; useful with high latency links\n"
msgstr ""

#: src/stty.c:843
msgid " * [-]flusho     discard output\n"
msgstr ""

#: src/stty.c:847
#, c-format
msgid ""
"   [-]icanon     enable special characters: %s\n"
"   [-]iexten     enable non-POSIX special characters\n"
msgstr ""

#: src/stty.c:858
msgid ""
"   [-]isig       enable interrupt, quit, and suspend special characters\n"
"   [-]noflsh     disable flushing after interrupt and quit special "
"characters\n"
msgstr ""

#: src/stty.c:863
msgid " * [-]prterase   same as [-]echoprt\n"
msgstr ""

#: src/stty.c:868
msgid ""
" * [-]tostop     stop background jobs that try to write to the terminal\n"
msgstr ""

#: src/stty.c:873
msgid ""
" * [-]xcase      with icanon, escape with '\\' for uppercase characters\n"
msgstr ""

#: src/stty.c:877
msgid ""
"\n"
"Combination settings:\n"
msgstr ""

#: src/stty.c:882
msgid " * [-]LCASE      same as [-]lcase\n"
msgstr ""

#: src/stty.c:886
msgid ""
"   cbreak        same as -icanon\n"
"   -cbreak       same as icanon\n"
msgstr ""

#: src/stty.c:890
msgid ""
"   cooked        same as brkint ignpar istrip icrnl ixon opost isig\n"
"                 icanon, eof and eol characters to their default values\n"
"   -cooked       same as raw\n"
msgstr ""

#: src/stty.c:895
#, c-format
msgid "   crt           same as %s\n"
msgstr ""

#: src/stty.c:905
#, c-format
msgid ""
"   dec           same as %s intr ^c erase 0177\n"
"                 kill ^u\n"
msgstr ""

#: src/stty.c:920
msgid " * [-]decctlq    same as [-]ixany\n"
msgstr ""

#: src/stty.c:924
msgid ""
"   ek            erase and kill characters to their default values\n"
"   evenp         same as parenb -parodd cs7\n"
"   -evenp        same as -parenb cs8\n"
msgstr ""

#: src/stty.c:930
msgid " * [-]lcase      same as xcase iuclc olcuc\n"
msgstr ""

#: src/stty.c:934
msgid ""
"   litout        same as -parenb -istrip -opost cs8\n"
"   -litout       same as parenb istrip opost cs7\n"
msgstr ""

#: src/stty.c:938
#, c-format
msgid ""
"   nl            same as %s\n"
"   -nl           same as %s\n"
msgstr ""

#: src/stty.c:956
msgid ""
"   oddp          same as parenb parodd cs7\n"
"   -oddp         same as -parenb cs8\n"
"   [-]parity     same as [-]evenp\n"
"   pass8         same as -parenb -istrip cs8\n"
"   -pass8        same as parenb istrip cs7\n"
msgstr ""
"   oddp\t等于parenb parodd cs7\n"
"   -oddp\t等于-parenb cs8\n"
"   [-]parity\t等于[-]evenp\n"
"   pass8\t等于-parenb -istrip cs8\n"
"   -pass8\t等于parenb istrip cs7\n"

#: src/stty.c:963
#, c-format
msgid ""
"   raw           same as -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                 -inlcr -igncr -icrnl -ixon -ixoff -icanon -opost\n"
"                 -isig%s min 1 time 0\n"
"   -raw          same as cooked\n"
msgstr ""

#: src/stty.c:982
#, c-format
msgid ""
"   sane          same as cread -ignbrk brkint -inlcr -igncr icrnl\n"
"                 icanon iexten echo echoe echok -echonl -noflsh\n"
"                 %s\n"
"                 %s\n"
"                 %s,\n"
"                 all special characters to their default values\n"
msgstr ""

#: src/stty.c:1068
msgid ""
"\n"
"Handle the tty line connected to standard input.  Without arguments,\n"
"prints baud rate, line discipline, and deviations from stty sane.  In\n"
"settings, CHAR is taken literally, or coded as in ^c, 0x37, 0177 or\n"
"127; special values ^- or undef used to disable special characters.\n"
msgstr ""
"\n"
"处理连接到标准输入的tty 终端行设置。当不附加参数时，程序会输出波特率、行约束\n"
"规则以及与标准stty 设置间的偏差。在设置中，字符会被逐字读取或是被编码为^c、\n"
"0x37、0177 或127 这样的字符，其中有特殊值^- 或undef 被用于禁止特殊字符。\n"

#: src/stty.c:1097
#, c-format
msgid "missing argument to %s"
msgstr "缺少%s 的参数"

#: src/stty.c:1140 src/stty.c:1258
#, c-format
msgid "invalid argument %s"
msgstr "无效的参数 %s"

#: src/stty.c:1192
#, c-format
msgid "%s: error setting %s"
msgstr "%s：设置 %s 时出错"

#: src/stty.c:1234
#, c-format
msgid "invalid line discipline %s"
msgstr "无效的行约束%s"

#: src/stty.c:1326
msgid "only one device may be specified"
msgstr "只能指定一个设备"

#: src/stty.c:1360
msgid ""
"the options for verbose and stty-readable output styles are\n"
"mutually exclusive"
msgstr "verbose 和 stty-readable 两种输入风格的选项是互相抵触的"

#: src/stty.c:1366
msgid "when specifying an output style, modes may not be set"
msgstr "当指定了输出风格时，模式不能再被设置"

#: src/stty.c:1384
#, c-format
msgid "%s: couldn't reset non-blocking mode"
msgstr "%s：无法重置非阻塞模式"

#: src/stty.c:1447
#, c-format
msgid "%s: unable to perform all requested operations"
msgstr "%s：无法执行所有请求的操作"

#: src/stty.c:1792
#, c-format
msgid "%s: no size information for this device"
msgstr "%s：此设备没有大小信息"

#: src/stty.c:2321
msgid "invalid integer argument"
msgstr "无效的整数参数"

#. This is a proper name. See the gettext manual, section Names.
#: src/sum.c:38
msgid "Kayvan Aghaiepour"
msgstr "Kayvan Aghaiepour"

#: src/sum.c:63
msgid "Print checksum and block counts for each FILE.\n"
msgstr ""

#: src/sum.c:69
msgid ""
"\n"
"  -r              use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
msgstr ""

#: src/sync.c:64
#, c-format
msgid "Usage: %s [OPTION] [FILE]...\n"
msgstr "用法：%s [选项] [文件]...\n"

#: src/sync.c:65
msgid ""
"Synchronize cached writes to persistent storage\n"
"\n"
"If one or more files are specified, sync only them,\n"
"or their containing file systems.\n"
"\n"
msgstr ""

#: src/sync.c:73
msgid "  -d, --data             sync only file data, no unneeded metadata\n"
msgstr ""

#: src/sync.c:76
msgid ""
"  -f, --file-system      sync the file systems that contain the files\n"
msgstr ""

#: src/sync.c:114
#, c-format
msgid "error opening %s"
msgstr ""

#: src/sync.c:124
#, c-format
msgid "couldn't reset non-blocking mode %s"
msgstr ""

#: src/sync.c:155
#, c-format
msgid "error syncing %s"
msgstr ""

#: src/sync.c:213
msgid "cannot specify both --data and --file-system"
msgstr ""

#: src/sync.c:217
msgid "--data needs at least one argument"
msgstr ""

#: src/system.h:344
#, c-format
msgid ""
"\n"
"NOTE: your shell may have its own version of %s, which usually supersedes\n"
"the version described here.  Please refer to your shell's documentation\n"
"for details about the options it supports.\n"
msgstr ""
"\n"
"注意：您的shell 可能内置了自己的%s 程序版本，它会覆盖这里所提及的相应\n"
"版本。请查阅您的shell 文档获知它所支持的选项。\n"

#: src/system.h:350
msgid "      --help     display this help and exit\n"
msgstr "      --help\t\t显示此帮助信息并退出\n"

#: src/system.h:352
msgid "      --version  output version information and exit\n"
msgstr "      --version\t\t显示版本信息并退出\n"

#: src/system.h:580
msgid ""
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"如果没有指定文件，或者文件为\"-\"，则从标准输入读取。\n"

#: src/system.h:587
msgid ""
"\n"
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"\n"
"必选参数对长短选项同时适用。\n"

#: src/system.h:595
msgid ""
"\n"
"The SIZE argument is an integer and optional unit (example: 10K is "
"10*1024).\n"
"Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n"
msgstr ""

#: src/system.h:604
#, c-format
msgid ""
"\n"
"Display values are in units of the first available SIZE from --block-size,\n"
"and the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\n"
"Otherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n"
msgstr ""
"\n"
"所显示的数值是来自 --block-size、%s_BLOCK_SIZE、BLOCK_SIZE \n"
"及 BLOCKSIZE 环境变量中第一个可用的 SIZE 单位。\n"
"否则，默认单位是 1024 字节(或是 512，若设定 POSIXLY_CORRECT 的话)。\n"

#: src/system.h:614
msgid ""
"\n"
"The backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n"
"The version control method may be selected via the --backup option or "
"through\n"
"the VERSION_CONTROL environment variable.  Here are the values:\n"
"\n"
msgstr ""

#: src/system.h:621
msgid ""
"  none, off       never make backups (even if --backup is given)\n"
"  numbered, t     make numbered backups\n"
"  existing, nil   numbered if numbered backups exist, simple otherwise\n"
"  simple, never   always make simple backups\n"
msgstr ""
"  none, off       不进行备份(即使使用了--backup 选项)\n"
"  numbered, t     备份文件加上数字进行排序\n"
"  existing, nil   若有数字的备份文件已经存在则使用数字，否则使用普通方式备份\n"
"  simple, never   永远使用普通方式备份\n"

#: src/system.h:651
#, c-format
msgid ""
"\n"
"%s online help: <%s>\n"
msgstr ""
"\n"
"%s 在线帮助：<%s>\n"

#. TRANSLATORS: Replace LANG_CODE in this URL with your language code
#. <https://translationproject.org/team/LANG_CODE.html> to form one of
#. the URLs at https://translationproject.org/team/.  Otherwise, replace
#. the entire URL with your translation team's email address.
#: src/system.h:662
#, c-format
msgid ""
"Report %s translation bugs to <https://translationproject.org/team/>\n"
msgstr "请向 <http://translationproject.org/team/zh_CN.html> 报告 %s 的翻译错误\n"

#: src/system.h:665
#, c-format
msgid "Full documentation at: <%s%s>\n"
msgstr "完整文档请见：<%s%s>\n"

#: src/system.h:667
#, c-format
msgid "or available locally via: info '(coreutils) %s%s'\n"
msgstr "或者在本地使用：info '(coreutils) %s%s'\n"

#: src/system.h:678
#, c-format
msgid "Try '%s --help' for more information.\n"
msgstr "请尝试执行 \"%s --help\" 来获取更多信息。\n"

#: src/system.h:722
#, c-format
msgid ""
"WARNING: Circular directory structure.\n"
"This almost certainly means that you have a corrupted file system.\n"
"NOTIFY YOUR SYSTEM MANAGER.\n"
"The following directory is part of the cycle:\n"
"  %s\n"
msgstr ""
"警告：发现循环的目录架构。\n"
"这几乎可以肯定文件系统已经损坏。\n"
"** 请通知系统管理员。**\n"
"以下的目录是循环的一部份：\n"
"  %s\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/tac.c:57
msgid "Jay Lepreau"
msgstr "Jay Lepreau"

#: src/tac.c:136
msgid "Write each FILE to standard output, last line first.\n"
msgstr ""

#: src/tac.c:143
msgid ""
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
msgstr ""
"  -b, --before\t\t\t在行前而非行尾添加分隔标志\n"
"  -r, --regex\t\t\t将分隔标志视作正则表达式来解析\n"
"  -s, --separator=字符串\t使用指定字符串代替换行作为分隔标志\n"

#: src/tac.c:223 src/tac.c:233 src/tac.c:343
#, c-format
msgid "%s: seek failed"
msgstr "%s：检索失败"

#: src/tac.c:276
msgid "record too large"
msgstr "记录数据过大"

#: src/tac.c:458
#, c-format
msgid "failed to create temporary file in %s"
msgstr "在 %s 创建临时文件失败"

#: src/tac.c:466
#, c-format
msgid "failed to open %s for writing"
msgstr "以写模式打开 %s 时失败"

#: src/tac.c:484
#, c-format
msgid "failed to rewind stream for %s"
msgstr ""

#: src/tac.c:521 src/tac.c:533
#, c-format
msgid "%s: write error"
msgstr "%s：写入出错"

#: src/tac.c:582
#, c-format
msgid "failed to open %s for reading"
msgstr "以读模式打开 %s 时失败"

#: src/tac.c:650
msgid "separator cannot be empty"
msgstr "分隔符不能为空"

#. This is a proper name. See the gettext manual, section Names.
#: src/tail.c:74
msgid "Ian Lance Taylor"
msgstr "Ian Lance Taylor"

#: src/tail.c:265
#, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
msgstr ""

#: src/tail.c:273
msgid ""
"  -c, --bytes=[+]NUM       output the last NUM bytes; or use -c +NUM to\n"
"                             output starting with byte NUM of each file\n"
msgstr ""

#: src/tail.c:277
msgid ""
"  -f, --follow[={name|descriptor}]\n"
"                           output appended data as the file grows;\n"
"                             an absent option argument means 'descriptor'\n"
"  -F                       same as --follow=name --retry\n"
msgstr ""

#: src/tail.c:283
#, c-format
msgid ""
"  -n, --lines=[+]NUM       output the last NUM lines, instead of the last "
"%d;\n"
"                             or use -n +NUM to output starting with line "
"NUM\n"
"      --max-unchanged-stats=N\n"
"                           with --follow=name, reopen a FILE which has not\n"
"                             changed size after N (default %d) iterations\n"
"                             to see if it has been unlinked or renamed\n"
"                             (this is the usual case of rotated log files);\n"
"                             with inotify, this option is rarely useful\n"
msgstr ""

#: src/tail.c:296
msgid ""
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"      --retry              keep trying to open a file if it is inaccessible\n"
msgstr ""

#: src/tail.c:301
msgid ""
"  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\n"
"                             (default 1.0) between iterations;\n"
"                             with inotify and --pid=P, check process P at\n"
"                             least once every N seconds\n"
"  -v, --verbose            always output headers giving file names\n"
msgstr ""

#: src/tail.c:313
msgid ""
"\n"
"NUM may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"\n"
msgstr ""

#: src/tail.c:320
msgid ""
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file in a way that accommodates renaming, removal and creation.\n"
msgstr ""
"如果您希望即时追查一个文件的有效名称而非描述内容(例如循环日志)，默认\n"
"的程序动作并不如您所愿。在这种场合可以使用--follow=name 选项，它会使\n"
"tail 定期追踪打开给定名称的文件，以确认它是否被删除或被其它某些程序重新创建过。\n"

#: src/tail.c:393
#, c-format
msgid "closing %s (fd=%d)"
msgstr "正在关闭 %s (fd=%d)"

#: src/tail.c:492
#, c-format
msgid "%s: cannot seek to end-relative offset %s"
msgstr "%s：无法检索相对偏移量的末尾 %s"

#: src/tail.c:927
#, c-format
msgid "cannot determine location of %s. reverting to polling"
msgstr "无法定位 %s 的位置，回归为 polling 机制"

#: src/tail.c:983
#, c-format
msgid "%s has been replaced with an untailable symbolic link"
msgstr ""

#: src/tail.c:998
#, c-format
msgid "%s has become inaccessible"
msgstr "%s 已不可访问"

#: src/tail.c:1016
#, c-format
msgid "%s has been replaced with an untailable file%s"
msgstr ""

#: src/tail.c:1018 src/tail.c:2024
msgid "; giving up on this name"
msgstr ""

#: src/tail.c:1024
#, c-format
msgid "%s has been replaced with an untailable remote file"
msgstr ""

#: src/tail.c:1045
#, c-format
msgid "%s has become accessible"
msgstr "%s 已经可以访问"

#: src/tail.c:1057
#, c-format
msgid "%s has appeared;  following new file"
msgstr ""

#: src/tail.c:1067
#, c-format
msgid "%s has been replaced;  following new file"
msgstr ""

#: src/tail.c:1182
#, c-format
msgid "%s: cannot change nonblocking mode"
msgstr "%s：无法更改非阻塞模式"

#: src/tail.c:1228 src/tail.c:1403
#, c-format
msgid "%s: file truncated"
msgstr "%s：文件已截断"

#: src/tail.c:1262 src/tail.c:1604
#, c-format
msgid "no files remaining"
msgstr "没有剩余文件"

#: src/tail.c:1498
#, c-format
msgid "cannot watch parent directory of %s"
msgstr "无法监视%s 的上级目录"

#: src/tail.c:1501 src/tail.c:1518 src/tail.c:1728
#, c-format
msgid "inotify resources exhausted"
msgstr "inotify 资源耗尽"

#: src/tail.c:1522 src/tail.c:1736
#, c-format
msgid "cannot watch %s"
msgstr "无法监视 %s"

#: src/tail.c:1571
#, c-format
msgid "%s was replaced"
msgstr "%s 已被替换"

#: src/tail.c:1643
msgid "error waiting for inotify and output events"
msgstr ""

#: src/tail.c:1671
msgid "error reading inotify event"
msgstr "读取inotify 事件出错"

#: src/tail.c:1690
#, c-format
msgid "directory containing watched file was removed"
msgstr ""

#: src/tail.c:2022
#, c-format
msgid "%s: cannot follow end of this type of file%s"
msgstr ""

#: src/tail.c:2203
msgid "invalid maximum number of unchanged stats between opens"
msgstr ""

#: src/tail.c:2211
msgid "invalid PID"
msgstr "无效的进程号（PID）"

#: src/tail.c:2227
#, c-format
msgid "invalid number of seconds: %s"
msgstr "无效的秒数：%s"

#: src/tail.c:2246
#, c-format
msgid "option used in invalid context -- %c"
msgstr "在未定义环境中的无效选项 -- %c"

#: src/tail.c:2258
#, c-format
msgid "warning: --retry ignored; --retry is useful only when following"
msgstr "警告：已忽略 --retry；只有在跟随模式下 --retry 选项才是有用的"

#: src/tail.c:2262
#, c-format
msgid "warning: --retry only effective for the initial open"
msgstr ""

#: src/tail.c:2267
#, c-format
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr "警告：已忽略进程号，只有在跟随模式下--pid=PID 选项才是有用的"

#: src/tail.c:2270
#, c-format
msgid "warning: --pid=PID is not supported on this system"
msgstr "警告：此系统不支持--pid=PID"

#: src/tail.c:2376
#, c-format
msgid "cannot follow %s by name"
msgstr "无法按名称跟随%s"

#: src/tail.c:2391
#, c-format
msgid "warning: following standard input indefinitely is ineffective"
msgstr "警告：无限期跟随标准输入是无用的"

#: src/tail.c:2488
#, c-format
msgid "inotify cannot be used, reverting to polling"
msgstr "无法使用 inotify 机制，回退为轮询（polling）机制"

#: src/tee.c:88
msgid ""
"Copy standard input to each FILE, and also to standard output.\n"
"\n"
"  -a, --append              append to the given FILEs, do not overwrite\n"
"  -i, --ignore-interrupts   ignore interrupt signals\n"
msgstr ""
"将标准输入复制到每个指定文件，并显示到标准输出。\n"
"\n"
"  -a, --append\t\t内容追加到给定的文件而非覆盖\n"
"  -i, --ignore-interrupts\t忽略中断信号\n"

#: src/tee.c:94
msgid ""
"  -p                        diagnose errors writing to non pipes\n"
"      --output-error[=MODE]   set behavior on write error.  See MODE below\n"
msgstr ""
"  -p                        对写入非管道的行为排查错误\n"
"      --output-error[=模式]   设置写入出错时的行为。见下面“模式”部分\n"

#: src/tee.c:100
msgid ""
"\n"
"MODE determines behavior with write errors on the outputs:\n"
"  'warn'         diagnose errors writing to any output\n"
"  'warn-nopipe'  diagnose errors writing to any output not a pipe\n"
"  'exit'         exit on error writing to any output\n"
"  'exit-nopipe'  exit on error writing to any output not a pipe\n"
"The default MODE for the -p option is 'warn-nopipe'.\n"
"The default operation when --output-error is not specified, is to\n"
"exit immediately on error writing to a pipe, and diagnose errors\n"
"writing to non pipe outputs.\n"
msgstr ""
"\n"
"模式确定向输出写入出错时的行为：\n"
"  'warn'         对向任何文件输出出错的情况进行诊断\n"
"  'warn-nopipe'  对向除了管道以外的任何文件输出出错的情况进行诊断\n"
"  'exit'         一旦输出出错，则退出程序\n"
"  'exit-nopipe'  一旦输出出错且非管道，则退出程序\n"
"-p 选项的默认模式是“warn-nopipe”。\n"
"当 --output-error 没有给出时，默认的操作是在向管道写入出错时立刻退出，\n"
"且在向非管道写入出错时对问题进行诊断。\n"

#: src/test.c:127
#, c-format
msgid "missing argument after %s"
msgstr "%s 后缺少参数"

#: src/test.c:163
#, c-format
msgid "invalid integer %s"
msgstr "无效的整数 %s"

#: src/test.c:245
#, c-format
msgid "%s expected"
msgstr "预期得到 %s"

#: src/test.c:248
#, c-format
msgid "%s expected, found %s"
msgstr "预期得到 %s，实际得到 %s"

#: src/test.c:265 src/test.c:623
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: 预期为单目运算符"

#: src/test.c:334
msgid "-nt does not accept -l"
msgstr "-nt 不能与-l 同时使用"

#: src/test.c:347
msgid "-ef does not accept -l"
msgstr "-ef 不能与-l 同时使用"

#: src/test.c:363
msgid "-ot does not accept -l"
msgstr "-ot 不能于-l 同时使用"

#: src/test.c:372
#, c-format
msgid "%s: unknown binary operator"
msgstr "%s：未知双目运算符"

#: src/test.c:651
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: 预期为双目运算符"

#: src/test.c:709
msgid ""
"Usage: test EXPRESSION\n"
"  or:  test\n"
"  or:  [ EXPRESSION ]\n"
"  or:  [ ]\n"
"  or:  [ OPTION\n"
msgstr ""
"用法：%s 表达式\n"
"　或：test\n"
"　或：[表达式]\n"
"　或：[ ]\n"
"　或：[ 选项\n"

#: src/test.c:716
msgid ""
"Exit with the status determined by EXPRESSION.\n"
"\n"
msgstr ""
"退出状态值取决于表达式。\n"
"\n"

#: src/test.c:722
msgid ""
"\n"
"An omitted EXPRESSION defaults to false.  Otherwise,\n"
"EXPRESSION is true or false and sets exit status.  It is one of:\n"
msgstr ""
"\n"
"被省略的表达式的值默认为假，否则可能为真也可能为假，\n"
"并会被设为退出状态值。有效的表达式应属于下列之一：\n"

#: src/test.c:727
msgid ""
"\n"
"  ( EXPRESSION )               EXPRESSION is true\n"
"  ! EXPRESSION                 EXPRESSION is false\n"
"  EXPRESSION1 -a EXPRESSION2   both EXPRESSION1 and EXPRESSION2 are true\n"
"  EXPRESSION1 -o EXPRESSION2   either EXPRESSION1 or EXPRESSION2 is true\n"
msgstr ""
"\n"
"  ( 表达式 )\t\t表达式的值为真\n"
"  ! 表达式\t\t表达式的值为假(非)\n"
"  表达式1 -a 表达式2\t两个表达式的值都为真时结果为真(与)\n"
"  表达式1 -o 表达式2\t两个表达式中任一的值为真时结果为真(或)\n"

#: src/test.c:734
msgid ""
"\n"
"  -n STRING            the length of STRING is nonzero\n"
"  STRING               equivalent to -n STRING\n"
"  -z STRING            the length of STRING is zero\n"
"  STRING1 = STRING2    the strings are equal\n"
"  STRING1 != STRING2   the strings are not equal\n"
msgstr ""
"\n"
"  -n 字符串\t\t字符串的长度非零\n"
"  字符串\t\t等于\"-n 字符串\"\n"
"  -z 字符串\t\t字符串的长度为零\n"
"  字符串1 = 字符串2\t两个字符串相等\n"
"  字符串1 != 字符串2\t两个字符串不等\n"

#: src/test.c:742
msgid ""
"\n"
"  INTEGER1 -eq INTEGER2   INTEGER1 is equal to INTEGER2\n"
"  INTEGER1 -ge INTEGER2   INTEGER1 is greater than or equal to INTEGER2\n"
"  INTEGER1 -gt INTEGER2   INTEGER1 is greater than INTEGER2\n"
"  INTEGER1 -le INTEGER2   INTEGER1 is less than or equal to INTEGER2\n"
"  INTEGER1 -lt INTEGER2   INTEGER1 is less than INTEGER2\n"
"  INTEGER1 -ne INTEGER2   INTEGER1 is not equal to INTEGER2\n"
msgstr ""
"\n"
"  整数1 -eq 整数2\t整数1 等于整数2\n"
"  整数1 -ge 整数2\t整数1 大于等于整数2\n"
"  整数1 -gt 整数2\t整数1 大于 整数2\n"
"  整数1 -le 整数2\t整数1 大于等于整数2\n"
"  整数1 -lt 整数2\t整数1 小于 整数2\n"
"  整数1 -ne 整数2\t整数1 不等于整数2\n"

#: src/test.c:751
msgid ""
"\n"
"  FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inode numbers\n"
"  FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2\n"
"  FILE1 -ot FILE2   FILE1 is older than FILE2\n"
msgstr ""
"\n"
"  文件1 -ef  文件2\t文件1 与文件2 的设备和节点号相等\n"
"  文件1 -nt  文件2\t文件1 的上次修改时间新于文件2\n"
"  文件1 -ot  文件2\t文件1 的上次修改时间旧于文件2\n"

#: src/test.c:757
msgid ""
"\n"
"  -b FILE     FILE exists and is block special\n"
"  -c FILE     FILE exists and is character special\n"
"  -d FILE     FILE exists and is a directory\n"
"  -e FILE     FILE exists\n"
msgstr ""
"\n"
"  -b 文件\t\t指定文件存在且为块设备文件\n"
"  -c 文件\t\t指定文件存在且为字符设备文件\n"
"  -d 文件\t\t指定文件存在且为目录\n"
"  -e 文件\t\t指定文件存在\n"

#: src/test.c:764
msgid ""
"  -f FILE     FILE exists and is a regular file\n"
"  -g FILE     FILE exists and is set-group-ID\n"
"  -G FILE     FILE exists and is owned by the effective group ID\n"
"  -h FILE     FILE exists and is a symbolic link (same as -L)\n"
"  -k FILE     FILE exists and has its sticky bit set\n"
msgstr ""
"  -f 文件\t\t指定文件存在且为普通文件\n"
"  -g 文件\t\t指定文件存在且设置了setgid 位\n"
"  -G 文件\t\t指定文件存在且属组ID 有效\n"
"  -h 文件\t\t指定文件存在且为符号链接 (等价于 -L)\n"
"  -k 文件\t\t指定文件存在且设置了粘附位\n"

#: src/test.c:771
msgid ""
"  -L FILE     FILE exists and is a symbolic link (same as -h)\n"
"  -O FILE     FILE exists and is owned by the effective user ID\n"
"  -p FILE     FILE exists and is a named pipe\n"
"  -r FILE     FILE exists and read permission is granted\n"
"  -s FILE     FILE exists and has a size greater than zero\n"
msgstr ""
"  -L 文件\t\t指定文件存在且为符号链接(等于-h)\n"
"  -O 文件\t\t指定文件存在且属主ID 有效\n"
"  -p 文件\t\t指定文件存在且为命名管道\n"
"  -r 文件\t\t指定文件存在且具备读取权限\n"
"  -s 文件\t\t指定文件存在且其大小大于0\n"

#: src/test.c:778
msgid ""
"  -S FILE     FILE exists and is a socket\n"
"  -t FD       file descriptor FD is opened on a terminal\n"
"  -u FILE     FILE exists and its set-user-ID bit is set\n"
"  -w FILE     FILE exists and write permission is granted\n"
"  -x FILE     FILE exists and execute (or search) permission is granted\n"
msgstr ""
"  -S 文件\t\t指定文件存在且为套接字文件\n"
"  -t FD\t\t\t已有一个终端打开了文件的描述符FD\n"
"  -u 文件\t\t指定文件存在且设置了setuid 位\n"
"  -w 文件\t\t指定文件存在且具备写入权限\n"
"  -x 文件\t\t指定文件存在且具备执行或搜索(针对目录)权限\n"

#: src/test.c:785
msgid ""
"\n"
"Except for -h and -L, all FILE-related tests dereference symbolic links.\n"
"Beware that parentheses need to be escaped (e.g., by backslashes) for "
"shells.\n"
"INTEGER may also be -l STRING, which evaluates to the length of STRING.\n"
msgstr ""
"\n"
"除-h 和-L 以外，其它所有与指定文件相关的测试都会作用于符号链接。\n"
"请留心您在必要时需由shell 转义圆括号字符(例如使用反斜杠)。\n"
"指定整数也可用\"-l 字符串\"表示，这会估算相应字符串的长度。\n"

#: src/test.c:791
msgid ""
"\n"
"NOTE: Binary -a and -o are inherently ambiguous.  Use 'test EXPR1 && test\n"
"EXPR2' or 'test EXPR1 || test EXPR2' instead.\n"
msgstr ""

#: src/test.c:796
msgid ""
"\n"
"NOTE: [ honors the --help and --version options, but test does not.\n"
"test treats each of those as it treats any other nonempty STRING.\n"
msgstr ""
"\n"
"注意：[ 服从 --help 和 --version 选项但 test 不同。\n"
"test 将其和其他非空字符串同能对待。\n"

#: src/test.c:801
msgid "test and/or ["
msgstr "test 和/或["

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:813
msgid "Kevin Braunsdorf"
msgstr "Kevin Braunsdorf"

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:814
msgid "Matthew Bradburn"
msgstr "Matthew Bradburn"

#: src/test.c:868
#, c-format
msgid "missing %s"
msgstr "缺少 %s"

#: src/test.c:882
#, c-format
msgid "extra argument %s"
msgstr "多余的参数 %s"

#: src/timeout.c:135
#, c-format
msgid "warning: timer_settime"
msgstr "警告：timer_settime"

#: src/timeout.c:140
#, c-format
msgid "warning: timer_create"
msgstr "警告：timer_create"

#: src/timeout.c:207
#, c-format
msgid "sending signal %s to command %s"
msgstr "正在发送信号 %s 至命令 %s"

#: src/timeout.c:235
#, c-format
msgid ""
"Usage: %s [OPTION] DURATION COMMAND [ARG]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"用法：%s [选项] 停留时间 命令 [参数]...\n"
"　或：%s 选项\n"

#: src/timeout.c:239
msgid "Start COMMAND, and kill it if still running after DURATION.\n"
msgstr "运行指定命令，在指定的停留时间后若该命令仍在运行则将其中止。\n"

#: src/timeout.c:245
msgid ""
"      --preserve-status\n"
"                 exit with the same status as COMMAND, even when the\n"
"                   command times out\n"
"      --foreground\n"
"                 when not running timeout directly from a shell prompt,\n"
"                   allow COMMAND to read from the TTY and get TTY signals;\n"
"                   in this mode, children of COMMAND will not be timed out\n"
"  -k, --kill-after=DURATION\n"
"                 also send a KILL signal if COMMAND is still running\n"
"                   this long after the initial signal was sent\n"
"  -s, --signal=SIGNAL\n"
"                 specify the signal to be sent on timeout;\n"
"                   SIGNAL may be a name like 'HUP' or a number;\n"
"                   see 'kill -l' for a list of signals\n"
msgstr ""

#: src/timeout.c:260
msgid "  -v, --verbose  diagnose to stderr any signal sent upon timeout\n"
msgstr ""

#: src/timeout.c:266
msgid ""
"\n"
"DURATION is a floating point number with an optional suffix:\n"
"'s' for seconds (the default), 'm' for minutes, 'h' for hours or 'd' for "
"days.\n"
"A duration of 0 disables the associated timeout.\n"
msgstr ""

#: src/timeout.c:271
msgid ""
"\n"
"If the command times out, and --preserve-status is not set, then exit with\n"
"status 124.  Otherwise, exit with the status of COMMAND.  If no signal\n"
"is specified, send the TERM signal upon timeout.  The TERM signal kills\n"
"any process that does not block or catch that signal.  It may be necessary\n"
"to use the KILL (9) signal, since this signal cannot be caught, in which\n"
"case the exit status is 128+9 rather than 124.\n"
msgstr ""

#: src/timeout.c:346 src/timeout.c:403
#, c-format
msgid "warning: sigprocmask"
msgstr "警告：sigprocmask"

#: src/timeout.c:425
#, c-format
msgid "warning: disabling core dumps failed"
msgstr ""

#: src/timeout.c:544
#, c-format
msgid "error waiting for command"
msgstr "等待命令出错"

#: src/timeout.c:555
#, c-format
msgid "the monitored command dumped core"
msgstr "监视的命令已核心转储"

#: src/timeout.c:568
#, c-format
msgid "unknown status from command (%d)"
msgstr "来自命令的未知状态（%d）"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:44
msgid "Jim Kingdon"
msgstr "Jim Kingdon"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:46
msgid "Randy Smith"
msgstr "Randy Smith"

#: src/touch.c:116 src/touch.c:310
#, c-format
msgid "invalid date format %s"
msgstr "日期格式 %s 无效"

#: src/touch.c:192
#, c-format
msgid "cannot touch %s"
msgstr "无法创建 %s"

#: src/touch.c:198
#, c-format
msgid "setting times of %s"
msgstr "正在设置 %s 的时间"

#: src/touch.c:214
msgid ""
"Update the access and modification times of each FILE to the current time.\n"
"\n"
"A FILE argument that does not exist is created empty, unless -c or -h\n"
"is supplied.\n"
"\n"
"A FILE argument string of - is handled specially and causes touch to\n"
"change the times of the file associated with standard output.\n"
msgstr ""

#: src/touch.c:226
msgid ""
"  -a                     change only the access time\n"
"  -c, --no-create        do not create any files\n"
"  -d, --date=STRING      parse STRING and use it instead of current time\n"
"  -f                     (ignored)\n"
msgstr ""
"  -a\t\t\t只更改访问时间\n"
"  -c, --no-create\t不创建任何文件\n"
"  -d, --date=字符串\t使用指定字符串表示时间而非当前时间\n"
"  -f\t\t\t(忽略)\n"

#: src/touch.c:232
msgid ""
"  -h, --no-dereference   affect each symbolic link instead of any "
"referenced\n"
"                         file (useful only on systems that can change the\n"
"                         timestamps of a symlink)\n"
"  -m                     change only the modification time\n"
msgstr ""
"  -h, --no-dereference\t\t会影响符号链接本身，而非符号链接所指示的目的地\n"
"\t\t\t\t(当系统支持更改符号链接的所有者时，此选项才有用)\n"
"  -m\t\t\t只更改修改时间\n"

#: src/touch.c:238
msgid ""
"  -r, --reference=FILE   use this file's times instead of current time\n"
"  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time\n"
"      --time=WORD        change the specified time:\n"
"                           WORD is access, atime, or use: equivalent to -a\n"
"                           WORD is modify or mtime: equivalent to -m\n"
msgstr ""

#: src/touch.c:247
msgid ""
"\n"
"Note that the -d and -t options accept different time-date formats.\n"
msgstr ""
"\n"
"请注意，-d 和-t 选项可接受不同的时间/日期格式。\n"

#: src/touch.c:336
#, c-format
msgid "cannot specify times from more than one source"
msgstr "无法由多于一种的来源来指定时间"

#: src/touch.c:410
#, c-format
msgid ""
"warning: 'touch %s' is obsolete; use 'touch -t %04ld%02d%02d%02d%02d.%02d'"
msgstr ""

#: src/tr.c:287
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "用法：%s [选项]... SET1 [SET2]\n"

#: src/tr.c:291
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, -C, --complement    use the complement of SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace each sequence of a repeated character\n"
"                            that is listed in the last specified SET,\n"
"                            with a single occurrence of that character\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
msgstr ""

#: src/tr.c:304
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
msgstr ""
"\n"
"SET 是一组字符串，一般都可按照字面含义理解。解析序列如下：\n"
"\n"
"  \\NNN\t八进制值为NNN 的字符(1 至3 个数位)\n"
"  \\\\\t\t反斜杠\n"
"  \\a\t\t终端鸣响\n"
"  \\b\t\t退格\n"
"  \\f\t\t换页\n"
"  \\n\t\t换行\n"
"  \\r\t\t回车\n"
"  \\t\t\t水平制表符\n"

#: src/tr.c:318
msgid ""
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
msgstr ""
"  \\v\t\t垂直制表符\n"
"  字符1-字符2\t从字符1 到字符2 的升序递增过程中经历的所有字符\n"
"  [字符*]\t在SET2 中适用，指定字符会被连续复制直到吻合设置1 的长度\n"
"  [字符*次数]\t对字符执行指定次数的复制，若次数以 0 开头则被视为八进制数\n"
"  [:alnum:]\t所有的字母和数字\n"
"  [:alpha:]\t所有的字母\n"
"  [:blank:]\t所有呈水平排列的空白字符\n"
"  [:cntrl:]\t所有的控制字符\n"
"  [:digit:]\t所有的数字\n"

#: src/tr.c:329
msgid ""
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"  [:graph:]\t所有的可打印字符，不包括空格\n"
"  [:lower:]\t所有的小写字母\n"
"  [:print:]\t所有的可打印字符，包括空格\n"
"  [:punct:]\t所有的标点字符\n"
"  [:space:]\t所有呈水平或垂直排列的空白字符\n"
"  [:upper:]\t所有的大写字母\n"
"  [:xdigit:]\t所有的十六进制数\n"
"  [=字符=]\t所有和指定字符相等的字符\n"

#: src/tr.c:339
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  -s uses the last\n"
"specified SET, and occurs after translation or deletion.\n"
msgstr ""

#: src/tr.c:507
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, %c"
msgstr "警告：含义不清的八进制内容 \\%c%c%c 已被视作为双字节序列 \\0%c%c, %c 处理"

#: src/tr.c:516
#, c-format
msgid "warning: an unescaped backslash at end of string is not portable"
msgstr "警告：在字符串结尾使用为转义的反斜杠是一种不可移植的做法"

#: src/tr.c:666
#, c-format
msgid "range-endpoints of '%s-%s' are in reverse collating sequence order"
msgstr ""

#: src/tr.c:812
#, c-format
msgid "invalid repeat count %s in [c*n] construct"
msgstr "在参数结构 [c*n] 中有无效的重复次数%s"

#: src/tr.c:888
#, c-format
msgid "missing character class name '[::]'"
msgstr ""

#: src/tr.c:891
#, c-format
msgid "missing equivalence class character '[==]'"
msgstr ""

#: src/tr.c:906
#, c-format
msgid "invalid character class %s"
msgstr "无效的字符类型%s"

#: src/tr.c:925
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s：同类操作数必须是单个字符"

#: src/tr.c:1205
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "[:upper:] 和/或[:lower:] 的结构对齐不完整"

#: src/tr.c:1309
msgid "too many characters in set"
msgstr "设置中的字符数量过多"

#: src/tr.c:1393
msgid ""
"when translating with string1 longer than string2,\n"
"the latter string must not end with a character class"
msgstr "当字符串1 长度大于字符串2时，后者不能以字符类结尾"

#: src/tr.c:1449
msgid "the [c*] repeat construct may not appear in string1"
msgstr "在字符串1 中不能出现[c*] 结构的重复次数声明"

#: src/tr.c:1459
msgid "only one [c*] repeat construct may appear in string2"
msgstr "在字符串2 中只能出现一次[c*] 结构的重复次数声明"

#: src/tr.c:1467
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr "在替换操作中字符串2 里不能出现表达式[=c=]"

#: src/tr.c:1474
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are 'upper' and 'lower'"
msgstr ""

#: src/tr.c:1489
msgid "when not truncating set1, string2 must be non-empty"
msgstr "当不截断设置1 时，字符串2 不能为空"

#: src/tr.c:1498
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr "当以反相模式替换字符类型时，字符串2 必须将所有字符映射到一个字域"

#: src/tr.c:1507
msgid "the [c*] construct may appear in string2 only when translating"
msgstr "当进行替换操作时[c*] 结构的参数只能出现在字符串2 中"

#: src/tr.c:1759
msgid "Two strings must be given when both deleting and squeezing repeats."
msgstr "当同时重复删除和缩减时必须给出两组字符串。"

#: src/tr.c:1761
msgid "Two strings must be given when translating."
msgstr "当进行替换操作时必须给定两组字符串。"

#: src/tr.c:1771
msgid "Only one string may be given when deleting without squeezing repeats."
msgstr "当进行不含缩减的删除操作时只能给定一组字符串。"

#: src/true.c:38
#, c-format
msgid ""
"Usage: %s [ignored command line arguments]\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s [忽略任何命令行参数]\n"
"　或：%s 选项\n"

#: src/true.c:45
msgid "Exit with a status code indicating success."
msgstr "以表示成功的状态值退出"

#: src/true.c:46
msgid "Exit with a status code indicating failure."
msgstr "以表示失败的状态值退出"

#: src/truncate.c:70
#, c-format
msgid "Usage: %s OPTION... FILE...\n"
msgstr "用法：%s 选项... 文件...\n"

#: src/truncate.c:71
msgid ""
"Shrink or extend the size of each FILE to the specified size\n"
"\n"
"A FILE argument that does not exist is created.\n"
"\n"
"If a FILE is larger than the specified size, the extra data is lost.\n"
"If a FILE is shorter, it is extended and the extended part (hole)\n"
"reads as zero bytes.\n"
msgstr ""

#: src/truncate.c:83
msgid "  -c, --no-create        do not create any files\n"
msgstr "  -c, --no-create\t不创建文件\n"

#: src/truncate.c:86
msgid ""
"  -o, --io-blocks        treat SIZE as number of IO blocks instead of bytes\n"
msgstr "  -o, --io-blocks\t将SIZE 视为IO 块数而不使用字节数\n"

#: src/truncate.c:89
msgid ""
"  -r, --reference=RFILE  base size on RFILE\n"
"  -s, --size=SIZE        set or adjust the file size by SIZE bytes\n"
msgstr ""

#: src/truncate.c:95
msgid ""
"\n"
"SIZE may also be prefixed by one of the following modifying characters:\n"
"'+' extend by, '-' reduce by, '<' at most, '>' at least,\n"
"'/' round down to multiple of, '%' round up to multiple of.\n"
msgstr ""

#: src/truncate.c:123
#, c-format
msgid "overflow in %<PRIdMAX> * %<PRIdMAX> byte blocks for file %s"
msgstr "在文件%3$s 的%1$<PRIdMAX> * %2$<PRIdMAX> 字节块中溢出"

#: src/truncate.c:147
#, c-format
msgid "%s has unusable, apparently negative size"
msgstr "%s 的文件大小为负数，无法使用"

#: src/truncate.c:157 src/truncate.c:359
#, c-format
msgid "cannot get the size of %s"
msgstr "无法获得%s 的大小"

#: src/truncate.c:179
#, c-format
msgid "overflow rounding up size of file %s"
msgstr "处理大于等于文件%s 的指定大小的最大倍数时溢出"

#: src/truncate.c:189
#, c-format
msgid "overflow extending size of file %s"
msgstr "扩展文件%s 大小时溢出"

#: src/truncate.c:204
#, c-format
msgid "failed to truncate %s at %<PRIdMAX> bytes"
msgstr "在%2$<PRIdMAX> 字节处截断%1$s 失败"

#: src/truncate.c:277
#, c-format
msgid "multiple relative modifiers specified"
msgstr "指定了多个相关修饰符"

#: src/truncate.c:286
msgid "Invalid number"
msgstr "无效的数字"

#: src/truncate.c:308
#, c-format
msgid "you must specify either %s or %s"
msgstr "您必须在 %s 或 %s 中指定一个"

#: src/truncate.c:315
#, c-format
msgid "you must specify a relative %s with %s"
msgstr "您必须为 %2$s 中指定一个相关的 %1$s"

#: src/truncate.c:322
#, c-format
msgid "%s was specified but %s was not"
msgstr "已指定 %s 但未指定 %s"

#: src/truncate.c:379
#, c-format
msgid "cannot open %s for writing"
msgstr "无法打开 %s 以写入数据"

#. This is a proper name. See the gettext manual, section Names.
#: src/tsort.c:41
msgid "Mark Kettenis"
msgstr "Mark Kettenis"

#: src/tsort.c:88
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
msgstr ""

#: src/tsort.c:95 src/uptime.c:218
#, c-format
msgid "\n"
msgstr "\n"

#: src/tsort.c:481
#, c-format
msgid "%s: input contains an odd number of tokens"
msgstr "%s：输入内容的行数为奇数"

#: src/tsort.c:527
#, c-format
msgid "%s: input contains a loop:"
msgstr "%s：输入内容中含有循环段落："

#: src/tty.c:66
msgid ""
"Print the file name of the terminal connected to standard input.\n"
"\n"
"  -s, --silent, --quiet   print nothing, only return an exit status\n"
msgstr ""
"显示出连接到当前标准输入的终端设备文件名。\n"
"\n"
"  -s, --silent, --quiet\t什么也不显示，只返回退出状态值\n"

#: src/tty.c:127
msgid "not a tty"
msgstr "不是一个 tty"

#: src/uname.c:125
msgid ""
"Print certain system information.  With no OPTION, same as -s.\n"
"\n"
"  -a, --all                print all information, in the following order,\n"
"                             except omit -p and -i if unknown:\n"
"  -s, --kernel-name        print the kernel name\n"
"  -n, --nodename           print the network node hostname\n"
"  -r, --kernel-release     print the kernel release\n"
msgstr ""
"输出一组系统信息。如果不跟随选项，则视为只附加 -s 选项。\n"
"\n"
"  -a, --all                以如下次序输出所有信息。其中若 -p 和\n"
"                             -i 的探测结果不可知则被省略：\n"
"  -s, --kernel-name        输出内核名称\n"
"  -n, --nodename           输出网络节点上的主机名\n"
"  -r, --kernel-release     输出内核发行号\n"

#: src/uname.c:134
msgid ""
"  -v, --kernel-version     print the kernel version\n"
"  -m, --machine            print the machine hardware name\n"
"  -p, --processor          print the processor type (non-portable)\n"
"  -i, --hardware-platform  print the hardware platform (non-portable)\n"
"  -o, --operating-system   print the operating system\n"
msgstr ""
"  -v, --kernel-version     输出内核版本\n"
"  -m, --machine            输出主机的硬件架构名称\n"
"  -p, --processor          输出处理器类型（不可移植）\n"
"  -i, --hardware-platform  输出硬件平台或（不可移植）\n"
"  -o, --operating-system   输出操作系统名称\n"

#: src/uname.c:144
msgid ""
"Print machine architecture.\n"
"\n"
msgstr ""
"输出机器的体系结构。\n"
"\n"

#: src/uname.c:287
msgid "cannot get system name"
msgstr "无法获取系统名"

#: src/unexpand.c:82
msgid "Convert blanks in each FILE to tabs, writing to standard output.\n"
msgstr "将每个指定文件中的空白字符转换为制表符并写到标准输出。\n"

#: src/unexpand.c:89
msgid ""
"  -a, --all        convert all blanks, instead of just initial blanks\n"
"      --first-only  convert only leading sequences of blanks (overrides -a)\n"
"  -t, --tabs=N     have tabs N characters apart instead of 8 (enables -a)\n"
msgstr ""
"  -a, --all        转换所有空格，包括但不只是起始空格\n"
"      --first-only  仅转换起始空格（覆盖-a 选项）\n"
"  -t, --tabs=N     设置制表符宽度为 N 字符而非默认的 8（启用 -a 选项）\n"

#: src/unexpand.c:306
msgid "tab stop value is too large"
msgstr "制表符限长过大"

#: src/uniq.c:171
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "用法：%s [选项]... [文件]\n"

#: src/uniq.c:175
msgid ""
"Filter adjacent matching lines from INPUT (or standard input),\n"
"writing to OUTPUT (or standard output).\n"
"\n"
"With no options, matching lines are merged to the first occurrence.\n"
msgstr ""

#: src/uniq.c:184
msgid ""
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines, one for each group\n"
msgstr ""

#: src/uniq.c:188
msgid ""
"  -D                    print all duplicate lines\n"
"      --all-repeated[=METHOD]  like -D, but allow separating groups\n"
"                                 with an empty line;\n"
"                                 METHOD={none(default),prepend,separate}\n"
msgstr ""

#: src/uniq.c:194
msgid "  -f, --skip-fields=N   avoid comparing the first N fields\n"
msgstr ""

#: src/uniq.c:197
msgid ""
"      --group[=METHOD]  show all items, separating groups with an empty "
"line;\n"
"                          METHOD={separate(default),prepend,append,both}\n"
msgstr ""

#: src/uniq.c:201
msgid ""
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
msgstr ""

#: src/uniq.c:209
msgid "  -w, --check-chars=N   compare no more than N characters in lines\n"
msgstr "  -w, --check-chars=N\t对每行第N 个字符以后的内容不作对照\n"

#: src/uniq.c:214
msgid ""
"\n"
"A field is a run of blanks (usually spaces and/or TABs), then non-blank\n"
"characters.  Fields are skipped before chars.\n"
msgstr ""
"\n"
"若域中为先空字符(通常包括空格以及制表符)，然后非空字符，域中字符前的空字符将被跳过。\n"

#: src/uniq.c:219
msgid ""
"\n"
"Note: 'uniq' does not detect repeated lines unless they are adjacent.\n"
"You may want to sort the input first, or use 'sort -u' without 'uniq'.\n"
"Also, comparisons honor the rules specified by 'LC_COLLATE'.\n"
msgstr ""
"\n"
"提示：\"uniq\" 不会检查重复的行，除非它们是相邻的行。\n"
"您也许需要事先对输入排序，或使用 \"sort -u\" 而非 \"uniq\"。\n"
"另外，比较操作将服从 \"LC_COLLATE\" 环境变量所指定的规则。\n"

#: src/uniq.c:437
msgid "too many repeated lines"
msgstr "重复行过多"

#: src/uniq.c:613
msgid "invalid number of fields to skip"
msgstr "要略过的区块数量无效"

#: src/uniq.c:622
msgid "invalid number of bytes to skip"
msgstr "要略过的字节数量无效"

#: src/uniq.c:632
msgid "invalid number of bytes to compare"
msgstr "要对照的字节数量无效"

#: src/uniq.c:654
#, c-format
msgid "--group is mutually exclusive with -c/-d/-D/-u"
msgstr ""

#: src/uniq.c:661
#, c-format
msgid "grouping and printing repeat counts is meaningless"
msgstr ""

#: src/uniq.c:668
#, c-format
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr "同时输出重复的行和重复计数是没有意义的"

#: src/unlink.c:51
#, c-format
msgid ""
"Usage: %s FILE\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 文件\n"
"　或：%s 选项\n"

#: src/unlink.c:54
msgid ""
"Call the unlink function to remove the specified FILE.\n"
"\n"
msgstr ""
"调用 unlink 函数删除指定的文件。\n"
"\n"

#: src/uptime.c:131
msgid "couldn't get boot time"
msgstr "无法获取启动时间"

#. TRANSLATORS: This prints the current clock time.
#: src/uptime.c:142
msgid " %H:%M:%S  "
msgstr " %H:%M:%S  "

#: src/uptime.c:144
#, c-format
msgid " ??:????  "
msgstr " ??:????  "

#: src/uptime.c:146
#, c-format
msgid "up ???? days ??:??,  "
msgstr "已启动 ???? 天 ??:??，  "

#: src/uptime.c:150
#, c-format
msgid "up %ld day %2d:%02d,  "
msgid_plural "up %ld days %2d:%02d,  "
msgstr[0] "已启动 %ld 天%2d:%02d，  "

#: src/uptime.c:155
#, c-format
msgid "up  %2d:%02d,  "
msgstr "已启动 %2d:%02d，  "

#: src/uptime.c:157
#, c-format
msgid "%lu user"
msgid_plural "%lu users"
msgstr[0] "%lu 个用户"

#: src/uptime.c:167
#, c-format
msgid ",  load average: %.2f"
msgstr "，平均负载：%.2f"

#: src/uptime.c:205
#, c-format
msgid ""
"Print the current time, the length of time the system has been up,\n"
"the number of users on the system, and the average number of jobs\n"
"in the run queue over the last 1, 5 and 15 minutes."
msgstr ""
"输出当前时间，系统启动时间，当前登录用户数以及最近1、5 和15 分钟系统运行\n"
"队列中的平均任务数。"

#: src/uptime.c:214
#, c-format
msgid ""
"  Processes in\n"
"an uninterruptible sleep state also contribute to the load average.\n"
msgstr "  处于不可中断睡眠状态的程序同样影响系统平均负载。\n"

#: src/uptime.c:220
#, c-format
msgid ""
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"如果文件没有指定，则使用%s，%s 是通用的相关文件。\n"
"\n"

#: src/users.c:112
#, c-format
msgid ""
"Output who is currently logged in according to FILE.\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"根据文件判断输出当前有谁正登录在系统上。\n"
"如果文件未予指定，则使用%s，%s 是通用的相关文件。\n"
"\n"

#: src/wc.c:120
msgid ""
"Print newline, word, and byte counts for each FILE, and a total line if\n"
"more than one FILE is specified.  A word is a non-zero-length sequence of\n"
"characters delimited by white space.\n"
msgstr ""

#: src/wc.c:128
msgid ""
"\n"
"The options below may be used to select which counts are printed, always in\n"
"the following order: newline, word, character, byte, maximum line length.\n"
"  -c, --bytes            print the byte counts\n"
"  -m, --chars            print the character counts\n"
"  -l, --lines            print the newline counts\n"
msgstr ""

#: src/wc.c:136
msgid ""
"      --files0-from=F    read input from the files specified by\n"
"                           NUL-terminated names in file F;\n"
"                           If F is - then read names from standard input\n"
"  -L, --max-line-length  print the maximum display width\n"
"  -w, --words            print the word counts\n"
msgstr ""

#: src/who.c:213
msgid " old "
msgstr " 旧的 "

#: src/who.c:443
msgid "system boot"
msgstr "系统引导"

#: src/who.c:451 src/who.c:453
msgid "id="
msgstr "id="

#: src/who.c:466 src/who.c:471
msgid "term="
msgstr "终端="

#: src/who.c:468 src/who.c:472
msgid "exit="
msgstr "退出="

#: src/who.c:489
msgid "LOGIN"
msgstr "登录"

#: src/who.c:509
msgid "clock change"
msgstr "时钟更改"

#: src/who.c:521 src/who.c:522
msgid "run-level"
msgstr "运行级别"

#: src/who.c:525 src/who.c:526
msgid "last="
msgstr "最近="

#: src/who.c:557
#, c-format
msgid ""
"\n"
"# users=%lu\n"
msgstr ""
"\n"
"# 用户数=%lu\n"

#: src/who.c:563
msgid "NAME"
msgstr "名称"

#: src/who.c:563
msgid "LINE"
msgstr "线路"

#: src/who.c:563
msgid "TIME"
msgstr "时间"

#: src/who.c:563
msgid "IDLE"
msgstr "空闲"

#: src/who.c:564
msgid "PID"
msgstr "进程号"

#: src/who.c:564
msgid "COMMENT"
msgstr "备注"

#: src/who.c:564
msgid "EXIT"
msgstr "退出"

#: src/who.c:644
#, c-format
msgid "Usage: %s [OPTION]... [ FILE | ARG1 ARG2 ]\n"
msgstr "用法：%s [选项]... [ 文件 | 参数1 参数2 ]\n"

#: src/who.c:645
msgid "Print information about users who are currently logged in.\n"
msgstr "显示当前已登录的用户信息。\n"

#: src/who.c:648
msgid ""
"\n"
"  -a, --all         same as -b -d --login -p -r -t -T -u\n"
"  -b, --boot        time of last system boot\n"
"  -d, --dead        print dead processes\n"
"  -H, --heading     print line of column headings\n"
msgstr ""
"\n"
"  -a, --all\t\t等于-b -d --login -p -r -t -T -u 选项的组合\n"
"  -b, --boot\t\t上次系统启动时间\n"
"  -d, --dead\t\t显示已死的进程\n"
"  -H, --heading\t输出头部的标题列\n"

#: src/who.c:655
msgid "  -l, --login       print system login processes\n"
msgstr "  -l，--login\t\t显示系统登录进程\n"

#: src/who.c:658
msgid ""
"      --lookup      attempt to canonicalize hostnames via DNS\n"
"  -m                only hostname and user associated with stdin\n"
"  -p, --process     print active processes spawned by init\n"
msgstr ""
"      --lookup\t\t尝试通过 DNS 规范化主机名\n"
"  -m\t\t\t只针对和标准输入有直接交互的主机和用户\n"
"  -p, --process\t显示由 init 进程衍生的活动进程\n"

#: src/who.c:663
msgid ""
"  -q, --count       all login names and number of users logged on\n"
"  -r, --runlevel    print current runlevel\n"
"  -s, --short       print only name, line, and time (default)\n"
"  -t, --time        print last system clock change\n"
msgstr ""
"  -q, --count\t\t列出所有已登录用户的登录名与用户数量\n"
"  -r, --runlevel\t显示当前的运行级别\n"
"  -s, --short\t\t只显示名称、线路和时间(默认)\n"

#: src/who.c:669
msgid ""
"  -T, -w, --mesg    add user's message status as +, - or ?\n"
"  -u, --users       list users logged in\n"
"      --message     same as -T\n"
"      --writable    same as -T\n"
msgstr ""
"  -T, -w, --mesg\t用+，- 或 ? 标注用户消息状态\n"
"  -u, --users\t\t列出已登录的用户\n"
"      --message\t等于-T\n"
"      --writable\t等于-T\n"

#: src/who.c:677
#, c-format
msgid ""
"\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"If ARG1 ARG2 given, -m presumed: 'am i' or 'mom likes' are usual.\n"
msgstr ""

#: src/whoami.c:51
msgid ""
"Print the user name associated with the current effective user ID.\n"
"Same as id -un.\n"
"\n"
msgstr ""
"显示与当前的有效用户ID 相关联的用户名。\n"
"与id -un 相同。\n"
"\n"

#: src/whoami.c:93
#, c-format
msgid "cannot find name for user ID %lu"
msgstr "无法找到 ID 为 %lu 的用户的名称"

#: src/yes.c:47
#, c-format
msgid ""
"Usage: %s [STRING]...\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s [字符串]...\n"
"　或：%s 选项\n"

#: src/yes.c:53
msgid ""
"Repeatedly output a line with all specified STRING(s), or 'y'.\n"
"\n"
msgstr ""
